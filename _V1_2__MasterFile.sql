-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD


/* SECTION 1.1.1 - SDS Table Creation */

SET client_encoding TO 'UTF8';


SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS sds;
ALTER SCHEMA sds OWNER TO scd_testuser;

SET search_path = sds,oracle,public;


CREATE TABLE "a$lte" (
	spalte1 varchar(8)
) ;


CREATE TABLE adrarch (
	scdid char(32),
	scdidflag char(1),
	scdid_lfd numeric(38),
	insert_datum timestamp NOT NULL,
	c char(2),
	o char(16),
	ou char(32),
	l char(32),
	localityint char(32),
	localitynat varchar(32),
	salid char(16),
	cn varchar(64),
	sn char(64),
	snflag char(1),
	givenname char(40),
	givennameflag char(1),
	commonnamenat varchar(64),
	commonnamenatflag char(1),
	initials char(8),
	initialsflag char(1),
	gender char(1),
	genderflag char(1),
	personaltitle varchar(16),
	personaltitleflag char(1),
	graduatetitle varchar(16),
	graduatetitleflag char(1),
	mainfunction varchar(128),
	mainfunctionflag char(1),
	department varchar(64),
	departmentflag char(1),
	roomnumber varchar(16),
	roomnumberflag char(1),
	orgid varchar(255),
	orgidflag char(1),
	mail varchar(240),
	mailflag char(1),
	telephonenr char(32),
	telephonenrflag char(1),
	faxnr char(32),
	faxnrflag char(1),
	secretary varchar(255),
	secretaryflag char(1),
	repres varchar(255),
	represflag char(1),
	mobile char(32),
	mobileflag char(1),
	videokonf1 char(32),
	videokonf1flag char(1),
	videokonf2 char(32),
	videokonf2flag char(1),
	publickey char(1),
	publickeyflag char(1),
	pager char(32),
	pagerflag char(1),
	costlocation char(32),
	costlocationflag char(1),
	personalidnr char(32),
	personalidnrflag char(1),
	securephone char(1),
	securephoneflag char(1),
	alternphone char(32),
	alternphoneflag char(1),
	personalfax char(32),
	personalfaxflag char(1),
	securefax char(1),
	securefaxflag char(1),
	netmeeting varchar(128),
	netmeetingflag char(1),
	maident char(16),
	maidentflag char(1),
	gid char(8),
	gidflag char(1),
	postofficebox char(32),
	postofficeboxflag char(1),
	costlocationun char(4),
	costlocationunflag char(1),
	surnamenat varchar(40),
	surnamenatflag char(1),
	givennamenat varchar(40),
	givennamenatflag char(1),
	departmenttext varchar(255),
	departmenttextflag char(1),
	releaseext char(1),
	releaseextflag char(1),
	persrem varchar(255),
	persremflag char(1),
	url_personal varchar(255),
	url_personalflag char(1),
	scdrob char(8),
	scdrobflag char(1),
	recordtype char(8),
	recordtypeflag char(1),
	joindate char(15),
	joindateflag char(1),
	leavedate char(15),
	leavedateflag char(1),
	validdate char(15),
	validdateflag char(1),
	expiredate char(15),
	expiredateflag char(1),
	userpassword char(16),
	initpassword char(48),
	pwinittime char(15),
	initcounter char(4),
	initfailcounter char(4),
	loginpassword char(48),
	pwmodtime char(15),
	loginfailcounter char(4),
	pwhistory varchar(255),
	gapassword char(48),
	tcgid char(8),
	tcgidflag char(1),
	tcgid_lfd numeric(38),
	certindicator char(1),
	phonenumbers varchar(128),
	lieferantnr char(10),
	lieferantnrflag char(1),
	nickname varchar(40),
	nicknameflag char(1),
	orgcodeid char(8),
	unitid char(8),
	unit varchar(16),
	manager1 char(8),
	manager2 char(8),
	managerf1 char(8),
	managerf2 char(8),
	managerf3 char(8),
	departmentnat varchar(255),
	delegation char(1),
	itacc char(1),
	reqacc char(1),
	reqmail char(1),
	reqmbox char(1),
	reststart varchar(16),
	restend varchar(16),
	vip char(1),
	companycode char(1),
	mgmtresp char(32),
	notwebvisible char(2),
	mailpriv char(128),
	mobilepriv char(32)
) ;
ALTER  TABLE adrarch OWNER TO scd_testuser;
CREATE INDEX iemail ON adrarch (mail);
CREATE INDEX itcgid ON adrarch (tcgid);
CREATE INDEX ixadrarch ON adrarch (scdid, scdid_lfd, insert_datum);
ALTER TABLE adrarch ALTER COLUMN INSERT_DATUM SET NOT NULL;


CREATE TABLE adrdat (
	c char(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32),
	cn varchar(64),
	sn varchar(64),
	gn varchar(40),
	cnamnat varchar(64),
	snamnat varchar(40),
	snampre varchar(16),
	snamadd varchar(16),
	gnamnat varchar(40),
	lastnam varchar(40),
	i varchar(8),
	gender char(1),
	personaltitle varchar(16),
	graduatetitle varchar(16),
	mail varchar(240),
	department varchar(64),
	departmenttext varchar(255),
	mainfunc varchar(128),
	building varchar(32),
	roomnumber varchar(32),
	postofficebox varchar(32),
	telnumber varchar(32),
	alternphone varchar(32),
	securephone char(1),
	faxnumber varchar(32),
	personalfax varchar(32),
	faxnumsec char(1),
	mobile varchar(32),
	vidconfnum1 varchar(32),
	vidconfnum2 varchar(32),
	pager varchar(32),
	netmeeting char(1),
	urlpers varchar(255),
	persremark varchar(255),
	robinson char(8),
	secretary varchar(255),
	representation varchar(255),
	sponsor char(8),
	costlocation varchar(512),
	costlocunit varchar(32),
	orgid varchar(16),
	persidnum varchar(32),
	maident char(16),
	appkey varchar(16),
	scdid varchar(32),
	gid char(8),
	usertype char(1),
	recordtype char(1),
	contractstat char(1),
	joindate varchar(16),
	validdate varchar(16),
	leavedate varchar(16),
	expiredate varchar(16),
	releaseext char(1),
	liefntnr integer,
	liefnr integer,
	isinscd smallint,
	lieferkey varchar(255),
	nicknam varchar(40),
	orgcodeid char(8),
	unitid char(8),
	unit varchar(16),
	manager1 char(8),
	manager2 char(8),
	managerf1 char(8),
	managerf2 char(8),
	managerf3 char(8),
	departmentnat varchar(128),
	mastat char(1),
	azubiend varchar(16),
	reststart varchar(16),
	restend varchar(16),
	vip char(1),
	itacc char(1),
	delegation char(1),
	gpcompany varchar(40),
	reqpki char(1),
	reqbadge char(1),
	reqacc char(1),
	reqmbox char(1),
	reqmail char(1),
	companycode char(1),
	mgmtresp varchar(32),
	notwebvisible char(2),
	mailpriv varchar(128),
	mobilepriv varchar(32),
	gcc varchar(8),
	division varchar(8),
	orgidperiod char(6),
	orgidclass char(1),
	wcunit varchar(64),
	actiontype char(2),
	actionreason char(2),
	actionstart varchar(16),
	makreis varchar(32),
	magruppe varchar(32),
	juper varchar(32),
	prefsn varchar(64),
	orgleva varchar(64),
	orglevb varchar(64),
	orglevc varchar(64),
	orglevd varchar(64),
	orglevx varchar(64),
	altou varchar(32),
	fksource varchar(40),
	prefpronoun varchar(40),
	cofres char(2)
) ;
ALTER  TABLE adrdat OWNER TO scd_testuser;
CREATE INDEX ixadrdatcostlocation ON adrdat (costlocation);
CREATE INDEX ixadrdatcostlocunit ON adrdat (costlocunit);
CREATE INDEX ixadrdatgid ON adrdat (gid);
CREATE UNIQUE INDEX ixadrdatkey ON adrdat (lieferkey, liefntnr);
CREATE INDEX ixadrdatliefnr ON adrdat (liefnr);
CREATE INDEX ixadrdatmail ON adrdat (mail);


CREATE TABLE app_exec (
	id bigint GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1 MAXVALUE 9223372036854775807 MINVALUE 1 NO CYCLE CACHE 20 ),
	app_name varchar(64),
	host_name varchar(64),
	pid varchar(12),
	started timestamp,
	last_ping timestamp
) ;
ALTER  TABLE app_exec OWNER TO scd_testuser;
ALTER TABLE app_exec ALTER COLUMN ID SET NOT NULL;


CREATE TABLE attr (
	bez varchar(20),
	txt varchar(120),
	min smallint,
	max smallint,
	zchn varchar(255)
) ;
ALTER  TABLE attr OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixattr ON attr (bez);


CREATE TABLE attribute (
	m_o varchar(50),
	feldname_scd varchar(50) NOT NULL,
	attributname varchar(50),
	bezeichnung_de varchar(150),
	bezeichnung_en varchar(150),
	ldapname varchar(50),
	abbr varchar(50),
	impl_abbr varchar(50),
	name_schema varchar(50),
	typ varchar(50),
	stamm_adress varchar(50),
	index_ varchar(50),
	herkunft varchar(50),
	beispiel varchar(250),
	example varchar(250),
	beschreibung varchar(4000),
	description varchar(4000),
	anzeige varchar(50),
	verknadr bigint,
	verknstamm bigint,
	hilfe varchar(4000),
	help varchar(4000),
	source varchar(100),
	category varchar(100),
	link varchar(500),
	link_2nd varchar(500),
	gov_dept varchar(255),
	gov_contact varchar(500),
	parameter_value varchar(500),
	plausability_checks varchar(250)
) ;
ALTER  TABLE attribute OWNER TO scd_testuser;
ALTER TABLE attribute ALTER COLUMN FELDNAME_SCD SET NOT NULL;


CREATE TABLE attribute_old (
	order_ bigint,
	feldnr bigint NOT NULL,
	feld varchar(50),
	m_o varchar(50),
	feldname_scd varchar(50) NOT NULL,
	attributname varchar(50),
	bezeichnung_de varchar(150),
	bezeichnung_en varchar(150),
	ldapname varchar(50),
	abbr varchar(50),
	impl_abbr varchar(50),
	name_schema varchar(50),
	typ varchar(50),
	stamm_adress varchar(50),
	index_ varchar(50),
	herkunft varchar(50),
	beispiel varchar(250),
	example varchar(250),
	beschreibung varchar(255),
	description varchar(255),
	anzeige varchar(50),
	verknadr bigint,
	verknstamm bigint,
	hilfe varchar(4000),
	help varchar(4000)
) ;
ALTER  TABLE attribute_old OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixattribute ON attribute_old (feldname_scd);
ALTER TABLE attribute_old ALTER COLUMN FELDNR SET NOT NULL;
ALTER TABLE attribute_old ALTER COLUMN FELDNAME_SCD SET NOT NULL;


CREATE TABLE attrset (
	bez varchar(20),
	txt varchar(120),
	attr varchar(20),
	feldnr smallint NOT NULL,
	pflicht char(1)
) ;
ALTER  TABLE attrset OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixattrset ON attrset (bez, attr);
ALTER TABLE attrset ALTER COLUMN FELDNR SET NOT NULL;


CREATE TABLE attr_check_norm (
	bez varchar(20),
	normfunction varchar(255),
	checkfunction varchar(255),
	dbnormfunction varchar(255)
) ;
ALTER  TABLE attr_check_norm OWNER TO scd_testuser;


CREATE TABLE attr_disp_select (
	bez varchar(20),
	headline_de varchar(100),
	headline_en varchar(100),
	header_de varchar(4000),
	header_en varchar(4000),
	visible varchar(1),
	template varchar(50)
) ;
ALTER  TABLE attr_disp_select OWNER TO scd_testuser;


CREATE TABLE attr_utf8 (
	bez varchar(20) NOT NULL
) ;
ALTER  TABLE attr_utf8 OWNER TO scd_testuser;
ALTER TABLE attr_utf8 ADD PRIMARY KEY (bez);
ALTER TABLE attr_utf8 ALTER COLUMN BEZ SET NOT NULL;


CREATE TABLE batch_job_execution (
	job_execution_id bigint,
	version bigint,
	job_instance_id bigint,
	create_time timestamp,
	start_time timestamp,
	end_time timestamp,
	status varchar(10),
	exit_code varchar(2500),
	exit_message varchar(2500),
	last_updated timestamp,
	job_configuration_location varchar(2500)
) ;
ALTER  TABLE batch_job_execution OWNER TO scd_testuser;


CREATE TABLE batch_job_execution_context (
	job_execution_id bigint,
	short_context varchar(2500),
	serialized_context text
) ;
ALTER  TABLE batch_job_execution_context OWNER TO scd_testuser;


CREATE TABLE batch_job_execution_params (
	job_execution_id bigint,
	type_cd varchar(6),
	key_name varchar(100),
	string_val varchar(250),
	date_val timestamp,
	long_val bigint,
	double_val bigint,
	identifying char(1)
) ;
ALTER  TABLE batch_job_execution_params OWNER TO scd_testuser;


CREATE TABLE batch_job_instance (
	job_instance_id bigint,
	version bigint,
	job_name varchar(100),
	job_key varchar(32)
) ;
ALTER  TABLE batch_job_instance OWNER TO scd_testuser;


CREATE TABLE batch_step_execution (
	step_execution_id bigint,
	version bigint,
	step_name varchar(100),
	job_execution_id bigint,
	start_time timestamp,
	end_time timestamp,
	status varchar(10),
	commit_count bigint,
	read_count bigint,
	filter_count bigint,
	write_count bigint,
	read_skip_count bigint,
	write_skip_count bigint,
	process_skip_count bigint,
	rollback_count bigint,
	exit_code varchar(2500),
	exit_message varchar(2500),
	last_updated timestamp
) ;
ALTER  TABLE batch_step_execution OWNER TO scd_testuser;


CREATE TABLE batch_step_execution_context (
	step_execution_id bigint,
	short_context varchar(2500),
	serialized_context text
) ;
ALTER  TABLE batch_step_execution_context OWNER TO scd_testuser;


CREATE TABLE bdsg_escalation (
	sponsor_gid char(8) NOT NULL,
	supplier_id integer NOT NULL,
	escalation_type varchar(32) NOT NULL,
	email_counter integer NOT NULL
) ;
ALTER  TABLE bdsg_escalation OWNER TO scd_testuser;
ALTER TABLE bdsg_escalation ALTER COLUMN SPONSOR_GID SET NOT NULL;
ALTER TABLE bdsg_escalation ALTER COLUMN SUPPLIER_ID SET NOT NULL;
ALTER TABLE bdsg_escalation ALTER COLUMN ESCALATION_TYPE SET NOT NULL;
ALTER TABLE bdsg_escalation ALTER COLUMN EMAIL_COUNTER SET NOT NULL;


CREATE TABLE berch (
	berchnr integer,
	berchid varchar(120),
	stellvid varchar(120),
	nick varchar(120),
	berchsn varchar(64),
	berchgn varchar(40),
	berchc varchar(2),
	bercho varchar(16),
	berchou varchar(32),
	berchl varchar(32),
	berchdep varchar(40),
	stellvsn varchar(64),
	stellvgn varchar(40),
	stellvc varchar(2),
	stellvo varchar(16),
	stellvou varchar(32),
	stellvl varchar(32),
	stellvdep varchar(40),
	changedate timestamp,
	commitdate timestamp,
	accsa smallint,
	accsu smallint,
	remit smallint,
	remtool smallint,
	mail2req smallint,
	mail2own smallint,
	mail2sp smallint,
	senddnregmail smallint DEFAULT 1
) ;
ALTER  TABLE berch OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixberch ON berch (berchnr);


CREATE TABLE bpr_actids (
	ut char(1),
	fionaid varchar(10),
	pki bigint,
	card bigint,
	itaccount char(1)
) ;
ALTER  TABLE bpr_actids OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixbpractids ON bpr_actids (ut, fionaid, pki, card, itaccount);


CREATE TABLE bpr_drop (
	id bigint,
	text varchar(50),
	event varchar(50)
) ;
ALTER  TABLE bpr_drop OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixbprdrop ON bpr_drop (id);


CREATE TABLE bpr_exclude (
	gid char(8)
) ;
ALTER  TABLE bpr_exclude OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixbprexclude ON bpr_exclude (gid);


CREATE TABLE bpr_exclude_rule (
	rule_number bigint,
	c varchar(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32),
	department varchar(64),
	ut varchar(1),
	account varchar(1),
	id bigint
) ;
ALTER  TABLE bpr_exclude_rule OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixbprexcluderule ON bpr_exclude_rule (id);


CREATE TABLE bpr_fionaerrorcodes (
	id bigint,
	errormessage varchar(300),
	action varchar(20),
	field varchar(20),
	responsible varchar(200),
	mailid bigint,
	errormessage_en varchar(300)
) ;
ALTER  TABLE bpr_fionaerrorcodes OWNER TO scd_testuser;
CREATE INDEX ixbprfionaerrorcodes ON bpr_fionaerrorcodes (id);


CREATE TABLE bpr_fionaids (
	activitylistid varchar(10),
	activity varchar(255),
	ut varchar(1),
	activityen varchar(255)
) ;
ALTER  TABLE bpr_fionaids OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixbprfionaids ON bpr_fionaids (activitylistid);


CREATE TABLE bpr_gids (
	id bigint,
	gid char(8),
	surname_old varchar(100),
	surname_new varchar(100),
	valid_old timestamp,
	valid_new timestamp,
	leave_old timestamp,
	leave_new timestamp,
	ut_old varchar(1),
	ut_new varchar(1),
	o_old varchar(16),
	o_new varchar(16),
	l_old varchar(32),
	l_new varchar(32),
	modifydate timestamp,
	status_fiona_id bigint,
	done char(2),
	ou_old varchar(32),
	ou_new varchar(32),
	c_old varchar(2),
	c_new varchar(2)
) ;
ALTER  TABLE bpr_gids OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixbprgids ON bpr_gids (id);


CREATE TABLE bpr_gids_temp (
	id bigint,
	gid char(8),
	surname_old varchar(100),
	surname_new varchar(100),
	valid_old timestamp,
	valid_new timestamp,
	leave_old timestamp,
	leave_new timestamp,
	ut_old varchar(1),
	ut_new varchar(1),
	o_old varchar(16),
	o_new varchar(16),
	l_old varchar(32),
	l_new varchar(32),
	modifydate timestamp,
	status_fiona_id bigint,
	done char(2),
	ou_old varchar(32),
	ou_new varchar(32)
) ;
ALTER  TABLE bpr_gids_temp OWNER TO scd_testuser;


CREATE TABLE bpr_konfig (
	c varchar(2),
	o varchar(255),
	ou varchar(255),
	l varchar(255),
	department varchar(64),
	new_emp_pki bigint,
	new_emp_idcard bigint,
	term_pki bigint,
	term_idcard bigint,
	change_ut_pki bigint,
	change_ut_idcard bigint,
	ut char(1),
	change_organisation_pki bigint,
	change_organisation_idcard bigint,
	change_name_pki bigint,
	change_name_idcard bigint,
	bv bigint,
	rule_number bigint,
	renew_pki bigint,
	renew_idcard bigint,
	change_location_pki bigint,
	change_location_idcard bigint,
	access_mo_sa bigint,
	access_mo_so bigint,
	remove_it bigint,
	remove_tools bigint,
	mail_requestor bigint,
	mail_cardholder bigint,
	mail_sponsor bigint,
	account varchar(1),
	orgid varchar(8),
	ordernr varchar(50)
) ;
ALTER  TABLE bpr_konfig OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixbprkonfig ON bpr_konfig (rule_number);


CREATE TABLE bpr_mail (
	id bigint,
	subject varchar(200),
	body varchar(4000),
	recipient varchar(100)
) ;
ALTER  TABLE bpr_mail OWNER TO scd_testuser;
CREATE INDEX ixbprmail ON bpr_mail (id);


CREATE TABLE bpr_services (
	servicename varchar(50),
	startdate timestamp,
	enddate timestamp,
	isrunning varchar(1)
) ;
ALTER  TABLE bpr_services OWNER TO scd_testuser;
CREATE UNIQUE INDEX bpr_services_pk ON bpr_services (servicename);


CREATE TABLE bpr_status_fiona (
	id bigint,
	gid char(8),
	activity varchar(40),
	valid_date timestamp,
	leave_date timestamp,
	status varchar(100),
	request_date timestamp,
	error_count bigint,
	action varchar(40),
	responsible varchar(100),
	frombprgids bigint,
	rule varchar(100),
	status_date timestamp,
	sendimagemail bigint,
	missing varchar(100),
	filename varchar(40),
	fionaerrorcode bigint,
	fionaerrormesg varchar(350),
	berchnr varchar(10),
	modified_by varchar(10)
) ;
ALTER  TABLE bpr_status_fiona OWNER TO scd_testuser;
CREATE INDEX ixbprstatusfiona ON bpr_status_fiona (gid, activity, request_date);


CREATE TABLE char_replace (
	charset varchar(20),
	char_code smallint,
	char_code_replace smallint
) ;
ALTER  TABLE char_replace OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixcharreplace ON char_replace (charset, char_code);


CREATE TABLE check_err_mesg (
	checkfunction varchar(255),
	messageid varchar(10)
) ;
ALTER  TABLE check_err_mesg OWNER TO scd_testuser;


CREATE TABLE client_config (
	clientname varchar(64),
	clientid smallint,
	scd_web varchar(100),
	gcp smallint,
	fits char(1),
	hdt char(1),
	onboarding char(1),
	mvt char(1)
) ;
ALTER  TABLE client_config OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixclient_configname ON client_config (clientname);


CREATE TABLE cltrun (
	cmd varchar(255),
	id bigint
) ;
ALTER  TABLE cltrun OWNER TO scd_testuser;


CREATE TABLE cl_user (
	gid char(8),
	role_id char(10)
) ;
ALTER  TABLE cl_user OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixcl_user ON cl_user (gid);


CREATE TABLE contacts (
	gid varchar(8) NOT NULL,
	surname varchar(50),
	given_name varchar(50),
	email varchar(255)
) ;
ALTER  TABLE contacts OWNER TO scd_testuser;
ALTER TABLE contacts ADD PRIMARY KEY (gid);
ALTER TABLE contacts ALTER COLUMN GID SET NOT NULL;


CREATE TABLE contest (
	gid varchar(8) NOT NULL,
	timestamp timestamp NOT NULL,
	frage1 varchar(1) NOT NULL,
	frage2 varchar(1) NOT NULL,
	frage3 varchar(1) NOT NULL,
	frage4 varchar(1) NOT NULL,
	frage5 varchar(1) NOT NULL,
	frage6 varchar(1) NOT NULL,
	frage7 varchar(1) NOT NULL,
	frage8 varchar(1) NOT NULL,
	frage9 varchar(1) NOT NULL,
	frage10 varchar(1) NOT NULL
) ;
ALTER  TABLE contest OWNER TO scd_testuser;
ALTER TABLE contest ADD PRIMARY KEY (gid);
ALTER TABLE contest ALTER COLUMN FRAGE10 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN FRAGE9 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN FRAGE8 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN FRAGE7 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN FRAGE6 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN FRAGE5 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN FRAGE4 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN FRAGE3 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN FRAGE2 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN FRAGE1 SET NOT NULL;
ALTER TABLE contest ALTER COLUMN GID SET NOT NULL;
ALTER TABLE contest ALTER COLUMN TIMESTAMP SET NOT NULL;


CREATE TABLE dn (
	c char(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32),
	typ char(4),
	mainid varchar(120),
	sync char(1),
	liefntnr integer,
	berchnr integer,
	joins varchar(20),
	userset varchar(20),
	urlsuz varchar(128),
	denyset varchar(20),
	login char(1),
	parmset varchar(20)
) ;
ALTER  TABLE dn OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixdn ON dn (c, o, ou, l, typ);
CREATE INDEX ixdn_c ON dn (c);
CREATE INDEX ixdn_l ON dn (l);
CREATE INDEX ixdn_o ON dn (o);
CREATE INDEX ixdn_ou ON dn (ou);


CREATE TABLE dn_auto_reg_blacklist (
	c char(2),
	o varchar(16),
	l varchar(32),
	not_delivered_from_sal_from timestamp
) ;
ALTER  TABLE dn_auto_reg_blacklist OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixauto_reg_blacklist ON dn_auto_reg_blacklist (c, o, l);


CREATE TABLE dn_auto_reg_conf (
	c char(2),
	o varchar(16),
	type char(4),
	gid_supplier_gid varchar(16),
	gid_supplier_id integer,
	scd_supplier_id integer,
	unit_officer_id integer,
	join_set varchar(20),
	user_set varchar(20),
	deny_set varchar(20),
	url_suz varchar(128)
) ;
ALTER  TABLE dn_auto_reg_conf OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixauto_reg_conf ON dn_auto_reg_conf (c, o, type);


CREATE TABLE dn_backup2757 (
	c char(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32),
	typ char(4),
	mainid varchar(120),
	sync char(1),
	liefntnr integer,
	berchnr integer,
	joins varchar(20),
	userset varchar(20),
	urlsuz varchar(128),
	denyset varchar(20),
	login char(1),
	parmset varchar(20)
) ;
ALTER  TABLE dn_backup2757 OWNER TO scd_testuser;


CREATE TABLE dn_log (
	ts timestamp,
	initiator varchar(16),
	operation varchar(20),
	c char(2),
	o varchar(16),
	l varchar(32),
	type char(4),
	unit_officer_gid varchar(16),
	gid_supplier_gid varchar(16),
	scd_supplier_gid varchar(16),
	join_set varchar(20),
	notes varchar(256)
) ;
ALTER  TABLE dn_log OWNER TO scd_testuser;


CREATE TABLE dn_matching (
	c varchar(2),
	o varchar(32),
	ou varchar(32),
	ou_new varchar(32),
	l varchar(32),
	user_type varchar(1),
	gv varchar(8),
	lv_full varchar(8),
	lv_join varchar(8)
) ;
ALTER  TABLE dn_matching OWNER TO scd_testuser;
CREATE INDEX icdnmatch_o ON dn_matching (o);
CREATE INDEX ixdnmatch_c ON dn_matching (c);
CREATE INDEX ixdnmatch_l ON dn_matching (l);
CREATE INDEX ixdnmatch_ou ON dn_matching (ou);
CREATE INDEX ixdnmatch_ou_new ON dn_matching (ou_new);


CREATE TABLE fits_actionmapping (
	owner varchar(8),
	usertype varchar(1),
	relevantforevent bigint,
	sourceactiontype varchar(20),
	actiontype varchar(2),
	actionreason varchar(2),
	nameofactiontype varchar(128),
	errormessage varchar(50),
	handling varchar(20)
) ;
ALTER  TABLE fits_actionmapping OWNER TO scd_testuser;


CREATE TABLE fits_actionmapping_old (
	actiontype varchar(2),
	actionreason varchar(2),
	nameofactiontype varchar(128),
	relevantforevent varchar(20),
	nameoffitsevent varchar(32),
	relevantforeventexternal varchar(20)
) ;
ALTER  TABLE fits_actionmapping_old OWNER TO scd_testuser;


CREATE TABLE fits_blacklist (
	gid varchar(8) NOT NULL,
	creation_date timestamp DEFAULT statement_timestamp(),
	note varchar(500)
) ;
ALTER  TABLE fits_blacklist OWNER TO scd_testuser;
CREATE INDEX ix_fits_blacklist ON fits_blacklist (gid);
ALTER TABLE fits_blacklist ALTER COLUMN GID SET NOT NULL;


CREATE TABLE fits_events (
	id bigint,
	gid char(8),
	valid_date timestamp,
	leave_date timestamp,
	ut char(1),
	c char(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32),
	are varchar(32),
	event smallint,
	eventdate timestamp,
	modifydate timestamp,
	done char(2),
	modifymasterdate timestamp,
	status varchar(128),
	error varchar(512),
	event_reason varchar(256),
	trigger_update varchar(1),
	deletedate timestamp,
	orgcode varchar(60)
) ;
ALTER  TABLE fits_events OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixfits_events ON fits_events (id);


CREATE TABLE fits_events_bak (
	id bigint,
	gid char(8),
	valid_date timestamp,
	leave_date timestamp,
	ut char(1),
	c char(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32),
	are varchar(32),
	event smallint,
	eventdate timestamp,
	modifydate timestamp,
	done char(2),
	modifymasterdate timestamp,
	status varchar(128),
	error varchar(512),
	event_reason varchar(256),
	trigger_update varchar(1),
	deletedate timestamp
) ;
ALTER  TABLE fits_events_bak OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixfits_events_bak ON fits_events_bak (id);
CREATE INDEX ixfits_events_bak_gid ON fits_events_bak (gid, id desc);


CREATE TABLE fits_scope (
	scope varchar(16),
	query varchar(1000),
	active char(1),
	are_filter varchar(4000),
	department_filter varchar(500),
	event_filter varchar(50),
	scope_groups varchar(50)
) ;
ALTER  TABLE fits_scope OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixfits_scope ON fits_scope (scope);


CREATE TABLE fits_trigger (
	id bigint,
	gid char(8),
	valid_old timestamp,
	valid_new timestamp,
	leave_old timestamp,
	leave_new timestamp,
	ut_old char(1),
	ut_new char(1),
	c_old char(2),
	c_new char(2),
	o_old varchar(16),
	o_new varchar(16),
	ou_old varchar(32),
	ou_new varchar(32),
	l_old varchar(32),
	l_new varchar(32),
	are_old varchar(32),
	are_new varchar(32),
	modifydate timestamp,
	done char(2),
	surname_old varchar(100),
	surname_new varchar(100),
	owner char(8)
) ;
ALTER  TABLE fits_trigger OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixfits_trigger ON fits_trigger (id);


CREATE TABLE gb_3150_dn (
	c varchar(26),
	o varchar(26),
	ou varchar(26),
	l varchar(26),
	typ varchar(26),
	mainid varchar(26),
	sync varchar(26),
	liefntnr numeric(38),
	berchnr numeric(38),
	joins varchar(26),
	userset varchar(26),
	urlsuz varchar(128),
	denyset varchar(26),
	login varchar(26),
	parmset varchar(26)
) ;
ALTER  TABLE gb_3150_dn OWNER TO scd_testuser;


CREATE TABLE gb_coloradokorrektur (
	gid varchar(26),
	c varchar(26),
	o varchar(26),
	ou varchar(26),
	l varchar(26),
	lastnam varchar(4000),
	gn varchar(4000),
	snampre varchar(26),
	snamadd varchar(26),
	snamnat varchar(26),
	gnamnat varchar(26),
	cnamnat varchar(128),
	i varchar(26),
	gender varchar(26),
	personaltitle varchar(26),
	graduatetitle varchar(26),
	usertype varchar(26),
	recordtype varchar(26),
	contractstat varchar(26),
	mail varchar(4000),
	department varchar(4000),
	departmenttext varchar(4000),
	mainfunc varchar(4000),
	building varchar(26),
	roomnumber varchar(26),
	postofficebox varchar(26),
	telnumber varchar(4000),
	alternphone varchar(4000),
	securephone varchar(26),
	faxnumber varchar(26),
	personalfax varchar(26),
	faxnumsec varchar(26),
	mobile varchar(4000),
	vidconfnum1 varchar(26),
	vidconfnum2 varchar(26),
	pager varchar(26),
	netmeeting varchar(26),
	gidsec varchar(26),
	gidrep varchar(26),
	sponsor varchar(26),
	persremark varchar(4000),
	urlpers varchar(4000),
	costlocation varchar(26),
	costlocunit varchar(26),
	persidnum numeric(38),
	scdidm varchar(26),
	maident varchar(26),
	appkey varchar(26),
	leavedate timestamp,
	validdate timestamp,
	expiredate varchar(26),
	orgid varchar(26),
	nicknam varchar(26),
	mastat numeric(38),
	azubiend numeric(38),
	reststart numeric(38),
	restend numeric(38),
	vip varchar(26),
	itacc varchar(26),
	delegation varchar(26),
	gpcompany varchar(26),
	reqpki varchar(26),
	reqbadge varchar(26),
	reqacc varchar(26),
	reqmbox varchar(26),
	reqmail varchar(26),
	manager1 varchar(26),
	mailpriv varchar(26),
	mobilepriv varchar(26),
	actiontype numeric(38),
	actionreason numeric(38),
	actionstart timestamp,
	magruppe varchar(26),
	makreis varchar(26),
	juper numeric(38)
) ;
ALTER  TABLE gb_coloradokorrektur OWNER TO scd_testuser;


CREATE TABLE gb_colorado_1010 (
	gid varchar(26),
	c varchar(26),
	o varchar(26),
	ou varchar(26),
	l varchar(26),
	usertype varchar(26),
	recordtype varchar(26),
	contractstat varchar(26),
	leavedate timestamp,
	validdate timestamp
) ;
ALTER  TABLE gb_colorado_1010 OWNER TO scd_testuser;


CREATE TABLE gb_colorado_export (
	pernr numeric(38),
	begda timestamp,
	endda timestamp,
	gid varchar(26)
) ;
ALTER  TABLE gb_colorado_export OWNER TO scd_testuser;


CREATE TABLE gb_colorado_scdkorrektur (
	gid varchar(26),
	c varchar(26),
	o varchar(26),
	ou varchar(26),
	l varchar(26),
	lastnam varchar(26),
	gn varchar(26),
	snampre varchar(26),
	snamadd varchar(26),
	snamnat varchar(26),
	gnamnat varchar(26),
	cnamnat varchar(128),
	i varchar(26),
	gender varchar(26),
	personaltitle varchar(26),
	graduatetitle varchar(26),
	usertype varchar(26),
	recordtype varchar(26),
	contractstat varchar(26),
	mail varchar(26),
	department varchar(26),
	departmenttext varchar(26),
	mainfunc varchar(128),
	building varchar(26),
	roomnumber varchar(26),
	postofficebox varchar(26),
	telnumber varchar(26),
	alternphone varchar(26),
	securephone varchar(26),
	faxnumber varchar(26),
	personalfax varchar(26),
	faxnumsec varchar(26),
	mobile varchar(26),
	vidconfnum1 varchar(26),
	vidconfnum2 varchar(26),
	pager varchar(26),
	netmeeting varchar(26),
	gidsec varchar(26),
	gidrep varchar(26),
	sponsor varchar(26),
	persremark varchar(26),
	urlpers varchar(26),
	costlocationx varchar(26),
	costlocunit varchar(26),
	persidnum numeric(38),
	scdidm varchar(26),
	maident varchar(26),
	appkey varchar(26),
	leavedate timestamp,
	validdate timestamp,
	expiredate varchar(26),
	orgid varchar(26),
	nicknam varchar(26),
	mastat numeric(38),
	azubiend numeric(38),
	reststart numeric(38),
	restend numeric(38),
	vip varchar(26),
	itacc varchar(26),
	delegation varchar(26),
	gpcompany varchar(26),
	reqpki varchar(26),
	reqbadge varchar(26),
	reqacc varchar(26),
	reqmbox varchar(26),
	reqmail varchar(26),
	manager1 varchar(26),
	mailpriv varchar(26),
	mobilepriv varchar(26),
	actiontype numeric(38),
	actionreason numeric(38),
	actionstart timestamp,
	magruppe varchar(26),
	makreis varchar(26),
	juper numeric(38)
) ;
ALTER  TABLE gb_colorado_scdkorrektur OWNER TO scd_testuser;


CREATE TABLE gb_colo_export (
	pernr numeric(38),
	begda timestamp,
	endda timestamp,
	gid varchar(26)
) ;
ALTER  TABLE gb_colo_export OWNER TO scd_testuser;


CREATE TABLE gb_colo_gid (
	gid varchar(26),
	valid_date varchar(26),
	leave_date numeric(38),
	user_type varchar(26),
	owner varchar(26),
	join_date varchar(26),
	sponsor varchar(26),
	c varchar(26),
	o varchar(26),
	ou varchar(26),
	l varchar(26),
	appl_internal_id varchar(26),
	appl_name varchar(26),
	confirmed numeric(38),
	scd numeric(38),
	isinscd numeric(38),
	delete_date varchar(26),
	delete_uid varchar(26),
	modify_data_date varchar(26),
	modify_data_uid varchar(26),
	confirm_date varchar(26),
	sync_date varchar(26)
) ;
ALTER  TABLE gb_colo_gid OWNER TO scd_testuser;


CREATE TABLE gb_dn_0612 (
	c varchar(26),
	o varchar(26),
	ou varchar(26),
	l varchar(26),
	typ varchar(26),
	mainid varchar(26),
	sync varchar(26),
	liefntnr numeric(38),
	berchnr numeric(38),
	joins varchar(26),
	userset varchar(26),
	urlsuz varchar(128),
	denyset varchar(26),
	login varchar(26),
	parmset varchar(26)
) ;
ALTER  TABLE gb_dn_0612 OWNER TO scd_testuser;


CREATE TABLE gb_iam_2809 (
	gid varchar(26)
) ;
ALTER  TABLE gb_iam_2809 OWNER TO scd_testuser;


CREATE TABLE gb_iam_energy (
	employeenumber varchar(26),
	sn varchar(26),
	givenname varchar(26),
	expiry_date varchar(26)
) ;
ALTER  TABLE gb_iam_energy OWNER TO scd_testuser;


CREATE TABLE gb_iam_siemens (
	employeenumber varchar(26),
	sn varchar(26),
	givenname varchar(26),
	expiry_date varchar(26)
) ;
ALTER  TABLE gb_iam_siemens OWNER TO scd_testuser;


CREATE TABLE gb_iam_siemens2 (
	employeenumber varchar(26),
	sn varchar(4000),
	givenname varchar(4000),
	expiry_date varchar(26)
) ;
ALTER  TABLE gb_iam_siemens2 OWNER TO scd_testuser;


CREATE TABLE gb_maildouble (
	mail varchar(128),
	gid1 varchar(26),
	gid2 varchar(26)
) ;
ALTER  TABLE gb_maildouble OWNER TO scd_testuser;


CREATE TABLE ggw_birthdate_wl (
	gid char(8) NOT NULL
) ;
ALTER  TABLE ggw_birthdate_wl OWNER TO scd_testuser;
ALTER TABLE ggw_birthdate_wl ADD PRIMARY KEY (gid);
ALTER TABLE ggw_birthdate_wl ALTER COLUMN GID SET NOT NULL;


CREATE TABLE ggw_chart_data (
	id bigint NOT NULL,
	month timestamp NOT NULL,
	reportconfigurationid bigint NOT NULL,
	value bigint
) ;
ALTER  TABLE ggw_chart_data OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_chart_data ON ggw_chart_data (id);
ALTER TABLE ggw_chart_data ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ggw_chart_data ALTER COLUMN MONTH SET NOT NULL;
ALTER TABLE ggw_chart_data ALTER COLUMN REPORTCONFIGURATIONID SET NOT NULL;


CREATE TABLE ggw_gid_batch (
	lfdnr bigint NOT NULL,
	instanz varchar(10) NOT NULL,
	no_reply_filter varchar(10),
	rename_in_to varchar(255),
	rename_out_from varchar(255),
	rename_out_to varchar(255),
	send_err smallint,
	tcp varchar(16),
	tcp_err varchar(16),
	transadm_err varchar(50),
	transferadm varchar(50),
	txt varchar(50) NOT NULL,
	userid varchar(50) NOT NULL
) ;
ALTER  TABLE ggw_gid_batch OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_gid_batch ON ggw_gid_batch (lfdnr);
ALTER TABLE ggw_gid_batch ALTER COLUMN LFDNR SET NOT NULL;
ALTER TABLE ggw_gid_batch ALTER COLUMN INSTANZ SET NOT NULL;
ALTER TABLE ggw_gid_batch ALTER COLUMN TXT SET NOT NULL;
ALTER TABLE ggw_gid_batch ALTER COLUMN USERID SET NOT NULL;


CREATE TABLE ggw_gid_pw (
	userid varchar(8) NOT NULL,
	pw varchar(32),
	txt varchar(255)
) ;
ALTER  TABLE ggw_gid_pw OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_gid_pw ON ggw_gid_pw (userid);
ALTER TABLE ggw_gid_pw ALTER COLUMN USERID SET NOT NULL;


CREATE TABLE ggw_jobs (
	job_id bigint NOT NULL,
	error_log varchar(1000),
	import_date timestamp,
	job_name varchar(255),
	jobtype char(1),
	state char(1),
	end_date timestamp,
	custom_id varchar(255)
) ;
ALTER  TABLE ggw_jobs OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_jobs ON ggw_jobs (job_id);
ALTER TABLE ggw_jobs ALTER COLUMN JOB_ID SET NOT NULL;


CREATE TABLE ggw_login_blocked (
	requestor varchar(8),
	ip varchar(20),
	blocked_until timestamp
) ;
ALTER  TABLE ggw_login_blocked OWNER TO scd_testuser;


CREATE TABLE ggw_login_failure (
	request_date timestamp,
	ip varchar(20),
	method varchar(50),
	requestor varchar(8),
	u_id varchar(50)
) ;
ALTER  TABLE ggw_login_failure OWNER TO scd_testuser;


CREATE TABLE ggw_logs (
	id bigint NOT NULL,
	jobenddate timestamp,
	applicationinternalid varchar(255),
	applicationname varchar(255),
	birthdate varchar(255),
	birthname varchar(255),
	birthplace varchar(255),
	country varchar(255),
	dateofseparation varchar(255),
	entrydate varchar(255),
	errormessage varchar(255),
	exclude varchar(255),
	gender varchar(255),
	gid varchar(255),
	givenname varchar(255),
	location varchar(255),
	nameprefix varchar(255),
	namesuffix varchar(255),
	newentrydate varchar(255),
	organization varchar(255),
	organizationunit varchar(255),
	requestor varchar(255),
	scd varchar(255),
	sponsor varchar(255),
	surname varchar(255),
	u_id varchar(255),
	usertype varchar(255),
	state varchar(255),
	jobtype varchar(255),
	jobstartdate timestamp,
	linenumber bigint
) ;
ALTER  TABLE ggw_logs OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_logs ON ggw_logs (id);
ALTER TABLE ggw_logs ALTER COLUMN ID SET NOT NULL;


CREATE TABLE ggw_method_count (
	id bigint NOT NULL,
	counter bigint NOT NULL,
	event_date timestamp NOT NULL,
	method varchar(255) NOT NULL,
	requestor varchar(8),
	u_id varchar(255) NOT NULL
) ;
ALTER  TABLE ggw_method_count OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_method_count ON ggw_method_count (id);
ALTER TABLE ggw_method_count ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ggw_method_count ALTER COLUMN COUNTER SET NOT NULL;
ALTER TABLE ggw_method_count ALTER COLUMN EVENT_DATE SET NOT NULL;
ALTER TABLE ggw_method_count ALTER COLUMN METHOD SET NOT NULL;
ALTER TABLE ggw_method_count ALTER COLUMN U_ID SET NOT NULL;


CREATE TABLE ggw_photoportal_blocked (
	gid varchar(8),
	ip varchar(20),
	blocked_until timestamp
) ;
ALTER  TABLE ggw_photoportal_blocked OWNER TO scd_testuser;


CREATE TABLE ggw_photoportal_failed (
	event_date timestamp,
	ip varchar(20),
	gid varchar(8),
	birthdate varchar(12)
) ;
ALTER  TABLE ggw_photoportal_failed OWNER TO scd_testuser;


CREATE TABLE ggw_properties (
	id bigint NOT NULL,
	key_column varchar(50) NOT NULL,
	value varchar(255)
) ;
ALTER  TABLE ggw_properties OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_properties ON ggw_properties (id);
CREATE UNIQUE INDEX ixggw_propertieskey ON ggw_properties (key_column);
ALTER TABLE ggw_properties ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ggw_properties ALTER COLUMN KEY_COLUMN SET NOT NULL;


CREATE TABLE ggw_report_config (
	id bigint NOT NULL,
	show_in_interval smallint,
	report_sql varchar(255) NOT NULL,
	title_de varchar(255) NOT NULL,
	title_en varchar(255) NOT NULL,
	calculation_time bigint,
	error_message varchar(255),
	last_chart_data_update timestamp,
	calculation_state bigint
) ;
ALTER  TABLE ggw_report_config OWNER TO scd_testuser;
ALTER TABLE ggw_report_config ADD PRIMARY KEY (id);
ALTER TABLE ggw_report_config ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ggw_report_config ALTER COLUMN REPORT_SQL SET NOT NULL;
ALTER TABLE ggw_report_config ALTER COLUMN TITLE_DE SET NOT NULL;
ALTER TABLE ggw_report_config ALTER COLUMN TITLE_EN SET NOT NULL;


CREATE TABLE ggw_rfc_servers (
	id bigint NOT NULL,
	state bigint NOT NULL,
	description varchar(255) NOT NULL,
	host varchar(255) NOT NULL,
	language varchar(5) NOT NULL,
	mandant varchar(3) NOT NULL,
	max_connections bigint NOT NULL,
	password varchar(255) NOT NULL,
	sap_gateway varchar(255) NOT NULL,
	secure smallint NOT NULL,
	server_name varchar(255) NOT NULL,
	snc_lib varchar(255) NOT NULL,
	snc_myname varchar(255) NOT NULL,
	snc_partnername varchar(255) NOT NULL,
	snc_qop bigint NOT NULL,
	system_nr varchar(2) NOT NULL,
	user_id varchar(255) NOT NULL,
	unicode smallint NOT NULL,
	trace smallint NOT NULL
) ;
ALTER  TABLE ggw_rfc_servers OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_rfc_servers ON ggw_rfc_servers (id);
ALTER TABLE ggw_rfc_servers ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN STATE SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN DESCRIPTION SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN HOST SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN LANGUAGE SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN MANDANT SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN MAX_CONNECTIONS SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN PASSWORD SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN SAP_GATEWAY SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN SECURE SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN SERVER_NAME SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN SNC_LIB SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN SNC_MYNAME SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN SNC_PARTNERNAME SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN SNC_QOP SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN SYSTEM_NR SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN UNICODE SET NOT NULL;
ALTER TABLE ggw_rfc_servers ALTER COLUMN TRACE SET NOT NULL;


CREATE TABLE ggw_role (
	id bigint NOT NULL,
	name varchar(20),
	description varchar(64)
) ;
ALTER  TABLE ggw_role OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_role ON ggw_role (id);
ALTER TABLE ggw_role ALTER COLUMN ID SET NOT NULL;


CREATE TABLE ggw_user (
	id bigint NOT NULL,
	version bigint NOT NULL,
	username varchar(50) NOT NULL,
	password varchar(255) NOT NULL,
	password_hint varchar(255),
	first_name varchar(50) NOT NULL,
	last_name varchar(50) NOT NULL,
	email varchar(255) NOT NULL,
	phone_number varchar(255),
	website varchar(255),
	address varchar(150),
	city varchar(50) NOT NULL,
	province varchar(100),
	country varchar(100),
	postal_code varchar(15) NOT NULL,
	account_enabled smallint,
	account_expired smallint NOT NULL,
	account_locked smallint NOT NULL,
	credentials_expired smallint NOT NULL
) ;
ALTER  TABLE ggw_user OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_user ON ggw_user (id);
CREATE UNIQUE INDEX ixggw_useremail ON ggw_user (email);
CREATE UNIQUE INDEX ixggw_userusername ON ggw_user (username);
ALTER TABLE ggw_user ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN VERSION SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN USERNAME SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN PASSWORD SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN FIRST_NAME SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN LAST_NAME SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN EMAIL SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN CITY SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN POSTAL_CODE SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN ACCOUNT_EXPIRED SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN ACCOUNT_LOCKED SET NOT NULL;
ALTER TABLE ggw_user ALTER COLUMN CREDENTIALS_EXPIRED SET NOT NULL;


CREATE TABLE ggw_userid_conf (
	userid varchar(128) NOT NULL,
	maskbirthdate smallint NOT NULL
) ;
ALTER  TABLE ggw_userid_conf OWNER TO scd_testuser;
ALTER TABLE ggw_userid_conf ADD PRIMARY KEY (userid);
ALTER TABLE ggw_userid_conf ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE ggw_userid_conf ALTER COLUMN MASKBIRTHDATE SET NOT NULL;


CREATE TABLE ggw_user_role (
	id bigint NOT NULL,
	user_name varchar(20) NOT NULL,
	role_name varchar(20) NOT NULL
) ;
ALTER  TABLE ggw_user_role OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixggw_user_role ON ggw_user_role (id);
ALTER TABLE ggw_user_role ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ggw_user_role ALTER COLUMN USER_NAME SET NOT NULL;
ALTER TABLE ggw_user_role ALTER COLUMN ROLE_NAME SET NOT NULL;


CREATE TABLE gidakt (
	gid char(8)
) ;
ALTER  TABLE gidakt OWNER TO scd_testuser;


CREATE TABLE gidband (
	snrfirst char(32),
	snrlast char(32),
	isource integer,
	createdate timestamp,
	moddate timestamp
) ;
ALTER  TABLE gidband OWNER TO scd_testuser;
CREATE UNIQUE INDEX snrfirst_idx ON gidband (snrfirst, snrlast);


CREATE TABLE gidzchn (
	istelle integer,
	szeichen varchar(255),
	ilen integer
) ;
ALTER  TABLE gidzchn OWNER TO scd_testuser;
CREATE UNIQUE INDEX istelle_idx ON gidzchn (istelle);


CREATE TABLE gid_batch_error (
	error_message varchar(256),
	error_type varchar(64),
	field_name varchar(64),
	illegal_character varchar(1),
	record_validation_id integer,
	id bigint GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1 MAXVALUE 9223372036854775807 MINVALUE 1 NO CYCLE CACHE 20 ),
	illegal_length smallint
) ;
ALTER  TABLE gid_batch_error OWNER TO scd_testuser;
ALTER TABLE gid_batch_error ADD PRIMARY KEY (id);
ALTER TABLE gid_batch_error ALTER COLUMN ID SET NOT NULL;


CREATE TABLE gid_batch_record_validation (
	record varchar(1024),
	validation_id integer,
	id bigint GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1 MAXVALUE 9223372036854775807 MINVALUE 1 NO CYCLE CACHE 20 )
) ;
ALTER  TABLE gid_batch_record_validation OWNER TO scd_testuser;
ALTER TABLE gid_batch_record_validation ADD PRIMARY KEY (id);
ALTER TABLE gid_batch_record_validation ALTER COLUMN ID SET NOT NULL;


CREATE TABLE gid_batch_validation (
	id bigint GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1 MAXVALUE 9223372036854775807 MINVALUE 1 NO CYCLE CACHE 20 ),
	validation_token varchar(36),
	liefntnr integer
) ;
ALTER  TABLE gid_batch_validation OWNER TO scd_testuser;
ALTER TABLE gid_batch_validation ADD PRIMARY KEY (id);
ALTER TABLE gid_batch_validation ALTER COLUMN ID SET NOT NULL;


CREATE TABLE gid_bl_dn (
	c char(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32)
) ;
ALTER  TABLE gid_bl_dn OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixgid_bl_dn ON gid_bl_dn (c, o, ou, l);


CREATE TABLE gid_bl_geb (
	birth_place varchar(40)
) ;
ALTER  TABLE gid_bl_geb OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixgid_bl_geb ON gid_bl_geb (birth_place);


CREATE TABLE gid_clearing (
	gid char(8),
	leavedate timestamp,
	sponsorgid char(8),
	detectiondate timestamp,
	ownergid char(8),
	createdtimestamp timestamp,
	modifiedtimestamp timestamp,
	escalationlevel smallint,
	mailid smallint,
	mailsentdate timestamp,
	status varchar(1024),
	invaliduser smallint DEFAULT 0,
	invalidowner smallint DEFAULT 0,
	supportnotified smallint DEFAULT 0,
	invaliduseremail smallint DEFAULT 0,
	reason varchar(20)
) ;
ALTER  TABLE gid_clearing OWNER TO scd_testuser;
CREATE INDEX ix_gid_clearing ON gid_clearing (gid);


CREATE TABLE gid_clearing_mail (
	id smallint NOT NULL,
	subject varchar(255),
	body varchar(4000)
) ;
ALTER  TABLE gid_clearing_mail OWNER TO scd_testuser;
ALTER TABLE gid_clearing_mail ALTER COLUMN ID SET NOT NULL;


CREATE TABLE gid_clientid_mig_override (
	gid char(8) NOT NULL,
	clientid smallint
) ;
ALTER  TABLE gid_clientid_mig_override OWNER TO scd_testuser;
ALTER TABLE gid_clientid_mig_override ADD PRIMARY KEY (gid);
ALTER TABLE gid_clientid_mig_override ALTER COLUMN GID SET NOT NULL;


CREATE TABLE gid_data (
	gid char(8),
	valid_date timestamp,
	leave_date timestamp,
	user_type char(1),
	owner char(8),
	join_date timestamp,
	sponsor char(8),
	c char(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32),
	appl_internal_id varchar(32),
	appl_name varchar(20),
	confirmed char(1),
	scd char(1),
	isinscd smallint,
	delete_date timestamp,
	delete_uid char(8),
	modify_data_date timestamp,
	modify_data_uid char(8),
	confirm_date timestamp,
	sync_date timestamp,
	id bigint GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1 MAXVALUE 9223372036854775807 MINVALUE 1 CYCLE CACHE 10 )
) ;
ALTER  TABLE gid_data OWNER TO scd_testuser;
CREATE INDEX ix_gid_data ON gid_data (gid);
CREATE INDEX ix_gid_data_deletedate ON gid_data (delete_date);
CREATE INDEX ix_gid_data_leavedate ON gid_data (leave_date);
CREATE INDEX ix_gid_data_validdate ON gid_data (valid_date);
CREATE INDEX ix_gid_dn ON gid_data (c, o, ou, l);
ALTER TABLE gid_data ALTER COLUMN ID SET NOT NULL;


CREATE TABLE gid_data_log (
	operation varchar(20),
	ts timestamp,
	gid_old char(8),
	gid_new char(8),
	valid_date_old char(19),
	valid_date_new char(19),
	leave_date_old char(19),
	leave_date_new char(19),
	user_type_old char(1),
	user_type_new char(1),
	owner_old char(8),
	owner_new char(8),
	join_date_old char(19),
	join_date_new char(19),
	sponsor_old char(8),
	sponsor_new char(8),
	c_old char(2),
	c_new char(2),
	o_old varchar(16),
	o_new varchar(16),
	ou_old varchar(32),
	ou_new varchar(32),
	l_old varchar(32),
	l_new varchar(32),
	appl_internal_id_old varchar(32),
	appl_internal_id_new varchar(32),
	appl_name_old varchar(20),
	appl_name_new varchar(20),
	confirmed_old char(1),
	confirmed_new char(1),
	scd_old char(1),
	scd_new char(1),
	delete_date_old char(19),
	delete_date_new char(19),
	delete_uid_old char(8),
	delete_uid_new char(8),
	modify_data_date_old char(19),
	modify_data_date_new char(19),
	modify_data_uid_old char(8),
	modify_data_uid_new char(8),
	confirm_date_old char(19),
	confirm_date_new char(19),
	changed_by varchar(128),
	notes varchar(256)
) ;
ALTER  TABLE gid_data_log OWNER TO scd_testuser;


CREATE TABLE gid_invalid_owners (
	gid varchar(8) NOT NULL,
	first_detection_date timestamp NOT NULL,
	latest_detection_date timestamp NOT NULL
) ;
ALTER  TABLE gid_invalid_owners OWNER TO scd_testuser;
CREATE UNIQUE INDEX gid_invalid_owners_index1 ON gid_invalid_owners (gid);
ALTER TABLE gid_invalid_owners ALTER COLUMN LATEST_DETECTION_DATE SET NOT NULL;
ALTER TABLE gid_invalid_owners ALTER COLUMN FIRST_DETECTION_DATE SET NOT NULL;
ALTER TABLE gid_invalid_owners ALTER COLUMN GID SET NOT NULL;


CREATE TABLE gid_log (
	operation varchar(10),
	ts timestamp,
	gid char(8),
	row_id varchar(20),
	attribute varchar(20),
	old_val varchar(40),
	new_val varchar(40),
	changed_by varchar(40),
	origin_table varchar(10),
	notes varchar(256)
) ;
ALTER  TABLE gid_log OWNER TO scd_testuser;
CREATE INDEX ix_gid_log_gid ON gid_log (gid);
CREATE INDEX ix_gid_log_ts ON gid_log (ts);


CREATE TABLE gid_mapping (
	gid varchar(8),
	c varchar(2),
	o varchar(32),
	ou varchar(32),
	ou_new varchar(32),
	l varchar(32),
	user_type varchar(1),
	gv varchar(8),
	lv_full varchar(8),
	lv_join varchar(8)
) ;
ALTER  TABLE gid_mapping OWNER TO scd_testuser;
CREATE INDEX ix_gid_mapping ON gid_mapping (gid);
CREATE INDEX ix_gid_mapping_c ON gid_mapping (c);
CREATE INDEX ix_gid_mapping_l ON gid_mapping (l);
CREATE INDEX ix_gid_mapping_o ON gid_mapping (o);
CREATE INDEX ix_gid_mapping_ou ON gid_mapping (ou);
CREATE INDEX ix_gid_mapping_ou_new ON gid_mapping (ou_new);


CREATE TABLE gid_mapping_old (
	gid varchar(8),
	c varchar(2),
	o varchar(32),
	ou varchar(32),
	ou_new varchar(32),
	l varchar(32),
	user_type varchar(1),
	gv varchar(8),
	lv_full varchar(8),
	lv_join varchar(8)
) ;
ALTER  TABLE gid_mapping_old OWNER TO scd_testuser;


CREATE TABLE gid_pw (
	userid varchar(8),
	txt varchar(255),
	pw varchar(32),
	chk varchar(255),
	typ varchar(255),
	internal smallint NOT NULL DEFAULT 0
) ;
ALTER  TABLE gid_pw OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixuserid ON gid_pw (userid);
ALTER TABLE gid_pw ALTER COLUMN INTERNAL SET NOT NULL;


CREATE TABLE gid_requestors (
	userid varchar(8) NOT NULL,
	requestor varchar(8) NOT NULL
) ;
ALTER  TABLE gid_requestors OWNER TO scd_testuser;
ALTER TABLE gid_requestors ADD PRIMARY KEY (userid,requestor);
ALTER TABLE gid_requestors ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE gid_requestors ALTER COLUMN REQUESTOR SET NOT NULL;


CREATE TABLE gid_unknown_dns (
	gid varchar(8) NOT NULL,
	detection_date timestamp NOT NULL,
	type bigint NOT NULL DEFAULT 0
) ;
ALTER  TABLE gid_unknown_dns OWNER TO scd_testuser;
ALTER TABLE gid_unknown_dns ALTER COLUMN DETECTION_DATE SET NOT NULL;
ALTER TABLE gid_unknown_dns ALTER COLUMN GID SET NOT NULL;
ALTER TABLE gid_unknown_dns ALTER COLUMN TYPE SET NOT NULL;


CREATE TABLE gid_user (
	gid char(8),
	creator char(8),
	creation_date timestamp,
	surname varchar(40),
	given_name varchar(40),
	name_prefix varchar(16),
	name_suffix varchar(16),
	birth_date timestamp,
	birth_place varchar(40),
	birth_name varchar(40),
	gender char(1),
	modify_user_date timestamp,
	modify_user_uid char(8),
	orig_gid char(8),
	clientid smallint
) ;
ALTER  TABLE gid_user OWNER TO scd_testuser;
CREATE INDEX ix_gid_given_name ON gid_user (given_name);
CREATE INDEX ix_gid_surname ON gid_user (surname);
CREATE UNIQUE INDEX ix_gid_user ON gid_user (gid);


CREATE TABLE gid_user_log (
	operation varchar(20),
	ts timestamp,
	gid_old char(8),
	gid_new char(8),
	surname_old varchar(40),
	surname_new varchar(40),
	given_name_old varchar(40),
	given_name_new varchar(40),
	name_prefix_old varchar(16),
	name_prefix_new varchar(16),
	name_suffix_old varchar(16),
	name_suffix_new varchar(16),
	birth_date_old timestamp,
	birth_date_new timestamp,
	birth_place_old varchar(40),
	birth_place_new varchar(40),
	birth_name_old varchar(40),
	birth_name_new varchar(40),
	gender_old char(1),
	gender_new char(1),
	modify_user_date_old char(19),
	modify_user_date_new char(19),
	modify_user_uid_old char(8),
	modify_user_uid_new char(8),
	orig_gid_old char(8),
	orig_gid_new char(8),
	changed_by varchar(128),
	clientid_new smallint,
	clientid_old smallint,
	notes varchar(256)
) ;
ALTER  TABLE gid_user_log OWNER TO scd_testuser;


CREATE TABLE hd_user (
	gid varchar(8) NOT NULL,
	role_id varchar(10) NOT NULL,
	approval_date timestamp,
	approver varchar(8),
	comments varchar(150)
) ;
ALTER  TABLE hd_user OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixhd_user ON hd_user (gid);
ALTER TABLE hd_user ALTER COLUMN GID SET NOT NULL;
ALTER TABLE hd_user ALTER COLUMN ROLE_ID SET NOT NULL;


CREATE TABLE invalid_data_suppliers (
	gid varchar(8) NOT NULL,
	first_detection_date timestamp NOT NULL,
	latest_detection_date timestamp NOT NULL
) ;
ALTER  TABLE invalid_data_suppliers OWNER TO scd_testuser;
ALTER TABLE invalid_data_suppliers ALTER COLUMN GID SET NOT NULL;
ALTER TABLE invalid_data_suppliers ALTER COLUMN FIRST_DETECTION_DATE SET NOT NULL;
ALTER TABLE invalid_data_suppliers ALTER COLUMN LATEST_DETECTION_DATE SET NOT NULL;


CREATE TABLE "join" (
	bez varchar(20),
	lfd smallint,
	txt varchar(120),
	liefntnr integer,
	joinset varchar(20)
) ;
ALTER  TABLE "join" OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixjoin ON "join" (bez, lfd);


CREATE TABLE konfig (
	konfignr char(10),
	sprache char(2),
	txt varchar(120),
	wert varchar(255)
) ;
ALTER  TABLE konfig OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixkonfig ON konfig (konfignr, sprache);


CREATE TABLE liefnt (
	liefntnr integer,
	liefntmin integer,
	liefntmax integer,
	senderid varchar(120),
	stellvid varchar(120),
	nick varchar(120),
	mailsds varchar(120),
	mailsuz varchar(120),
	notify char(4),
	sprache char(2),
	zchnsatz varchar(20),
	lieferart varchar(32),
	lieferset varchar(20),
	lieferkey varchar(20),
	mainid varchar(120),
	delta smallint,
	bdsg timestamp,
	aptool smallint,
	dgetid char(8),
	isv3 timestamp,
	txv3 varchar(255),
	ftread char(8),
	pagids smallint,
	updcurr smallint
) ;
ALTER  TABLE liefnt OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixliefnt ON liefnt (liefntnr);
CREATE INDEX ixliefntmainid ON liefnt (mainid);


CREATE TABLE liefnt_contacts (
	mainid varchar(8) NOT NULL,
	gid varchar(8) NOT NULL,
	info varchar(255)
) ;
ALTER  TABLE liefnt_contacts OWNER TO scd_testuser;
ALTER TABLE liefnt_contacts ADD PRIMARY KEY (mainid,gid);
ALTER TABLE liefnt_contacts ALTER COLUMN MAINID SET NOT NULL;
ALTER TABLE liefnt_contacts ALTER COLUMN GID SET NOT NULL;


CREATE TABLE liefnt_details (
	liefntnr integer NOT NULL,
	phone varchar(32),
	url varchar(512),
	desc_html_de varchar(4000),
	desc_html_en varchar(4000),
	desc_html_pt varchar(4000),
	desc_html_es varchar(4000),
	desc_html_fr varchar(4000)
) ;
ALTER  TABLE liefnt_details OWNER TO scd_testuser;
ALTER TABLE liefnt_details ADD PRIMARY KEY (liefntnr);


CREATE TABLE liefnt_gid (
	mainid char(8) NOT NULL,
	typ char(8) NOT NULL,
	description varchar(120),
	userid varchar(120),
	password varchar(20),
	tech_contact varchar(120),
	tech_contact_mail varchar(120),
	ta_in varchar(30),
	ip_out varchar(16),
	ta_out varchar(30),
	contractnr varchar(16),
	servername varchar(80),
	host varchar(80),
	lang char(2),
	sap_client varchar(10),
	max_connections char(3),
	sap_gateway varchar(16),
	systemnr varchar(16),
	secure varchar(20),
	snc_qop varchar(16),
	snc_partnername varchar(120),
	snc_myname varchar(120),
	snc_lib varchar(120),
	unicode varchar(16),
	trace char(1),
	ip_out_err varchar(16),
	ta_out_err varchar(30)
) ;
ALTER  TABLE liefnt_gid OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixliefnt_gid ON liefnt_gid (mainid, typ);
ALTER TABLE liefnt_gid ALTER COLUMN MAINID SET NOT NULL;
ALTER TABLE liefnt_gid ALTER COLUMN TYP SET NOT NULL;


CREATE TABLE liefnt_srq (
	mainid char(8),
	c char(2),
	o varchar(16),
	l varchar(32),
	ut varchar(4),
	clientid varchar(16),
	srq_id char(8),
	takeover char(1),
	leave_max smallint
) ;
ALTER  TABLE liefnt_srq OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixliefnt_srq ON liefnt_srq (mainid, c, o, l);


CREATE TABLE mail_log (
	uuid varchar(36),
	sent_date timestamp,
	intended_recipients varchar(1024),
	sent_to varchar(1024),
	mail_template_id smallint,
	email_type varchar(50),
	subject varchar(512),
	app_name varchar(32),
	status varchar(512)
) ;
ALTER  TABLE mail_log OWNER TO scd_testuser;


CREATE TABLE mandant_department_mapping (
	consumer_client_id smallint,
	owner_client_id smallint,
	department varchar(255)
) ;
ALTER  TABLE mandant_department_mapping OWNER TO scd_testuser;


CREATE TABLE mandant_dn_mapping (
	mandant varchar(20),
	c varchar(2),
	o varchar(16)
) ;
ALTER  TABLE mandant_dn_mapping OWNER TO scd_testuser;


CREATE TABLE mesg (
	mesgnr char(10),
	sprache char(2),
	typ char(1),
	txt varchar(255)
) ;
ALTER  TABLE mesg OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixmesg ON mesg (mesgnr, sprache);


CREATE TABLE msteams_domain_whitelist (
	client_id smallint,
	domain varchar(255)
) ;
ALTER  TABLE msteams_domain_whitelist OWNER TO scd_testuser;


CREATE TABLE national_holiday (
	id bigint NOT NULL,
	iso_country_code varchar(2) NOT NULL,
	scd_country_code varchar(2) NOT NULL,
	holiday_data text
) ;
ALTER  TABLE national_holiday OWNER TO scd_testuser;
CREATE UNIQUE INDEX national_holiday_index_c ON national_holiday (iso_country_code);
ALTER TABLE national_holiday ADD PRIMARY KEY (id);
ALTER TABLE national_holiday ALTER COLUMN SCD_COUNTRY_CODE SET NOT NULL;
ALTER TABLE national_holiday ALTER COLUMN ISO_COUNTRY_CODE SET NOT NULL;
ALTER TABLE national_holiday ALTER COLUMN ID SET NOT NULL;


CREATE TABLE prot (
	liefnr integer,
	senderid varchar(120),
	liefntnr integer,
	lieferart char(8),
	status char(10),
	grund char(10),
	liefanz integer,
	liefende timestamp,
	prfanz integer,
	prfende timestamp,
	makanz integer,
	makende timestamp,
	pid integer,
	makstart timestamp
) ;
ALTER  TABLE prot OWNER TO scd_testuser;
CREATE INDEX ixprotdat ON prot (liefende);
CREATE UNIQUE INDEX ixprotnr ON prot (liefnr);


CREATE TABLE prot_pid (
	liefnr integer NOT NULL,
	started timestamp NOT NULL
) ;
ALTER  TABLE prot_pid OWNER TO scd_testuser;
ALTER TABLE prot_pid ADD PRIMARY KEY (liefnr);
ALTER TABLE prot_pid ALTER COLUMN LIEFNR SET NOT NULL;
ALTER TABLE prot_pid ALTER COLUMN STARTED SET NOT NULL;


CREATE TABLE request_err (
	id integer NOT NULL,
	attr varchar(20) NOT NULL,
	idx smallint NOT NULL,
	mesgnr char(10),
	mesgtyp char(1) NOT NULL,
	mesgtxt varchar(255) NOT NULL
) ;
ALTER  TABLE request_err OWNER TO scd_testuser;
ALTER TABLE request_err ADD PRIMARY KEY (id,idx);
ALTER TABLE request_err ALTER COLUMN ID SET NOT NULL;
ALTER TABLE request_err ALTER COLUMN ATTR SET NOT NULL;
ALTER TABLE request_err ALTER COLUMN IDX SET NOT NULL;
ALTER TABLE request_err ALTER COLUMN MESGTYP SET NOT NULL;
ALTER TABLE request_err ALTER COLUMN MESGTXT SET NOT NULL;


CREATE TABLE request_in (
	id integer NOT NULL,
	attr varchar(20) NOT NULL,
	val varchar(1024)
) ;
ALTER  TABLE request_in OWNER TO scd_testuser;
ALTER TABLE request_in ADD PRIMARY KEY (attr,id);
ALTER TABLE request_in ALTER COLUMN ID SET NOT NULL;
ALTER TABLE request_in ALTER COLUMN ATTR SET NOT NULL;


CREATE TABLE request_log (
	id integer NOT NULL,
	ts timestamp NOT NULL,
	duration integer,
	type varchar(40) NOT NULL,
	userid varchar(8) NOT NULL,
	status smallint NOT NULL
) ;
ALTER  TABLE request_log OWNER TO scd_testuser;
ALTER TABLE request_log ADD PRIMARY KEY (id);
ALTER TABLE request_log ALTER COLUMN ID SET NOT NULL;
ALTER TABLE request_log ALTER COLUMN TS SET NOT NULL;
ALTER TABLE request_log ALTER COLUMN TYPE SET NOT NULL;
ALTER TABLE request_log ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE request_log ALTER COLUMN STATUS SET NOT NULL;


CREATE TABLE request_out (
	id integer NOT NULL,
	idx smallint NOT NULL,
	attr varchar(20) NOT NULL,
	val varchar(1024)
) ;
ALTER  TABLE request_out OWNER TO scd_testuser;
ALTER TABLE request_out ADD PRIMARY KEY (attr,idx,id);
ALTER TABLE request_out ALTER COLUMN ID SET NOT NULL;
ALTER TABLE request_out ALTER COLUMN IDX SET NOT NULL;
ALTER TABLE request_out ALTER COLUMN ATTR SET NOT NULL;


CREATE TABLE rtc_domain_replacement (
	branding_domain varchar(100) NOT NULL,
	rtc_domain varchar(100) NOT NULL
) ;
ALTER  TABLE rtc_domain_replacement OWNER TO scd_testuser;
ALTER TABLE rtc_domain_replacement ALTER COLUMN RTC_DOMAIN SET NOT NULL;
ALTER TABLE rtc_domain_replacement ALTER COLUMN BRANDING_DOMAIN SET NOT NULL;


CREATE TABLE sgid_err (
	f_nummer integer NOT NULL,
	f_datum timestamp NOT NULL,
	liefntnr integer NOT NULL,
	lfd_nr integer NOT NULL,
	f_text varchar(1024)
) ;
ALTER  TABLE sgid_err OWNER TO scd_testuser;
CREATE INDEX ixsgid_err_f_datum ON sgid_err (f_datum);
CREATE INDEX ixsgid_err_liefnt ON sgid_err (liefntnr);
CREATE INDEX ixsgid_err_txt ON sgid_err (f_text);
ALTER TABLE sgid_err ALTER COLUMN F_NUMMER SET NOT NULL;
ALTER TABLE sgid_err ALTER COLUMN F_DATUM SET NOT NULL;
ALTER TABLE sgid_err ALTER COLUMN LIEFNTNR SET NOT NULL;
ALTER TABLE sgid_err ALTER COLUMN LFD_NR SET NOT NULL;


CREATE TABLE sgid_new_err (
	id bigint GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1 MAXVALUE 9223372036854775807 MINVALUE 1 NO CYCLE CACHE 20 ),
	err_number integer,
	err_date timestamp,
	liefntnr integer,
	err_text varchar(1024),
	email_due_date timestamp,
	email_sent_date timestamp,
	email_sent smallint DEFAULT 0
) ;
ALTER  TABLE sgid_new_err OWNER TO scd_testuser;
ALTER TABLE sgid_new_err ALTER COLUMN ID SET NOT NULL;


CREATE TABLE stmdat (
	c char(2),
	cnameeng varchar(64),
	cnamenat varchar(64),
	o varchar(16),
	onameint varchar(128),
	onamenat varchar(128),
	ou varchar(32),
	ounameshort varchar(32),
	ounameint varchar(128),
	ounamenat varchar(128),
	l varchar(32),
	lnameshort varchar(32),
	lnameint varchar(32),
	lnamenat varchar(32),
	street varchar(64),
	streetadrnat varchar(64),
	postalcode varchar(16),
	postadrint1 varchar(64),
	postadrint2 varchar(64),
	postadrnat1 varchar(64),
	postadrnat2 varchar(64),
	phonenumex varchar(32),
	faxnumex varchar(32),
	regofficeplant varchar(64),
	urlo varchar(128),
	urlou varchar(128),
	urll varchar(128),
	salid char(16),
	utc varchar(64),
	company varchar(32),
	cgroup varchar(32),
	liefnr integer,
	konzbet varchar(64),
	konzstat char(1),
	lnameeng varchar(32),
	gps varchar(40),
	isvirtual char(1),
	stprovince varchar(120),
	clientname varchar(64),
	clientid smallint
) ;
ALTER  TABLE stmdat OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixstmdat ON stmdat (c, o, ou, l, liefnr);
CREATE INDEX ixstmdat_c ON stmdat (c);
CREATE INDEX ixstmdat_l ON stmdat (l);
CREATE INDEX ixstmdat_o ON stmdat (o);
CREATE INDEX ixstmdat_ou ON stmdat (ou);


CREATE TABLE stmtzone (
	l varchar(32),
	tzid varchar(64)
) ;
ALTER  TABLE stmtzone OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixstmtzoneloc ON stmtzone (l);


CREATE TABLE tcgids (
	tcgid char(8) NOT NULL,
	cn varchar(64)
) ;
ALTER  TABLE tcgids OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixtcgids ON tcgids (tcgid);
ALTER TABLE tcgids ALTER COLUMN TCGID SET NOT NULL;


CREATE TABLE to_delete_konfig_log (
	logid bigint NOT NULL,
	gid varchar(10) NOT NULL,
	konfignr varchar(10) NOT NULL,
	timestamp timestamp NOT NULL,
	txtnew varchar(120),
	txtold varchar(120),
	wertnew varchar(255),
	wertold varchar(255),
	actiontype varchar(10) NOT NULL
) ;
ALTER  TABLE to_delete_konfig_log OWNER TO scd_testuser;
ALTER TABLE to_delete_konfig_log ADD PRIMARY KEY (logid);
ALTER TABLE to_delete_konfig_log ALTER COLUMN ACTIONTYPE SET NOT NULL;
ALTER TABLE to_delete_konfig_log ALTER COLUMN TIMESTAMP SET NOT NULL;
ALTER TABLE to_delete_konfig_log ALTER COLUMN KONFIGNR SET NOT NULL;
ALTER TABLE to_delete_konfig_log ALTER COLUMN GID SET NOT NULL;
ALTER TABLE to_delete_konfig_log ALTER COLUMN LOGID SET NOT NULL;


CREATE TABLE to_delete_konfig_user (
	gid varchar(10) NOT NULL
) ;
ALTER  TABLE to_delete_konfig_user OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixkonfiguser ON to_delete_konfig_user (gid);
ALTER TABLE to_delete_konfig_user ALTER COLUMN GID SET NOT NULL;


CREATE TABLE validorgcodeschcm (
	department varchar(64),
	startdate varchar(16),
	enddate varchar(16)
) ;
ALTER  TABLE validorgcodeschcm OWNER TO scd_testuser;


CREATE TABLE validorgcodesmanual (
	department varchar(64),
	startdate varchar(16),
	enddate varchar(16)
) ;
ALTER  TABLE validorgcodesmanual OWNER TO scd_testuser;


CREATE TABLE webs_log (
	ts timestamp,
	request_id varchar(20) NOT NULL,
	requestor varchar(20),
	endpoint varchar(6),
	request_type varchar(10),
	parameter varchar(20),
	val varchar(50),
	response varchar(256)
) ;
ALTER  TABLE webs_log OWNER TO scd_testuser;
CREATE INDEX ix_webs_log_ts ON webs_log (ts);
ALTER TABLE webs_log ADD PRIMARY KEY (request_id);
ALTER TABLE webs_log ALTER COLUMN REQUEST_ID SET NOT NULL;


CREATE TABLE webui_all_attributes (
	attr_txt varchar(120),
	attr_ui varchar(20)
) ;
COMMENT ON COLUMN webui_all_attributes.attr_ui IS E'attribute name WEBUI';
ALTER  TABLE webui_all_attributes OWNER TO scd_testuser;


CREATE TABLE webui_bookmarked_employees (
	id numeric(38) NOT NULL,
	userid varchar(8) NOT NULL,
	bookmarked_gid varchar(8) NOT NULL,
	timestamp timestamp NOT NULL
) ;
ALTER  TABLE webui_bookmarked_employees OWNER TO scd_testuser;
ALTER TABLE webui_bookmarked_employees ADD PRIMARY KEY (id);
ALTER TABLE webui_bookmarked_employees ALTER COLUMN ID SET NOT NULL;
ALTER TABLE webui_bookmarked_employees ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE webui_bookmarked_employees ALTER COLUMN BOOKMARKED_GID SET NOT NULL;
ALTER TABLE webui_bookmarked_employees ALTER COLUMN TIMESTAMP SET NOT NULL;


CREATE TABLE webui_cd_attribute_mapping (
	attr varchar(20),
	attr_ui varchar(20),
	attr_txt varchar(20)
) ;
COMMENT ON COLUMN webui_cd_attribute_mapping.attr IS E'attribute webserviceNG';
COMMENT ON COLUMN webui_cd_attribute_mapping.attr_txt IS E'txt=ldap attribute name';
COMMENT ON COLUMN webui_cd_attribute_mapping.attr_ui IS E'attribute name scd web ui';
ALTER  TABLE webui_cd_attribute_mapping OWNER TO scd_testuser;


CREATE TABLE webui_cd_fksource_mapping (
	liefntnr bigint NOT NULL,
	fksource varchar(40) NOT NULL,
	redirect varchar(500) NOT NULL
) ;
ALTER  TABLE webui_cd_fksource_mapping OWNER TO scd_testuser;
ALTER TABLE webui_cd_fksource_mapping ALTER COLUMN REDIRECT SET NOT NULL;
ALTER TABLE webui_cd_fksource_mapping ALTER COLUMN FKSOURCE SET NOT NULL;
ALTER TABLE webui_cd_fksource_mapping ALTER COLUMN LIEFNTNR SET NOT NULL;


CREATE TABLE webui_cd_gender_pronoun (
	id bigint NOT NULL,
	value varchar(40)
) ;
ALTER  TABLE webui_cd_gender_pronoun OWNER TO scd_testuser;
ALTER TABLE webui_cd_gender_pronoun ALTER COLUMN ID SET NOT NULL;


CREATE TABLE webui_cd_key_values (
	id bigint NOT NULL,
	key varchar(50) NOT NULL,
	language varchar(2) NOT NULL,
	infotext varchar(800),
	redirect varchar(500),
	redirectsponsoredentries varchar(500)
) ;
ALTER  TABLE webui_cd_key_values OWNER TO scd_testuser;
ALTER TABLE webui_cd_key_values ALTER COLUMN LANGUAGE SET NOT NULL;
ALTER TABLE webui_cd_key_values ALTER COLUMN KEY SET NOT NULL;
ALTER TABLE webui_cd_key_values ALTER COLUMN ID SET NOT NULL;


CREATE TABLE webui_change_data_config (
	liefntnr bigint NOT NULL,
	attribute varchar(20) NOT NULL,
	usertype varchar(1) NOT NULL,
	recordtype varchar(1) NOT NULL,
	check_are smallint NOT NULL DEFAULT 0,
	mail_to_sponsor smallint NOT NULL DEFAULT 0,
	priority bigint DEFAULT 0,
	key varchar(50),
	check_fksource bigint NOT NULL DEFAULT 0
) ;
COMMENT ON COLUMN webui_change_data_config.check_are IS E'0=false, 1=true';
COMMENT ON COLUMN webui_change_data_config.check_fksource IS E'0=false, 1=true';
COMMENT ON COLUMN webui_change_data_config.mail_to_sponsor IS E'0=false, 1=true';
COMMENT ON COLUMN webui_change_data_config.priority IS E'use entry with maximum priority';
ALTER  TABLE webui_change_data_config OWNER TO scd_testuser;
ALTER TABLE webui_change_data_config ALTER COLUMN CHECK_FKSOURCE SET NOT NULL;
ALTER TABLE webui_change_data_config ALTER COLUMN RECORDTYPE SET NOT NULL;
ALTER TABLE webui_change_data_config ALTER COLUMN USERTYPE SET NOT NULL;
ALTER TABLE webui_change_data_config ALTER COLUMN ATTRIBUTE SET NOT NULL;
ALTER TABLE webui_change_data_config ALTER COLUMN MAIL_TO_SPONSOR SET NOT NULL;
ALTER TABLE webui_change_data_config ALTER COLUMN CHECK_ARE SET NOT NULL;
ALTER TABLE webui_change_data_config ALTER COLUMN LIEFNTNR SET NOT NULL;


CREATE TABLE webui_countries (
	id bigint NOT NULL,
	country_code varchar(2) NOT NULL,
	country_name varchar(40) NOT NULL,
	language varchar(2) NOT NULL
) ;
ALTER  TABLE webui_countries OWNER TO scd_testuser;
ALTER TABLE webui_countries ALTER COLUMN ID SET NOT NULL;
ALTER TABLE webui_countries ALTER COLUMN COUNTRY_CODE SET NOT NULL;
ALTER TABLE webui_countries ALTER COLUMN COUNTRY_NAME SET NOT NULL;
ALTER TABLE webui_countries ALTER COLUMN LANGUAGE SET NOT NULL;


CREATE TABLE webui_last_viewed_employees (
	id bigint NOT NULL,
	userid varchar(8) NOT NULL,
	employee_gid varchar(8) NOT NULL,
	employee_sn varchar(40),
	employee_gn varchar(40),
	timestamp timestamp NOT NULL DEFAULT statement_timestamp()
) ;
ALTER  TABLE webui_last_viewed_employees OWNER TO scd_testuser;
CREATE UNIQUE INDEX webui_last_viewed_employee_pk ON webui_last_viewed_employees (id);
ALTER TABLE webui_last_viewed_employees ALTER COLUMN ID SET NOT NULL;
ALTER TABLE webui_last_viewed_employees ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE webui_last_viewed_employees ALTER COLUMN EMPLOYEE_GID SET NOT NULL;
ALTER TABLE webui_last_viewed_employees ALTER COLUMN TIMESTAMP SET NOT NULL;


CREATE TABLE webui_national_holidays (
	scd_country_code varchar(2) NOT NULL,
	holidaydate timestamp NOT NULL,
	year bigint NOT NULL,
	month bigint NOT NULL,
	holiday varchar(50),
	locations varchar(120)
) ;
ALTER  TABLE webui_national_holidays OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixwebuinationalholidays ON webui_national_holidays (scd_country_code, holidaydate, holiday);
ALTER TABLE webui_national_holidays ALTER COLUMN SCD_COUNTRY_CODE SET NOT NULL;
ALTER TABLE webui_national_holidays ALTER COLUMN HOLIDAYDATE SET NOT NULL;
ALTER TABLE webui_national_holidays ALTER COLUMN YEAR SET NOT NULL;
ALTER TABLE webui_national_holidays ALTER COLUMN MONTH SET NOT NULL;


CREATE TABLE webui_user_settings (
	id bigint NOT NULL,
	userid varchar(20) NOT NULL,
	key varchar(100) NOT NULL,
	value varchar(100)
) ;
ALTER  TABLE webui_user_settings OWNER TO scd_testuser;
CREATE UNIQUE INDEX idx_webui_user_settings ON webui_user_settings (userid, "key");
ALTER TABLE webui_user_settings ALTER COLUMN ID SET NOT NULL;
ALTER TABLE webui_user_settings ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE webui_user_settings ALTER COLUMN KEY SET NOT NULL;


CREATE TABLE zchn (
	zchnsatz varchar(20),
	zchn smallint,
	iso88 smallint
) ;
ALTER  TABLE zchn OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixzchn ON zchn (zchnsatz, zchn);


CREATE TABLE zchnsatz (
	zchnsatz varchar(20),
	txt varchar(120)
) ;
ALTER  TABLE zchnsatz OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixzchnsatz ON zchnsatz (zchnsatz);
ALTER TABLE ggw_chart_data ADD CONSTRAINT fk322c2953e47cae50 FOREIGN KEY (reportconfigurationid) REFERENCES ggw_report_config(id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;


/* Section 2.1 - VRT Table Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';


SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS vrt;
ALTER SCHEMA vrt OWNER TO scd_testuser;

SET search_path = vrt,oracle,public;


CREATE TABLE anbindung_are (
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	are varchar(6),
	cont_gid varchar(8),
	cont_name varchar(50),
	cont_vorname varchar(50),
	cont_l varchar(50),
	cont_abt varchar(50),
	cont_tel varchar(50),
	cont_mail varchar(50),
	responsibility varchar(50)
) ;
ALTER  TABLE anbindung_are OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixanbindung_are ON anbindung_are (vertragsnummer);


CREATE TABLE ap9965_avature (
	gid char(8),
	surname varchar(255),
	name varchar(255),
	email varchar(255),
	are varchar(255),
	country char(2),
	employeetype varchar(255),
	contractstatus varchar(255),
	exitdate varchar(255),
	status varchar(20),
	ts timestamp,
	clientid smallint
) ;
ALTER  TABLE ap9965_avature OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixap9965 ON ap9965_avature (gid);


CREATE TABLE ap9965_basis (
	gid char(8),
	surname varchar(255),
	name varchar(255),
	email varchar(255),
	are varchar(255),
	country char(2),
	employeetype varchar(255),
	contractstatus varchar(255),
	exitdate varchar(255),
	status varchar(20),
	ts timestamp
) ;
ALTER  TABLE ap9965_basis OWNER TO scd_testuser;


CREATE TABLE ap9965_basis_sicherung (
	gid char(8),
	surname varchar(255),
	name varchar(255),
	email varchar(255),
	are varchar(255),
	country char(2),
	employeetype varchar(255),
	contractstatus varchar(255),
	exitdate varchar(255),
	status varchar(20),
	ts timestamp
) ;
ALTER  TABLE ap9965_basis_sicherung OWNER TO scd_testuser;


CREATE TABLE app (
	app_id bigint NOT NULL,
	description varchar(1000),
	name varchar(100) NOT NULL
) ;
ALTER  TABLE app OWNER TO scd_testuser;
ALTER TABLE app ADD PRIMARY KEY (app_id);
ALTER TABLE app ALTER COLUMN APP_ID SET NOT NULL;
ALTER TABLE app ALTER COLUMN NAME SET NOT NULL;


CREATE TABLE app_config (
	config_id bigint NOT NULL,
	description varchar(1000),
	key varchar(100) NOT NULL,
	value varchar(4000),
	app_id bigint,
	app_name varchar(100)
) ;
ALTER  TABLE app_config OWNER TO scd_testuser;
ALTER TABLE app_config ADD PRIMARY KEY (config_id);
ALTER TABLE app_config ALTER COLUMN CONFIG_ID SET NOT NULL;
ALTER TABLE app_config ALTER COLUMN KEY SET NOT NULL;


CREATE TABLE ap_delivery (
	delivery_id bigint NOT NULL,
	contract_id bigint NOT NULL,
	name varchar(60) NOT NULL,
	description varchar(1000),
	enabled smallint NOT NULL,
	query varchar(4000),
	user_id bigint NOT NULL,
	added_ts timestamp NOT NULL DEFAULT statement_timestamp(),
	latest_run_result varchar(10) DEFAULT NULL,
	latest_run_ts timestamp,
	to_remove_ts timestamp,
	supp_data_file varchar(255),
	supp_data_filetype varchar(20),
	supp_data_delimiter char(1),
	supp_data_file_mod_ts timestamp,
	supp_data_has_header smallint NOT NULL DEFAULT 0,
	supp_data_enabled smallint NOT NULL DEFAULT 0,
	backup smallint NOT NULL DEFAULT 0,
	backup_count bigint,
	is_running smallint NOT NULL DEFAULT 0
) ;
ALTER  TABLE ap_delivery OWNER TO scd_testuser;
ALTER TABLE ap_delivery ADD PRIMARY KEY (delivery_id);
ALTER TABLE ap_delivery ALTER COLUMN DELIVERY_ID SET NOT NULL;
ALTER TABLE ap_delivery ALTER COLUMN CONTRACT_ID SET NOT NULL;
ALTER TABLE ap_delivery ALTER COLUMN NAME SET NOT NULL;
ALTER TABLE ap_delivery ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE ap_delivery ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ap_delivery ALTER COLUMN ADDED_TS SET NOT NULL;
ALTER TABLE ap_delivery ALTER COLUMN SUPP_DATA_HAS_HEADER SET NOT NULL;
ALTER TABLE ap_delivery ALTER COLUMN SUPP_DATA_ENABLED SET NOT NULL;
ALTER TABLE ap_delivery ALTER COLUMN BACKUP SET NOT NULL;
ALTER TABLE ap_delivery ALTER COLUMN IS_RUNNING SET NOT NULL;


CREATE TABLE ap_delivery_save (
	delivery_id bigint NOT NULL,
	contract_id bigint NOT NULL,
	name varchar(60) NOT NULL,
	description varchar(1000),
	enabled smallint NOT NULL,
	query varchar(4000),
	user_id bigint NOT NULL,
	added_ts timestamp NOT NULL,
	latest_run_result varchar(10),
	latest_run_ts timestamp,
	to_remove_ts timestamp,
	supp_data_file varchar(255),
	supp_data_filetype varchar(20),
	supp_data_delimiter char(1),
	supp_data_file_mod_ts timestamp,
	supp_data_has_header smallint NOT NULL,
	supp_data_enabled smallint NOT NULL,
	backup smallint NOT NULL,
	backup_count bigint
) ;
ALTER  TABLE ap_delivery_save OWNER TO scd_testuser;
ALTER TABLE ap_delivery_save ALTER COLUMN DELIVERY_ID SET NOT NULL;
ALTER TABLE ap_delivery_save ALTER COLUMN CONTRACT_ID SET NOT NULL;
ALTER TABLE ap_delivery_save ALTER COLUMN NAME SET NOT NULL;
ALTER TABLE ap_delivery_save ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE ap_delivery_save ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ap_delivery_save ALTER COLUMN ADDED_TS SET NOT NULL;
ALTER TABLE ap_delivery_save ALTER COLUMN SUPP_DATA_HAS_HEADER SET NOT NULL;
ALTER TABLE ap_delivery_save ALTER COLUMN SUPP_DATA_ENABLED SET NOT NULL;
ALTER TABLE ap_delivery_save ALTER COLUMN BACKUP SET NOT NULL;


CREATE TABLE ap_exporter (
	exporter_id bigint NOT NULL,
	scheduler_id bigint NOT NULL,
	file_name varchar(250) NOT NULL,
	file_format varchar(20) NOT NULL,
	output_to varchar(20) NOT NULL,
	delimiter char(1),
	charset varchar(25) NOT NULL DEFAULT 'UTF-8',
	zip_data smallint NOT NULL DEFAULT 0,
	print_header smallint NOT NULL DEFAULT 1,
	openft_addr varchar(128),
	openft_transfer_adm varchar(75),
	enabled smallint NOT NULL,
	user_id bigint NOT NULL,
	added_ts timestamp NOT NULL DEFAULT statement_timestamp(),
	download_for varchar(180),
	transfer_files smallint NOT NULL DEFAULT NULL,
	delta_enabled smallint NOT NULL DEFAULT 0,
	delta_indexes varchar(1000),
	delta_indexes_all smallint NOT NULL DEFAULT 0,
	print_status_column smallint NOT NULL DEFAULT 0,
	transfer_data smallint NOT NULL DEFAULT 0,
	transfer_delta smallint NOT NULL DEFAULT 0,
	zip_delta smallint NOT NULL DEFAULT 0,
	zip_file_name varchar(250),
	double_quotes_enclosing smallint NOT NULL DEFAULT 0,
	line_break varchar(20) DEFAULT 'WIN',
	sign_transfer_files smallint NOT NULL DEFAULT 0,
	sftp_user varchar(50),
	sftp_host varchar(100),
	sftp_port bigint,
	sftp_folder varchar(255)
) ;
ALTER  TABLE ap_exporter OWNER TO scd_testuser;
ALTER TABLE ap_exporter ADD PRIMARY KEY (exporter_id);
ALTER TABLE ap_exporter ADD CONSTRAINT ap_exporter_uc_file_name CHECK (file_format = UPPER(file_format));
ALTER TABLE ap_exporter ADD CONSTRAINT ap_exporter_uc_output_to CHECK (output_to = UPPER(output_to));
ALTER TABLE ap_exporter ALTER COLUMN EXPORTER_ID SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN SCHEDULER_ID SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN FILE_NAME SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN FILE_FORMAT SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN OUTPUT_TO SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN CHARSET SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN ZIP_DATA SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN PRINT_HEADER SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN ADDED_TS SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN TRANSFER_FILES SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN DELTA_ENABLED SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN DELTA_INDEXES_ALL SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN PRINT_STATUS_COLUMN SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN TRANSFER_DATA SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN TRANSFER_DELTA SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN ZIP_DELTA SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN DOUBLE_QUOTES_ENCLOSING SET NOT NULL;
ALTER TABLE ap_exporter ALTER COLUMN SIGN_TRANSFER_FILES SET NOT NULL;


CREATE TABLE ap_exporter_log (
	exporter_log_id bigint NOT NULL,
	delivery_id bigint NOT NULL,
	exporter_id bigint,
	start_ts timestamp NOT NULL,
	end_ts timestamp,
	initiated_by varchar(20) NOT NULL,
	file_path varchar(255),
	zip_file_path varchar(255),
	result varchar(10) NOT NULL,
	error_description varchar(4000),
	error_stage varchar(40),
	record_count bigint,
	transferred smallint NOT NULL DEFAULT 0,
	data_file_name varchar(255),
	delta_file_path varchar(255),
	delta_file_name varchar(255),
	delta_record_count bigint DEFAULT 0
) ;
ALTER  TABLE ap_exporter_log OWNER TO scd_testuser;
ALTER TABLE ap_exporter_log ADD PRIMARY KEY (exporter_log_id);
ALTER TABLE ap_exporter_log ADD CONSTRAINT ap_exporter_log_uc_init_by CHECK (initiated_by = UPPER(initiated_by));
ALTER TABLE ap_exporter_log ADD CONSTRAINT ap_exporter_log_uc_result CHECK (result = UPPER(result));
ALTER TABLE ap_exporter_log ALTER COLUMN EXPORTER_LOG_ID SET NOT NULL;
ALTER TABLE ap_exporter_log ALTER COLUMN DELIVERY_ID SET NOT NULL;
ALTER TABLE ap_exporter_log ALTER COLUMN START_TS SET NOT NULL;
ALTER TABLE ap_exporter_log ALTER COLUMN INITIATED_BY SET NOT NULL;
ALTER TABLE ap_exporter_log ALTER COLUMN RESULT SET NOT NULL;
ALTER TABLE ap_exporter_log ALTER COLUMN TRANSFERRED SET NOT NULL;


CREATE TABLE ap_exporter_log_save (
	exporter_log_id bigint NOT NULL,
	delivery_id bigint NOT NULL,
	exporter_id bigint,
	start_ts timestamp NOT NULL,
	end_ts timestamp,
	initiated_by varchar(20) NOT NULL,
	file_path varchar(255),
	zip_file_path varchar(255),
	result varchar(10) NOT NULL,
	error_description varchar(4000),
	error_stage varchar(20),
	record_count bigint,
	transferred smallint NOT NULL,
	file_name varchar(255)
) ;
ALTER  TABLE ap_exporter_log_save OWNER TO scd_testuser;
ALTER TABLE ap_exporter_log_save ALTER COLUMN EXPORTER_LOG_ID SET NOT NULL;
ALTER TABLE ap_exporter_log_save ALTER COLUMN DELIVERY_ID SET NOT NULL;
ALTER TABLE ap_exporter_log_save ALTER COLUMN START_TS SET NOT NULL;
ALTER TABLE ap_exporter_log_save ALTER COLUMN INITIATED_BY SET NOT NULL;
ALTER TABLE ap_exporter_log_save ALTER COLUMN RESULT SET NOT NULL;
ALTER TABLE ap_exporter_log_save ALTER COLUMN TRANSFERRED SET NOT NULL;


CREATE TABLE ap_exporter_save (
	exporter_id bigint NOT NULL,
	scheduler_id bigint NOT NULL,
	file_name varchar(250) NOT NULL,
	file_format varchar(20) NOT NULL,
	output_to varchar(20) NOT NULL,
	delimiter char(1),
	charset varchar(25) NOT NULL,
	zip smallint NOT NULL,
	print_header smallint NOT NULL,
	openft_addr varchar(128),
	openft_transfer_adm varchar(75),
	enabled smallint NOT NULL,
	user_id bigint NOT NULL,
	added_ts timestamp NOT NULL,
	download_for varchar(180),
	transfer_files smallint NOT NULL,
	zip_file_name varchar(250)
) ;
ALTER  TABLE ap_exporter_save OWNER TO scd_testuser;
ALTER TABLE ap_exporter_save ALTER COLUMN EXPORTER_ID SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN SCHEDULER_ID SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN FILE_NAME SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN FILE_FORMAT SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN OUTPUT_TO SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN CHARSET SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN ZIP SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN PRINT_HEADER SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN ADDED_TS SET NOT NULL;
ALTER TABLE ap_exporter_save ALTER COLUMN TRANSFER_FILES SET NOT NULL;


CREATE TABLE ap_scheduler (
	scheduler_id bigint NOT NULL,
	delivery_id bigint NOT NULL,
	cron varchar(50) NOT NULL,
	enabled smallint NOT NULL,
	user_id bigint NOT NULL,
	added_ts timestamp NOT NULL DEFAULT statement_timestamp()
) ;
ALTER  TABLE ap_scheduler OWNER TO scd_testuser;
ALTER TABLE ap_scheduler ADD PRIMARY KEY (scheduler_id);
ALTER TABLE ap_scheduler ALTER COLUMN SCHEDULER_ID SET NOT NULL;
ALTER TABLE ap_scheduler ALTER COLUMN DELIVERY_ID SET NOT NULL;
ALTER TABLE ap_scheduler ALTER COLUMN CRON SET NOT NULL;
ALTER TABLE ap_scheduler ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE ap_scheduler ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ap_scheduler ALTER COLUMN ADDED_TS SET NOT NULL;


CREATE TABLE ap_scheduler_save (
	scheduler_id bigint NOT NULL,
	delivery_id bigint NOT NULL,
	cron varchar(50) NOT NULL,
	enabled smallint NOT NULL,
	user_id bigint NOT NULL,
	added_ts timestamp NOT NULL
) ;
ALTER  TABLE ap_scheduler_save OWNER TO scd_testuser;
ALTER TABLE ap_scheduler_save ALTER COLUMN SCHEDULER_ID SET NOT NULL;
ALTER TABLE ap_scheduler_save ALTER COLUMN DELIVERY_ID SET NOT NULL;
ALTER TABLE ap_scheduler_save ALTER COLUMN CRON SET NOT NULL;
ALTER TABLE ap_scheduler_save ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE ap_scheduler_save ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ap_scheduler_save ALTER COLUMN ADDED_TS SET NOT NULL;


CREATE TABLE ap_supp_data (
	delivery_id bigint NOT NULL,
	col1 varchar(4000),
	col2 varchar(4000),
	col3 varchar(4000),
	col4 varchar(4000),
	col5 varchar(4000),
	col6 varchar(4000),
	col7 varchar(4000),
	col8 varchar(4000),
	col9 varchar(4000),
	col10 varchar(4000),
	col11 varchar(4000),
	col12 varchar(4000),
	col13 varchar(4000),
	col14 varchar(4000),
	col15 varchar(4000),
	col16 varchar(4000),
	col17 varchar(4000),
	col18 varchar(4000),
	col19 varchar(4000),
	col20 varchar(4000),
	col21 varchar(4000),
	col22 varchar(4000),
	col23 varchar(4000),
	col24 varchar(4000),
	col25 varchar(4000),
	col26 varchar(4000),
	col27 varchar(4000),
	col28 varchar(4000),
	col29 varchar(4000),
	col30 varchar(4000),
	col31 varchar(4000),
	col32 varchar(4000),
	col33 varchar(4000),
	col34 varchar(4000),
	col35 varchar(4000),
	col36 varchar(4000),
	col37 varchar(4000),
	col38 varchar(4000),
	col39 varchar(4000),
	col40 varchar(4000),
	col41 varchar(4000),
	col42 varchar(4000),
	col43 varchar(4000),
	col44 varchar(4000),
	col45 varchar(4000),
	col46 varchar(4000),
	col47 varchar(4000),
	col48 varchar(4000),
	col49 varchar(4000),
	col50 varchar(4000),
	col51 varchar(4000),
	col52 varchar(4000),
	col53 varchar(4000),
	col54 varchar(4000),
	col55 varchar(4000),
	col56 varchar(4000),
	col57 varchar(4000),
	col58 varchar(4000),
	col59 varchar(4000),
	col60 varchar(4000),
	col61 varchar(4000),
	col62 varchar(4000),
	col63 varchar(4000),
	col64 varchar(4000),
	col65 varchar(4000),
	col66 varchar(4000),
	col67 varchar(4000),
	col68 varchar(4000),
	col69 varchar(4000),
	col70 varchar(4000),
	col71 varchar(4000),
	col72 varchar(4000),
	col73 varchar(4000),
	col74 varchar(4000),
	col75 varchar(4000),
	col76 varchar(4000),
	col77 varchar(4000),
	col78 varchar(4000),
	col79 varchar(4000),
	col80 varchar(4000),
	col81 varchar(4000),
	col82 varchar(4000),
	col83 varchar(4000),
	col84 varchar(4000),
	col85 varchar(4000),
	col86 varchar(4000),
	col87 varchar(4000),
	col88 varchar(4000),
	col89 varchar(4000),
	col90 varchar(4000),
	col91 varchar(4000),
	col92 varchar(4000),
	col93 varchar(4000),
	col94 varchar(4000),
	col95 varchar(4000),
	col96 varchar(4000),
	col97 varchar(4000),
	col98 varchar(4000),
	col99 varchar(4000),
	col100 varchar(4000),
	supp_data_id bigint NOT NULL
) ;
ALTER  TABLE ap_supp_data OWNER TO scd_testuser;
ALTER TABLE ap_supp_data ADD PRIMARY KEY (supp_data_id);
ALTER TABLE ap_supp_data ALTER COLUMN DELIVERY_ID SET NOT NULL;


CREATE TABLE ap_supp_data_save (
	delivery_id bigint NOT NULL,
	col1 varchar(4000),
	col2 varchar(4000),
	col3 varchar(4000),
	col4 varchar(4000),
	col5 varchar(4000),
	col6 varchar(4000),
	col7 varchar(4000),
	col8 varchar(4000),
	col9 varchar(4000),
	col10 varchar(4000),
	col11 varchar(4000),
	col12 varchar(4000),
	col13 varchar(4000),
	col14 varchar(4000),
	col15 varchar(4000),
	col16 varchar(4000),
	col17 varchar(4000),
	col18 varchar(4000),
	col19 varchar(4000),
	col20 varchar(4000),
	col21 varchar(4000),
	col22 varchar(4000),
	col23 varchar(4000),
	col24 varchar(4000),
	col25 varchar(4000),
	col26 varchar(4000),
	col27 varchar(4000),
	col28 varchar(4000),
	col29 varchar(4000),
	col30 varchar(4000),
	col31 varchar(4000),
	col32 varchar(4000),
	col33 varchar(4000),
	col34 varchar(4000),
	col35 varchar(4000),
	col36 varchar(4000),
	col37 varchar(4000),
	col38 varchar(4000),
	col39 varchar(4000),
	col40 varchar(4000),
	col41 varchar(4000),
	col42 varchar(4000),
	col43 varchar(4000),
	col44 varchar(4000),
	col45 varchar(4000),
	col46 varchar(4000),
	col47 varchar(4000),
	col48 varchar(4000),
	col49 varchar(4000),
	col50 varchar(4000),
	col51 varchar(4000),
	col52 varchar(4000),
	col53 varchar(4000),
	col54 varchar(4000),
	col55 varchar(4000),
	col56 varchar(4000),
	col57 varchar(4000),
	col58 varchar(4000),
	col59 varchar(4000),
	col60 varchar(4000),
	col61 varchar(4000),
	col62 varchar(4000),
	col63 varchar(4000),
	col64 varchar(4000),
	col65 varchar(4000),
	col66 varchar(4000),
	col67 varchar(4000),
	col68 varchar(4000),
	col69 varchar(4000),
	col70 varchar(4000),
	col71 varchar(4000),
	col72 varchar(4000),
	col73 varchar(4000),
	col74 varchar(4000),
	col75 varchar(4000),
	col76 varchar(4000),
	col77 varchar(4000),
	col78 varchar(4000),
	col79 varchar(4000),
	col80 varchar(4000),
	col81 varchar(4000),
	col82 varchar(4000),
	col83 varchar(4000),
	col84 varchar(4000),
	col85 varchar(4000),
	col86 varchar(4000),
	col87 varchar(4000),
	col88 varchar(4000),
	col89 varchar(4000),
	col90 varchar(4000),
	col91 varchar(4000),
	col92 varchar(4000),
	col93 varchar(4000),
	col94 varchar(4000),
	col95 varchar(4000),
	col96 varchar(4000),
	col97 varchar(4000),
	col98 varchar(4000),
	col99 varchar(4000),
	col100 varchar(4000),
	supp_data_id bigint
) ;
ALTER  TABLE ap_supp_data_save OWNER TO scd_testuser;
ALTER TABLE ap_supp_data_save ALTER COLUMN DELIVERY_ID SET NOT NULL;


CREATE TABLE ap_supp_metadata (
	delivery_id bigint NOT NULL,
	col_number bigint,
	title varchar(50),
	transform_fn varchar(100),
	supp_metadata_id bigint NOT NULL,
	transform_fn_arg1 varchar(100),
	transform_fn_arg2 varchar(100),
	transform_fn_arg3 varchar(100)
) ;
ALTER  TABLE ap_supp_metadata OWNER TO scd_testuser;
ALTER TABLE ap_supp_metadata ALTER COLUMN DELIVERY_ID SET NOT NULL;
ALTER TABLE ap_supp_metadata ALTER COLUMN SUPP_METADATA_ID SET NOT NULL;


CREATE TABLE ap_supp_metadata_save (
	delivery_id bigint NOT NULL,
	col_number bigint,
	title varchar(50),
	transform_fn varchar(100),
	supp_metadata_id bigint NOT NULL,
	transform_fn_arg1 varchar(100),
	transform_fn_arg2 varchar(100),
	transform_fn_arg3 varchar(100)
) ;
ALTER  TABLE ap_supp_metadata_save OWNER TO scd_testuser;
ALTER TABLE ap_supp_metadata_save ALTER COLUMN DELIVERY_ID SET NOT NULL;
ALTER TABLE ap_supp_metadata_save ALTER COLUMN SUPP_METADATA_ID SET NOT NULL;


CREATE TABLE ap_user (
	user_id bigint NOT NULL,
	gid varchar(8) NOT NULL,
	first_name varchar(50) NOT NULL,
	last_name varchar(50) NOT NULL,
	email varchar(75) NOT NULL,
	enabled smallint NOT NULL,
	role varchar(20) NOT NULL,
	added_ts timestamp NOT NULL DEFAULT statement_timestamp()
) ;
ALTER  TABLE ap_user OWNER TO scd_testuser;
ALTER TABLE ap_user ADD PRIMARY KEY (user_id);
ALTER TABLE ap_user ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ap_user ALTER COLUMN GID SET NOT NULL;
ALTER TABLE ap_user ALTER COLUMN FIRST_NAME SET NOT NULL;
ALTER TABLE ap_user ALTER COLUMN LAST_NAME SET NOT NULL;
ALTER TABLE ap_user ALTER COLUMN EMAIL SET NOT NULL;
ALTER TABLE ap_user ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE ap_user ALTER COLUMN ROLE SET NOT NULL;
ALTER TABLE ap_user ALTER COLUMN ADDED_TS SET NOT NULL;


CREATE TABLE ap_user_save (
	user_id bigint NOT NULL,
	gid varchar(8) NOT NULL,
	first_name varchar(50) NOT NULL,
	last_name varchar(50) NOT NULL,
	email varchar(75) NOT NULL,
	enabled smallint NOT NULL,
	role varchar(20) NOT NULL,
	added_ts timestamp NOT NULL
) ;
ALTER  TABLE ap_user_save OWNER TO scd_testuser;
ALTER TABLE ap_user_save ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ap_user_save ALTER COLUMN GID SET NOT NULL;
ALTER TABLE ap_user_save ALTER COLUMN FIRST_NAME SET NOT NULL;
ALTER TABLE ap_user_save ALTER COLUMN LAST_NAME SET NOT NULL;
ALTER TABLE ap_user_save ALTER COLUMN EMAIL SET NOT NULL;
ALTER TABLE ap_user_save ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE ap_user_save ALTER COLUMN ROLE SET NOT NULL;
ALTER TABLE ap_user_save ALTER COLUMN ADDED_TS SET NOT NULL;


CREATE TABLE as_billing (
	id bigint NOT NULL,
	given_name varchar(50),
	surname varchar(50),
	company varchar(50),
	department varchar(50),
	org_id varchar(20),
	order_id varchar(50),
	position_nr bigint,
	n bigint,
	la varchar(10),
	destination varchar(50),
	sum bigint,
	service varchar(50),
	service_year smallint,
	service_month smallint,
	a_are varchar(10),
	contract_id varchar(50),
	subject varchar(100),
	client_id smallint,
	correction smallint NOT NULL DEFAULT 0,
	exported timestamp
) ;
ALTER  TABLE as_billing OWNER TO scd_testuser;
ALTER TABLE as_billing ADD PRIMARY KEY (id);
ALTER TABLE as_billing ALTER COLUMN ID SET NOT NULL;
ALTER TABLE as_billing ALTER COLUMN CORRECTION SET NOT NULL;


CREATE TABLE as_pricelist (
	service varchar(20),
	amount_from bigint,
	amount_to bigint,
	price bigint,
	info varchar(20)
) ;
ALTER  TABLE as_pricelist OWNER TO scd_testuser;


CREATE TABLE as_pricing (
	service varchar(50) NOT NULL,
	amount bigint NOT NULL,
	price bigint
) ;
ALTER  TABLE as_pricing OWNER TO scd_testuser;
ALTER TABLE as_pricing ADD PRIMARY KEY (service,amount);


CREATE TABLE bearbeiter (
	kurzzeichen varchar(50),
	gid varchar(8),
	name varchar(50),
	vorname varchar(50),
	abteilung varchar(50),
	mail varchar(50),
	nt_kennung varchar(50)
) ;
ALTER  TABLE bearbeiter OWNER TO scd_testuser;


CREATE TABLE check_functions (
	delivery_id numeric(38) NOT NULL,
	sqlstatement varchar(2000),
	threshold numeric(38),
	deliverycheckfailstatus smallint,
	info varchar(256),
	id bigint NOT NULL
) ;
ALTER  TABLE check_functions OWNER TO scd_testuser;
ALTER TABLE check_functions ADD PRIMARY KEY (id);
ALTER TABLE check_functions ALTER COLUMN DELIVERY_ID SET NOT NULL;


CREATE TABLE check_mon_exp_prot (
	exectime timestamp,
	parameter numeric(38),
	scdx_createtime timestamp
) ;
ALTER  TABLE check_mon_exp_prot OWNER TO scd_testuser;


CREATE TABLE delivery_status_change (
	delivery_id numeric(38) NOT NULL,
	deliverystatusifscdtableold smallint NOT NULL,
	info varchar(256)
) ;
ALTER  TABLE delivery_status_change OWNER TO scd_testuser;
ALTER TABLE delivery_status_change ADD UNIQUE (delivery_id);
ALTER TABLE delivery_status_change ALTER COLUMN DELIVERY_ID SET NOT NULL;
ALTER TABLE delivery_status_change ALTER COLUMN DELIVERYSTATUSIFSCDTABLEOLD SET NOT NULL;


CREATE TABLE el_audit (
	account varchar(128),
	gid_typ varchar(26),
	vertragsanzahl numeric(38),
	trefferuebrig numeric(38),
	quota varchar(26),
	treffermenge numeric(38),
	zugriffe numeric(38),
	vertragspreis numeric(38),
	vertragsmailkunde varchar(128),
	month_year varchar(20)
) ;
ALTER  TABLE el_audit OWNER TO scd_testuser;


CREATE TABLE ergebnis (
	verteiler_nummer integer,
	laufende_nummer integer,
	verteiler_art char(1),
	mailadresse varchar(120),
	name varchar(32),
	vorname varchar(32),
	abteilung varchar(32),
	telefon varchar(16),
	raum varchar(16),
	bereich varchar(32),
	standort varchar(32),
	firma varchar(32),
	land char(2),
	inhalt_nummer smallint,
	ignore smallint,
	gid char(8)
) ;
ALTER  TABLE ergebnis OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixergebnis ON ergebnis (verteiler_nummer, laufende_nummer);


CREATE TABLE e_asp (
	vertragsart char(2),
	vertragsnummer bigint,
	mandant varchar(250)
) ;
ALTER  TABLE e_asp OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixe_asp ON e_asp (vertragsnummer);


CREATE TABLE e_contract_server (
	ecs_id bigint,
	ecs_contract_id bigint,
	ecs_system_identifier varchar(3),
	ecs_server_id varchar(250)
) ;
ALTER  TABLE e_contract_server OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixe_contract_server ON e_contract_server (ecs_id, ecs_contract_id);


CREATE TABLE e_ga_resource (
	ers_id bigint,
	ers_resource_id varchar(250),
	ers_system_identifier varchar(3),
	ers_ts_create varchar(100),
	ers_ts_modify varchar(100)
) ;
ALTER  TABLE e_ga_resource OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixe_ga_resource ON e_ga_resource (ers_id, ers_resource_id);


CREATE TABLE e_ga_server (
	esr_id bigint,
	esr_server_id varchar(250),
	esr_system_identifier varchar(3),
	esr_ts_create varchar(100),
	esr_ts_modify varchar(100)
) ;
ALTER  TABLE e_ga_server OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixe_ga_server ON e_ga_server (esr_id);


CREATE TABLE e_start_url (
	esu_id bigint,
	vertragsnummer bigint,
	esu_url varchar(250)
) ;
ALTER  TABLE e_start_url OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixe_start_url ON e_start_url (esu_id, vertragsnummer);


CREATE TABLE e_unprotected_url (
	euu_id bigint,
	vertragsnummer bigint,
	euu_url varchar(250)
) ;
ALTER  TABLE e_unprotected_url OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixe_unprotected_url ON e_unprotected_url (euu_id, vertragsnummer);


CREATE TABLE e_vertraege_zusatz (
	vertragsnummer bigint,
	evz_entitlement_status varchar(50),
	evz_system_linie varchar(50),
	evz_application_port varchar(50),
	evz_lm_username smallint,
	evz_lm_windows smallint,
	evz_lm_pki smallint,
	evz_lm_grid smallint,
	evz_lm_sms smallint,
	evz_lm_token smallint,
	evz_default_login_page smallint,
	evz_login_page varchar(250),
	evz_internet smallint,
	evz_intranet smallint,
	evz_pm_authentication_only smallint,
	evz_int_entitlement_only smallint,
	evz_operating_system varchar(50),
	evz_sslloadbalancer smallint,
	evz_user_type_internal smallint,
	evz_user_type_external smallint,
	evz_webserver varchar(50)
) ;
ALTER  TABLE e_vertraege_zusatz OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixe_vertraege_zusatz ON e_vertraege_zusatz (vertragsnummer);


CREATE TABLE filter (
	verteiler_nummer integer,
	inhalt_nummer smallint,
	laufende_nummer integer,
	gid char(8)
) ;
ALTER  TABLE filter OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixfilter ON filter (verteiler_nummer, inhalt_nummer, laufende_nummer);


CREATE TABLE gb_dss2 (
	ecgid varchar(26),
	ecstatus varchar(26),
	ecsystem varchar(26)
) ;
ALTER  TABLE gb_dss2 OWNER TO scd_testuser;


CREATE TABLE gb_ru_adobe (
	emailaddress varchar(128)
) ;
ALTER  TABLE gb_ru_adobe OWNER TO scd_testuser;


CREATE TABLE gb_yunex_cert (
	gid varchar(26)
) ;
ALTER  TABLE gb_yunex_cert OWNER TO scd_testuser;


CREATE TABLE gb_yunex_de (
	gid varchar(26)
) ;
ALTER  TABLE gb_yunex_de OWNER TO scd_testuser;


CREATE TABLE gc_case (
	case_id bigint NOT NULL,
	added_at timestamp,
	cleared bigint NOT NULL,
	cleared_at timestamp,
	escalation_counter bigint NOT NULL,
	escalation_level varchar(50) NOT NULL,
	gid varchar(8) NOT NULL,
	last_escalation_at timestamp,
	last_owner varchar(255),
	last_owner_counter bigint,
	manually_cleared bigint,
	obs varchar(4000),
	to_check bigint NOT NULL,
	week_count bigint NOT NULL,
	run_data_id bigint
) ;
ALTER  TABLE gc_case OWNER TO scd_testuser;
CREATE INDEX ix_gc_case_gid ON gc_case (gid);
ALTER TABLE gc_case ADD PRIMARY KEY (case_id);
ALTER TABLE gc_case ALTER COLUMN CASE_ID SET NOT NULL;
ALTER TABLE gc_case ALTER COLUMN CLEARED SET NOT NULL;
ALTER TABLE gc_case ALTER COLUMN ESCALATION_COUNTER SET NOT NULL;
ALTER TABLE gc_case ALTER COLUMN ESCALATION_LEVEL SET NOT NULL;
ALTER TABLE gc_case ALTER COLUMN GID SET NOT NULL;
ALTER TABLE gc_case ALTER COLUMN TO_CHECK SET NOT NULL;
ALTER TABLE gc_case ALTER COLUMN WEEK_COUNT SET NOT NULL;


CREATE TABLE gc_country (
	country_id bigint NOT NULL,
	abbreviation varchar(50),
	added_at timestamp,
	are varchar(255),
	gid varchar(8),
	gn varchar(255),
	mail varchar(100),
	name varchar(100) NOT NULL,
	sn varchar(255),
	lead_country_id bigint,
	user_id bigint
) ;
ALTER  TABLE gc_country OWNER TO scd_testuser;
ALTER TABLE gc_country ADD PRIMARY KEY (country_id);
ALTER TABLE gc_country ALTER COLUMN COUNTRY_ID SET NOT NULL;
ALTER TABLE gc_country ALTER COLUMN NAME SET NOT NULL;


CREATE TABLE gc_email_template (
	template_id bigint NOT NULL,
	body text,
	name varchar(100) NOT NULL,
	sender varchar(255),
	subject varchar(255),
	use_for_error_notifications bigint,
	use_for_escalation bigint,
	use_for_query_notifications bigint,
	use_for_success_notifications bigint,
	user_id bigint NOT NULL
) ;
ALTER  TABLE gc_email_template OWNER TO scd_testuser;
ALTER TABLE gc_email_template ADD PRIMARY KEY (template_id);
ALTER TABLE gc_email_template ALTER COLUMN TEMPLATE_ID SET NOT NULL;
ALTER TABLE gc_email_template ALTER COLUMN NAME SET NOT NULL;
ALTER TABLE gc_email_template ALTER COLUMN USER_ID SET NOT NULL;


CREATE TABLE gc_escalation (
	escalation_id bigint NOT NULL,
	added_at timestamp,
	email_bcc varchar(512),
	email_body text,
	email_cc varchar(512),
	email_from varchar(255),
	email_subject varchar(255),
	email_to varchar(512),
	escalation_level varchar(50) NOT NULL,
	obs varchar(2000),
	email_template_id bigint,
	user_id bigint NOT NULL
) ;
ALTER  TABLE gc_escalation OWNER TO scd_testuser;
ALTER TABLE gc_escalation ADD PRIMARY KEY (escalation_id);
ALTER TABLE gc_escalation ALTER COLUMN ESCALATION_ID SET NOT NULL;
ALTER TABLE gc_escalation ALTER COLUMN ESCALATION_LEVEL SET NOT NULL;
ALTER TABLE gc_escalation ALTER COLUMN USER_ID SET NOT NULL;


CREATE TABLE gc_escalation_cases (
	escalation_id bigint NOT NULL,
	case_id bigint NOT NULL
) ;
ALTER  TABLE gc_escalation_cases OWNER TO scd_testuser;
ALTER TABLE gc_escalation_cases ALTER COLUMN ESCALATION_ID SET NOT NULL;
ALTER TABLE gc_escalation_cases ALTER COLUMN CASE_ID SET NOT NULL;


CREATE TABLE gc_open_cases (
	escalation_counter bigint,
	escalation_date timestamp,
	counter_last_owner bigint,
	counter bigint,
	last_owner varchar(200),
	report varchar(200),
	gid1 varchar(200),
	gid2 varchar(200),
	db_entry timestamp
) ;
ALTER  TABLE gc_open_cases OWNER TO scd_testuser;


CREATE TABLE gc_query (
	query_id bigint NOT NULL,
	added_at timestamp NOT NULL,
	cron varchar(100),
	description varchar(500),
	disabled_escalation bigint,
	enabled bigint NOT NULL,
	error_notif_recipients varchar(4000),
	internal bigint NOT NULL,
	name varchar(100) NOT NULL,
	report_code varchar(100) NOT NULL,
	send_owner_notifications bigint NOT NULL,
	query text NOT NULL,
	status varchar(100),
	success_notif_recipients varchar(4000),
	error_notif_template_id bigint,
	notification_template_id bigint,
	success_notif_template_id bigint,
	user_id bigint NOT NULL,
	excluded_client_ids varchar(10),
	excluded_suppliers_gids varchar(100)
) ;
ALTER  TABLE gc_query OWNER TO scd_testuser;
ALTER TABLE gc_query ADD PRIMARY KEY (query_id);
ALTER TABLE gc_query ALTER COLUMN QUERY_ID SET NOT NULL;
ALTER TABLE gc_query ALTER COLUMN ADDED_AT SET NOT NULL;
ALTER TABLE gc_query ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE gc_query ALTER COLUMN INTERNAL SET NOT NULL;
ALTER TABLE gc_query ALTER COLUMN NAME SET NOT NULL;
ALTER TABLE gc_query ALTER COLUMN REPORT_CODE SET NOT NULL;
ALTER TABLE gc_query ALTER COLUMN SEND_OWNER_NOTIFICATIONS SET NOT NULL;
ALTER TABLE gc_query ALTER COLUMN QUERY SET NOT NULL;
ALTER TABLE gc_query ALTER COLUMN USER_ID SET NOT NULL;


CREATE TABLE gc_run (
	run_id bigint NOT NULL,
	cases_cleared bigint,
	cases_new bigint,
	ended_at timestamp NOT NULL,
	error_details varchar(4000),
	started_at timestamp NOT NULL,
	status varchar(100) NOT NULL,
	query_id bigint,
	started_by_user_id bigint
) ;
ALTER  TABLE gc_run OWNER TO scd_testuser;
ALTER TABLE gc_run ADD PRIMARY KEY (run_id);
ALTER TABLE gc_run ALTER COLUMN RUN_ID SET NOT NULL;
ALTER TABLE gc_run ALTER COLUMN ENDED_AT SET NOT NULL;
ALTER TABLE gc_run ALTER COLUMN STARTED_AT SET NOT NULL;
ALTER TABLE gc_run ALTER COLUMN STATUS SET NOT NULL;


CREATE TABLE gc_run_data (
	run_data_id bigint NOT NULL,
	added_at timestamp,
	are varchar(255),
	are_2 varchar(255),
	birth_date timestamp,
	birth_date_2 timestamp,
	c varchar(255),
	c_2 varchar(255),
	gid varchar(8),
	gid_2 varchar(8),
	gn varchar(255),
	gn_2 varchar(255),
	is_in_scd bigint,
	l varchar(255),
	l_2 varchar(255),
	leave_date timestamp,
	leave_date_2 timestamp,
	mail varchar(255),
	mail_2 varchar(255),
	o varchar(255),
	o_2 varchar(255),
	ou varchar(255),
	ou_2 varchar(255),
	owner_gid varchar(8) NOT NULL,
	owner_gid_2 varchar(8),
	owner_mail varchar(255),
	owner_mail_2 varchar(255),
	owner_sponsor_mail varchar(255),
	owner_sponsor_mail_2 varchar(255),
	pki varchar(255),
	pki_2 varchar(255),
	probable_creator varchar(8),
	sn varchar(255),
	sn_2 varchar(255),
	sponsor_gid varchar(8),
	sponsor_gid_2 varchar(8),
	user_type varchar(1),
	user_type_2 varchar(1),
	run_id bigint,
	clientid smallint,
	clientid_2 smallint,
	org_code varchar(256),
	record_type char(1),
	org_code_2 varchar(256),
	record_type_2 char(1)
) ;
ALTER  TABLE gc_run_data OWNER TO scd_testuser;
ALTER TABLE gc_run_data ADD PRIMARY KEY (run_data_id);
ALTER TABLE gc_run_data ALTER COLUMN RUN_DATA_ID SET NOT NULL;
ALTER TABLE gc_run_data ALTER COLUMN OWNER_GID SET NOT NULL;


CREATE TABLE gc_two_diff_persons (
	gid1 varchar(10),
	gid2 varchar(10),
	gn1 varchar(200),
	sn1 varchar(200),
	bd1 timestamp,
	gn2 varchar(200),
	sn2 varchar(200),
	bd2 timestamp
) ;
ALTER  TABLE gc_two_diff_persons OWNER TO scd_testuser;


CREATE TABLE gc_user (
	user_id bigint NOT NULL,
	added_at timestamp NOT NULL,
	enabled bigint NOT NULL,
	gid char(8) NOT NULL
) ;
ALTER  TABLE gc_user OWNER TO scd_testuser;
ALTER TABLE gc_user ADD PRIMARY KEY (user_id);
ALTER TABLE gc_user ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE gc_user ALTER COLUMN ADDED_AT SET NOT NULL;
ALTER TABLE gc_user ALTER COLUMN ENABLED SET NOT NULL;
ALTER TABLE gc_user ALTER COLUMN GID SET NOT NULL;


CREATE TABLE genehmigungsgrund (
	id bigint,
	genehmigungsgrund varchar(150)
) ;
ALTER  TABLE genehmigungsgrund OWNER TO scd_testuser;


CREATE TABLE help (
	gid char(8)
) ;
ALTER  TABLE help OWNER TO scd_testuser;


CREATE TABLE hotline_partner (
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	mailadresse varchar(250),
	name varchar(50),
	vorname varchar(50),
	gid char(8),
	rolle varchar(250)
) ;
ALTER  TABLE hotline_partner OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixhotline_partner ON hotline_partner (vertragsnummer, geschaeftsjahr, rolle, mailadresse);
CREATE INDEX ixhotline_partnerv_nr ON hotline_partner (vertragsnummer);


CREATE TABLE hotline_partner_save (
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	mailadresse varchar(250),
	name varchar(50),
	vorname varchar(50),
	gid char(8),
	rolle varchar(250)
) ;
ALTER  TABLE hotline_partner_save OWNER TO scd_testuser;


CREATE TABLE inhalt (
	verteiler_nummer integer,
	laufende_nummer smallint,
	verteiler_art char(1),
	anzahl integer,
	herkunft varchar(255),
	beispiel varchar(255)
) ;
ALTER  TABLE inhalt OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixinhalt ON inhalt (verteiler_nummer, laufende_nummer);


CREATE TABLE konfiguration (
	eigenschaft varchar(250),
	wert varchar(250)
) ;
ALTER  TABLE konfiguration OWNER TO scd_testuser;


CREATE TABLE ldapdaten (
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	ip varchar(50),
	dns varchar(50)
) ;
ALTER  TABLE ldapdaten OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixldapdaten ON ldapdaten (vertragsnummer, geschaeftsjahr, ip);
CREATE INDEX ixldapdatenv_nr ON ldapdaten (vertragsnummer);


CREATE TABLE logindaten (
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	ip varchar(50),
	dns varchar(50)
) ;
ALTER  TABLE logindaten OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixlogindaten ON logindaten (vertragsnummer, geschaeftsjahr, ip, dns);
CREATE INDEX ixlogindatenv_nr ON logindaten (vertragsnummer);


CREATE TABLE md_additional_properties (
	id bigint NOT NULL,
	connection_id_fk bigint NOT NULL,
	ref_id_fk bigint NOT NULL,
	ref_type varchar(4000) NOT NULL,
	property_order bigint,
	prop_key varchar(4000) NOT NULL,
	value varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_additional_properties IS E'This table is used to store additional properties in key-value pairs.  It is designed to store "other information" that is not supported in the main database object table.';
COMMENT ON COLUMN md_additional_properties.connection_id_fk IS E'Connection to which this belongs //PARENTFIELD';
COMMENT ON COLUMN md_additional_properties.id IS E'Primary Key';
COMMENT ON COLUMN md_additional_properties.prop_key IS E'The keyname for this property';
COMMENT ON COLUMN md_additional_properties.property_order IS E'This is to handle a situation where multiple properties have a relevant order, or multiple properties have multiple values';
COMMENT ON COLUMN md_additional_properties.ref_id_fk IS E'The object to which this property blongs';
COMMENT ON COLUMN md_additional_properties.ref_type IS E'Type of object that this property belongs to';
COMMENT ON COLUMN md_additional_properties.value IS E'The value for this property';
ALTER  TABLE md_additional_properties OWNER TO scd_testuser;
ALTER TABLE md_additional_properties ADD PRIMARY KEY (id);
ALTER TABLE md_additional_properties ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_additional_properties ALTER COLUMN CONNECTION_ID_FK SET NOT NULL;
ALTER TABLE md_additional_properties ALTER COLUMN REF_ID_FK SET NOT NULL;
ALTER TABLE md_additional_properties ALTER COLUMN REF_TYPE SET NOT NULL;
ALTER TABLE md_additional_properties ALTER COLUMN PROP_KEY SET NOT NULL;
ALTER TABLE md_additional_properties ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_additional_properties ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_applicationfiles (
	id bigint NOT NULL,
	applications_id_fk bigint NOT NULL,
	name varchar(200) NOT NULL,
	uri varchar(4000) NOT NULL,
	type varchar(100) NOT NULL,
	state varchar(100) NOT NULL,
	language varchar(100),
	loc bigint,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(4000),
	updated_on timestamp,
	updated_by varchar(4000)
) ;
COMMENT ON TABLE md_applicationfiles IS E'Holds a tuple for each file that is being processed whether it is changed or not.';
COMMENT ON COLUMN md_applicationfiles.created_by IS E'APEX';
COMMENT ON COLUMN md_applicationfiles.created_on IS E'APEX';
COMMENT ON COLUMN md_applicationfiles.language IS E'Language of the file that has been processed.';
COMMENT ON COLUMN md_applicationfiles.name IS E'file name  //OBJECTNAME';
COMMENT ON COLUMN md_applicationfiles.security_group_id IS E'APEX';
COMMENT ON COLUMN md_applicationfiles.state IS E'State will be how this file is operated on.  For example. it will be OPEN, NEW, FIXED, IGNORED, REVIEWED, COMPLETE';
COMMENT ON COLUMN md_applicationfiles.type IS E'This will denote the type of file we have, including DIR, FILE (text), BINARY, IGNORE (where we choose to ignore files)';
COMMENT ON COLUMN md_applicationfiles.updated_by IS E'APEX';
COMMENT ON COLUMN md_applicationfiles.updated_on IS E'APEX';
COMMENT ON COLUMN md_applicationfiles.uri IS E'The uri is the part of the file url after the base dir has been removed.  See MD_APPLICATION for base dir';
ALTER  TABLE md_applicationfiles OWNER TO scd_testuser;
CREATE INDEX md_app_file_type_idx ON md_applicationfiles (type, id);
CREATE INDEX md_state_type__id ON md_applicationfiles (state, type, id);
ALTER TABLE md_applicationfiles ADD PRIMARY KEY (id);
ALTER TABLE md_applicationfiles ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_applicationfiles ALTER COLUMN APPLICATIONS_ID_FK SET NOT NULL;
ALTER TABLE md_applicationfiles ALTER COLUMN NAME SET NOT NULL;
ALTER TABLE md_applicationfiles ALTER COLUMN URI SET NOT NULL;
ALTER TABLE md_applicationfiles ALTER COLUMN TYPE SET NOT NULL;
ALTER TABLE md_applicationfiles ALTER COLUMN STATE SET NOT NULL;
ALTER TABLE md_applicationfiles ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_applicationfiles ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_applications (
	id bigint NOT NULL,
	name varchar(4000),
	description varchar(4000),
	base_dir varchar(4000),
	output_dir varchar(4000),
	backup_dir varchar(4000),
	inplace bigint,
	project_id_fk bigint NOT NULL,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_applications IS E'This is the base table for application projects.  It holds the base information for applications associated with a database';
COMMENT ON COLUMN md_applications.backup_dir IS E'This is the directory in which the application files are backed up if a backp is chosen';
COMMENT ON COLUMN md_applications.base_dir IS E'This is the base src directory for the application.  It could be an svn checkout, a clearcase view or something similar';
COMMENT ON COLUMN md_applications.description IS E'Overview of what the application does.';
COMMENT ON COLUMN md_applications.id IS E'Primary Key';
COMMENT ON COLUMN md_applications.inplace IS E'Designates whether the changes have been made inplace, in the source directory or not';
COMMENT ON COLUMN md_applications.name IS E'Name of the application suite  //OBJECTNAME';
COMMENT ON COLUMN md_applications.output_dir IS E'This is the output directory where the scanner will present the converted files, if there are converted or modified.';
COMMENT ON COLUMN md_applications.project_id_fk IS E'project of the database(s) this application relates to';
ALTER  TABLE md_applications OWNER TO scd_testuser;
ALTER TABLE md_applications ADD PRIMARY KEY (id);
ALTER TABLE md_applications ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_applications ALTER COLUMN PROJECT_ID_FK SET NOT NULL;
ALTER TABLE md_applications ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_applications ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_catalogs (
	id bigint NOT NULL,
	connection_id_fk bigint NOT NULL,
	catalog_name varchar(4000),
	dummy_flag char(1) DEFAULT 'N',
	native_sql text,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_catalogs IS E'Store catalogs in this table.';
COMMENT ON COLUMN md_catalogs.catalog_name IS E'Name of the catalog //OBJECTNAME';
COMMENT ON COLUMN md_catalogs.connection_id_fk IS E'Foreign key into the connections table - Shows what connection this catalog belongs to //PARENTFIELD';
COMMENT ON COLUMN md_catalogs.dummy_flag IS E'Flag to show if this catalog is a "dummy" catalog which is used as a placeholder for those platforms that do not support catalogs.  ''N'' signifies that this is NOT a dummy catalog, while ''Y'' signifies that it is.';
COMMENT ON COLUMN md_catalogs.native_key IS E'A unique identifier used to identify the catalog at source.';
COMMENT ON COLUMN md_catalogs.native_sql IS E'THe SQL used to create this catalog';
ALTER  TABLE md_catalogs OWNER TO scd_testuser;
ALTER TABLE md_catalogs ADD PRIMARY KEY (id);
ALTER TABLE md_catalogs ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_catalogs ALTER COLUMN CONNECTION_ID_FK SET NOT NULL;
ALTER TABLE md_catalogs ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_catalogs ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_code_regex (
	id bigint NOT NULL,
	regex varchar(100) NOT NULL,
	description varchar(200) NOT NULL
) ;
COMMENT ON COLUMN md_code_regex.id IS E'ID of regex for searching source code';
COMMENT ON COLUMN md_code_regex.regex IS E'Regex to use in reports of artifiacts in code.  This will be used for customers to analyze what is in their code.';
ALTER  TABLE md_code_regex OWNER TO scd_testuser;
ALTER TABLE md_code_regex ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_code_regex ALTER COLUMN REGEX SET NOT NULL;
ALTER TABLE md_code_regex ALTER COLUMN DESCRIPTION SET NOT NULL;


CREATE TABLE md_columns (
	id bigint NOT NULL,
	table_id_fk bigint NOT NULL,
	column_name varchar(4000) NOT NULL,
	column_order bigint NOT NULL,
	column_type varchar(4000),
	precision bigint,
	scale bigint,
	nullable char(1) NOT NULL,
	default_value varchar(4000),
	native_sql text,
	native_key varchar(4000),
	datatype_transformed_flag char(1),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_by varchar(255),
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	last_updated_by varchar(255),
	last_updated_on timestamp
) ;
COMMENT ON TABLE md_columns IS E'Column information is stored in this table.';
COMMENT ON COLUMN md_columns.column_name IS E'The name of the column //OBJECTNAME';
COMMENT ON COLUMN md_columns.column_order IS E'The order this appears in the table';
COMMENT ON COLUMN md_columns.column_type IS E'The type of the column';
COMMENT ON COLUMN md_columns.datatype_transformed_flag IS E'This is set to ''Y'' to show if the data type was transformed.  This is useful so we don''t apply more than 1 datatype transformation to a column';
COMMENT ON COLUMN md_columns.default_value IS E'Default value on the column';
COMMENT ON COLUMN md_columns.id IS E'Primary Key';
COMMENT ON COLUMN md_columns.native_key IS E'Unique identifier for this object at source';
COMMENT ON COLUMN md_columns.native_sql IS E'The SQL used to create this column at source';
COMMENT ON COLUMN md_columns.nullable IS E'Yes or No.  Null signifies NO';
COMMENT ON COLUMN md_columns.precision IS E'The precision on the column';
COMMENT ON COLUMN md_columns.scale IS E'The scale of the column';
COMMENT ON COLUMN md_columns.table_id_fk IS E'The table that this column is part of //PARENTFIELD';
ALTER  TABLE md_columns OWNER TO scd_testuser;
ALTER TABLE md_columns ADD PRIMARY KEY (id);
ALTER TABLE md_columns ADD CONSTRAINT md_columns_nullable_y_n CHECK ((UPPER(nullable) IN ('Y','N')));
ALTER TABLE md_columns ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_columns ALTER COLUMN TABLE_ID_FK SET NOT NULL;
ALTER TABLE md_columns ALTER COLUMN COLUMN_NAME SET NOT NULL;
ALTER TABLE md_columns ALTER COLUMN COLUMN_ORDER SET NOT NULL;
ALTER TABLE md_columns ALTER COLUMN NULLABLE SET NOT NULL;
ALTER TABLE md_columns ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_columns ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_connections (
	id bigint NOT NULL,
	project_id_fk bigint NOT NULL,
	type varchar(4000),
	host varchar(4000),
	port bigint,
	username varchar(4000),
	password varchar(4000),
	dburl varchar(4000),
	name varchar(255),
	native_sql text,
	status varchar(30),
	num_catalogs bigint,
	num_columns bigint,
	num_constraints bigint,
	num_groups bigint,
	num_roles bigint,
	num_indexes bigint,
	num_other_objects bigint,
	num_packages bigint,
	num_privileges bigint,
	num_schemas bigint,
	num_sequences bigint,
	num_stored_programs bigint,
	num_synonyms bigint,
	num_tables bigint,
	num_tablespaces bigint,
	num_triggers bigint,
	num_user_defined_data_types bigint,
	num_users bigint,
	num_views bigint,
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_connections IS E'This table is used to store connection information.  For example, in migrations, we could be carrying out a consolidation which occurs across many connections.';
COMMENT ON COLUMN md_connections.dburl IS E'The database url used to make this connection';
COMMENT ON COLUMN md_connections.host IS E'The host to which this connection connects.';
COMMENT ON COLUMN md_connections.id IS E'Primary key';
COMMENT ON COLUMN md_connections.name IS E'//OBJECTNAME';
COMMENT ON COLUMN md_connections.native_sql IS E'The native sql used to create this connection';
COMMENT ON COLUMN md_connections.password IS E'The password used to make this connection';
COMMENT ON COLUMN md_connections.port IS E'The port to which this connection connects';
COMMENT ON COLUMN md_connections.project_id_fk IS E'The project to which this connection belongs //PARENTFIELD';
COMMENT ON COLUMN md_connections.status IS E'Status of Migration, = captured,converted,generated,datamoved';
COMMENT ON COLUMN md_connections.type IS E'The type of the connection - For example it could be used to store "ORACLE" or "MYSQL"';
COMMENT ON COLUMN md_connections.username IS E'The username used to make the connection';
ALTER  TABLE md_connections OWNER TO scd_testuser;
ALTER TABLE md_connections ADD PRIMARY KEY (id);
ALTER TABLE md_connections ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_connections ALTER COLUMN PROJECT_ID_FK SET NOT NULL;
ALTER TABLE md_connections ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_connections ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_constraints (
	id bigint NOT NULL,
	delete_clause varchar(4000),
	name varchar(4000),
	constraint_type varchar(4000),
	table_id_fk bigint NOT NULL,
	reftable_id_fk bigint,
	constraint_text text,
	language varchar(40) NOT NULL,
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_constraints IS E'Table for storing information about a constraint';
COMMENT ON COLUMN md_constraints.constraint_text IS E'The text of the constraint';
COMMENT ON COLUMN md_constraints.constraint_type IS E'Type of the constraint (e.g. CHECK)';
COMMENT ON COLUMN md_constraints.delete_clause IS E'delete option , can be either CASCADE, RESTRICT or NULL';
COMMENT ON COLUMN md_constraints.id IS E'Primary Key';
COMMENT ON COLUMN md_constraints.language IS E'//PUBLIC';
COMMENT ON COLUMN md_constraints.name IS E'Name of the constraint //OBJECTNAME';
COMMENT ON COLUMN md_constraints.reftable_id_fk IS E'Used in foreign keys - this gives the table that we refer to.';
COMMENT ON COLUMN md_constraints.table_id_fk IS E'Table on which this constraint exists //PARENTFIELD';
ALTER  TABLE md_constraints OWNER TO scd_testuser;
ALTER TABLE md_constraints ADD PRIMARY KEY (id);
ALTER TABLE md_constraints ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_constraints ALTER COLUMN TABLE_ID_FK SET NOT NULL;
ALTER TABLE md_constraints ALTER COLUMN LANGUAGE SET NOT NULL;
ALTER TABLE md_constraints ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_constraints ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_constraint_details (
	id bigint NOT NULL,
	ref_flag char(1) DEFAULT 'N',
	constraint_id_fk bigint NOT NULL,
	column_id_fk bigint,
	column_portion bigint,
	constraint_text text,
	detail_order bigint NOT NULL,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_constraint_details IS E'Constraint details show what columns are "involved" in a constraint.';
COMMENT ON COLUMN md_constraint_details.column_portion IS E'The portion of a column this detail belongs (e.g. for constrints on substrings)';
COMMENT ON COLUMN md_constraint_details.constraint_id_fk IS E'Constraint that this detail belongs to //PARENTFIELD';
COMMENT ON COLUMN md_constraint_details.constraint_text IS E'The text of the constraint';
COMMENT ON COLUMN md_constraint_details.id IS E'Primary Key';
COMMENT ON COLUMN md_constraint_details.ref_flag IS E'"N" or Null signify that this column is the colum that is used in the constraint.  A flag of Y signifies that the colum is a referenced column (i.e. part of a foreign key constraint)';
ALTER  TABLE md_constraint_details OWNER TO scd_testuser;
ALTER TABLE md_constraint_details ADD PRIMARY KEY (id);
ALTER TABLE md_constraint_details ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_constraint_details ALTER COLUMN CONSTRAINT_ID_FK SET NOT NULL;
ALTER TABLE md_constraint_details ALTER COLUMN DETAIL_ORDER SET NOT NULL;
ALTER TABLE md_constraint_details ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_constraint_details ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_derivatives (
	id bigint NOT NULL,
	src_id bigint NOT NULL,
	src_type varchar(4000),
	derived_id bigint NOT NULL,
	derived_type varchar(4000),
	derived_connection_id_fk bigint NOT NULL,
	transformed char(1),
	original_identifier varchar(4000),
	new_identifier varchar(4000),
	derived_object_namespace varchar(40),
	derivative_reason varchar(10),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255),
	enabled char(1) DEFAULT 'Y'
) ;
COMMENT ON TABLE md_derivatives IS E'This table is used to store objects that are derived from each other.  For example in a migration an auto-increment column in a source model could be mapped to a primary key, and a sequence, and a trigger.  The MD_DERIVATIVES table would store the fact that these 3 objects are derived from the auto-increment column.';
COMMENT ON COLUMN md_derivatives.transformed IS E'Set this field to ''Y'' if we carry out any sort of transformation on teh derived object.';
ALTER  TABLE md_derivatives OWNER TO scd_testuser;
ALTER TABLE md_derivatives ADD PRIMARY KEY (id);
ALTER TABLE md_derivatives ADD CONSTRAINT migrder_chk CHECK (enabled = 'Y' OR enabled = 'y' OR enabled = 'N' OR  enabled = 'n');
ALTER TABLE md_derivatives ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_derivatives ALTER COLUMN SRC_ID SET NOT NULL;
ALTER TABLE md_derivatives ALTER COLUMN DERIVED_ID SET NOT NULL;
ALTER TABLE md_derivatives ALTER COLUMN DERIVED_CONNECTION_ID_FK SET NOT NULL;
ALTER TABLE md_derivatives ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_derivatives ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_file_artifacts (
	id bigint NOT NULL,
	applicationfiles_id bigint NOT NULL,
	pattern varchar(4000),
	string_found varchar(4000),
	string_replaced varchar(4000),
	type varchar(200),
	status varchar(4000),
	line bigint,
	pattern_start bigint,
	pattern_end bigint,
	due_date timestamp,
	db_type varchar(100),
	code_type varchar(1000),
	description varchar(4000),
	priority numeric(38),
	security_group_id varchar(20) NOT NULL DEFAULT '0',
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(4000),
	last_updated timestamp,
	last_updated_by varchar(4000)
) ;
COMMENT ON TABLE md_file_artifacts IS E'Holds a tuple for each interesting thing the scanner finds in a file';
COMMENT ON COLUMN md_file_artifacts.code_type IS E'Source code db api, like dblib, jdbc';
COMMENT ON COLUMN md_file_artifacts.db_type IS E'Source database calls type';
COMMENT ON COLUMN md_file_artifacts.description IS E'This is a description of the artifact which will have a default generated by the scanner and then can be modified by the user to be more appropriate for their use';
COMMENT ON COLUMN md_file_artifacts.due_date IS E'Due date is used by the TODO mechanism to manage the validation and work to complete this change';
COMMENT ON COLUMN md_file_artifacts.pattern IS E'Pattern used to search source file for interesting artifiacts';
COMMENT ON COLUMN md_file_artifacts.priority IS E'The priority is set for the TODOs so they can be managed by the user';
COMMENT ON COLUMN md_file_artifacts.status IS E'Pattern used to search source file for interesting artifiacts';
COMMENT ON COLUMN md_file_artifacts.string_found IS E'String found in source from the pattern supplied';
COMMENT ON COLUMN md_file_artifacts.string_replaced IS E'This is the string which replace the string found if it was replaced.';
COMMENT ON COLUMN md_file_artifacts.type IS E'This is the type of the replacement.  It could be a straight replace from a replacement pattern, or we could have passed the string to a translator which would change the string depending on the database.';
ALTER  TABLE md_file_artifacts OWNER TO scd_testuser;
ALTER TABLE md_file_artifacts ADD PRIMARY KEY (id);
ALTER TABLE md_file_artifacts ALTER COLUMN APPLICATIONFILES_ID SET NOT NULL;
ALTER TABLE md_file_artifacts ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_file_artifacts ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_file_artifacts ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_groups (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	group_name varchar(4000),
	group_flag char(1),
	native_sql text,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_groups IS E'Groups of users in a schema';
COMMENT ON COLUMN md_groups.group_flag IS E'This is a flag to signify a group or a role.  If this is ''R'' it means the group is known as a Role.  Any other value means it is known as a group.';
COMMENT ON COLUMN md_groups.group_name IS E'Name of the group //OBJECTNAME';
COMMENT ON COLUMN md_groups.id IS E'Primary Key';
COMMENT ON COLUMN md_groups.native_key IS E'Unique id for this object at source';
COMMENT ON COLUMN md_groups.native_sql IS E'SQL Used to generate this object at source';
COMMENT ON COLUMN md_groups.schema_id_fk IS E'Schema in which this object belongs //PARENTFIELD';
ALTER  TABLE md_groups OWNER TO scd_testuser;
ALTER TABLE md_groups ADD PRIMARY KEY (id);
ALTER TABLE md_groups ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_groups ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_groups ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_groups ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_group_members (
	id bigint NOT NULL,
	group_id_fk bigint NOT NULL,
	user_id_fk bigint,
	group_member_id_fk bigint,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_group_members IS E'This table is used to store the members of a group.';
COMMENT ON COLUMN md_group_members.group_member_id_fk IS E'groups can be members of groups';
COMMENT ON COLUMN md_group_members.id IS E'Primary Key';
COMMENT ON COLUMN md_group_members.user_id_fk IS E'Id of member';
ALTER  TABLE md_group_members OWNER TO scd_testuser;
ALTER TABLE md_group_members ADD PRIMARY KEY (id);
ALTER TABLE md_group_members ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_group_members ALTER COLUMN GROUP_ID_FK SET NOT NULL;
ALTER TABLE md_group_members ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_group_members ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_group_privileges (
	id bigint NOT NULL,
	group_id_fk bigint NOT NULL,
	privilege_id_fk bigint NOT NULL,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_group_privileges IS E'This table stores the privileges granted to a group (or role)';
ALTER  TABLE md_group_privileges OWNER TO scd_testuser;
ALTER TABLE md_group_privileges ADD PRIMARY KEY (id);
ALTER TABLE md_group_privileges ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_group_privileges ALTER COLUMN GROUP_ID_FK SET NOT NULL;
ALTER TABLE md_group_privileges ALTER COLUMN PRIVILEGE_ID_FK SET NOT NULL;
ALTER TABLE md_group_privileges ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_group_privileges ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_indexes (
	id bigint NOT NULL,
	index_type varchar(4000),
	table_id_fk bigint NOT NULL,
	index_name varchar(4000),
	native_sql text,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(4000)
) ;
COMMENT ON TABLE md_indexes IS E'This table is used to store information about the indexes in a schema';
COMMENT ON COLUMN md_indexes.id IS E'Primary Key';
COMMENT ON COLUMN md_indexes.index_name IS E'Name of the index //OBJECTNAME';
COMMENT ON COLUMN md_indexes.index_type IS E'Type of the index e.g. PRIMARY';
COMMENT ON COLUMN md_indexes.native_key IS E'A unique identifier for this object at the source';
COMMENT ON COLUMN md_indexes.native_sql IS E'SQL used to create the index at source';
COMMENT ON COLUMN md_indexes.table_id_fk IS E'Table that this index is on //PARENTFIELD';
ALTER  TABLE md_indexes OWNER TO scd_testuser;
ALTER TABLE md_indexes ADD PRIMARY KEY (id);
ALTER TABLE md_indexes ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_indexes ALTER COLUMN TABLE_ID_FK SET NOT NULL;
ALTER TABLE md_indexes ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_indexes ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_index_details (
	id bigint NOT NULL,
	index_id_fk bigint NOT NULL,
	column_id_fk bigint NOT NULL,
	index_portion bigint,
	detail_order bigint NOT NULL,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_index_details IS E'This table stores the details of an index.  It shows what columns are "part" of the index.';
COMMENT ON COLUMN md_index_details.index_id_fk IS E'The index to which this detail belongs. //PARENTFIELD';
COMMENT ON COLUMN md_index_details.index_portion IS E'To support indexing on part of a field';
ALTER  TABLE md_index_details OWNER TO scd_testuser;
ALTER TABLE md_index_details ADD PRIMARY KEY (id);
ALTER TABLE md_index_details ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_index_details ALTER COLUMN INDEX_ID_FK SET NOT NULL;
ALTER TABLE md_index_details ALTER COLUMN COLUMN_ID_FK SET NOT NULL;
ALTER TABLE md_index_details ALTER COLUMN DETAIL_ORDER SET NOT NULL;
ALTER TABLE md_index_details ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_index_details ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_migr_dependency (
	id bigint NOT NULL,
	connection_id_fk bigint NOT NULL,
	parent_id bigint NOT NULL,
	child_id bigint NOT NULL,
	parent_object_type varchar(4000) NOT NULL,
	child_object_type varchar(4000) NOT NULL,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON COLUMN md_migr_dependency.connection_id_fk IS E'The connection that this exists in //PARENTFIELD';
ALTER  TABLE md_migr_dependency OWNER TO scd_testuser;
ALTER TABLE md_migr_dependency ADD PRIMARY KEY (id);
ALTER TABLE md_migr_dependency ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_migr_dependency ALTER COLUMN CONNECTION_ID_FK SET NOT NULL;
ALTER TABLE md_migr_dependency ALTER COLUMN PARENT_ID SET NOT NULL;
ALTER TABLE md_migr_dependency ALTER COLUMN CHILD_ID SET NOT NULL;
ALTER TABLE md_migr_dependency ALTER COLUMN PARENT_OBJECT_TYPE SET NOT NULL;
ALTER TABLE md_migr_dependency ALTER COLUMN CHILD_OBJECT_TYPE SET NOT NULL;
ALTER TABLE md_migr_dependency ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_migr_dependency ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_migr_parameter (
	id bigint NOT NULL,
	connection_id_fk bigint NOT NULL,
	object_id bigint NOT NULL,
	object_type varchar(4000) NOT NULL,
	param_existing bigint NOT NULL,
	param_order bigint NOT NULL,
	param_name varchar(4000) NOT NULL,
	param_type varchar(4000) NOT NULL,
	param_data_type varchar(4000) NOT NULL,
	percision bigint,
	scale bigint,
	nullable char(1) NOT NULL,
	default_value varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON COLUMN md_migr_parameter.connection_id_fk IS E'the connection in which this belongs //PARENTFIELD';
COMMENT ON COLUMN md_migr_parameter.param_existing IS E'1 represents a new parameter for PL/SQL that was not present in the origional. 0 represents a n existing parameter that was present in the origional';
COMMENT ON COLUMN md_migr_parameter.param_order IS E'IF -1 THEN THIS PARAM IS A RETURN PARAMETER. 1 WILL BE THE FIRST PARAMETER IN THE PARAMETER LIST';
ALTER  TABLE md_migr_parameter OWNER TO scd_testuser;
ALTER TABLE md_migr_parameter ADD PRIMARY KEY (id);
ALTER TABLE md_migr_parameter ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN CONNECTION_ID_FK SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN OBJECT_ID SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN OBJECT_TYPE SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN PARAM_EXISTING SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN PARAM_ORDER SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN PARAM_NAME SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN PARAM_TYPE SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN PARAM_DATA_TYPE SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN NULLABLE SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_migr_parameter ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_migr_weakdep (
	id bigint NOT NULL,
	connection_id_fk bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	parent_id bigint NOT NULL,
	child_name varchar(4000) NOT NULL,
	parent_type varchar(4000) NOT NULL,
	child_type varchar(4000) NOT NULL,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON COLUMN md_migr_weakdep.child_name IS E'name of the child,  as weak dependencies dont have reference to child id';
COMMENT ON COLUMN md_migr_weakdep.child_type IS E'Generic Type (not MD_<tablename>)';
COMMENT ON COLUMN md_migr_weakdep.parent_type IS E'MD_<tablename>';
ALTER  TABLE md_migr_weakdep OWNER TO scd_testuser;
ALTER TABLE md_migr_weakdep ADD PRIMARY KEY (id);
ALTER TABLE md_migr_weakdep ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_migr_weakdep ALTER COLUMN CONNECTION_ID_FK SET NOT NULL;
ALTER TABLE md_migr_weakdep ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_migr_weakdep ALTER COLUMN PARENT_ID SET NOT NULL;
ALTER TABLE md_migr_weakdep ALTER COLUMN CHILD_NAME SET NOT NULL;
ALTER TABLE md_migr_weakdep ALTER COLUMN PARENT_TYPE SET NOT NULL;
ALTER TABLE md_migr_weakdep ALTER COLUMN CHILD_TYPE SET NOT NULL;
ALTER TABLE md_migr_weakdep ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_migr_weakdep ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE "md_numrow$source" (
	numrows bigint,
	name varchar(4000),
	objid bigint
) ;


CREATE TABLE "md_numrow$target" (
	numrows bigint,
	name varchar(4000),
	objid bigint
) ;


CREATE TABLE md_other_objects (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	name varchar(4000),
	native_sql text,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_other_objects IS E'For storing objects that don''''t belong anywhere else';
COMMENT ON COLUMN md_other_objects.id IS E'Primary Key';
COMMENT ON COLUMN md_other_objects.name IS E'Name of this object //OBJECTNAME';
COMMENT ON COLUMN md_other_objects.native_key IS E'A key that identifies this object at source.';
COMMENT ON COLUMN md_other_objects.native_sql IS E'The native SQL used to create this object';
COMMENT ON COLUMN md_other_objects.schema_id_fk IS E'Schema to which this object blongs. //PARENTFIELD';
ALTER  TABLE md_other_objects OWNER TO scd_testuser;
ALTER TABLE md_other_objects ADD PRIMARY KEY (id);
ALTER TABLE md_other_objects ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_other_objects ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_other_objects ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_other_objects ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_packages (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	name varchar(4000) NOT NULL,
	package_header text,
	native_sql text,
	native_key varchar(4000),
	language varchar(40) NOT NULL,
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_packages IS E'For storing packages';
COMMENT ON COLUMN md_packages.id IS E'Primary Key';
COMMENT ON COLUMN md_packages.language IS E'//PUBLIC';
COMMENT ON COLUMN md_packages.name IS E'Name of this package //OBJECTNAME';
COMMENT ON COLUMN md_packages.native_key IS E'A unique identifer for this object at source.';
COMMENT ON COLUMN md_packages.native_sql IS E'The SQL used to create this package at source';
COMMENT ON COLUMN md_packages.schema_id_fk IS E'the schema in which this package resides //PARENTFIELD';
ALTER  TABLE md_packages OWNER TO scd_testuser;
ALTER TABLE md_packages ADD PRIMARY KEY (id);
ALTER TABLE md_packages ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_packages ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_packages ALTER COLUMN NAME SET NOT NULL;
ALTER TABLE md_packages ALTER COLUMN LANGUAGE SET NOT NULL;
ALTER TABLE md_packages ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_packages ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_partitions (
	id bigint NOT NULL,
	table_id_fk bigint NOT NULL,
	native_sql text,
	partition_expression varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_by varchar(255),
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	last_updated_by varchar(255),
	last_updated_on timestamp
) ;
COMMENT ON TABLE md_partitions IS E'Partition information is stored in this table.';
COMMENT ON COLUMN md_partitions.id IS E'Primary Key';
COMMENT ON COLUMN md_partitions.native_sql IS E'The SQL used to create this partition at source';
COMMENT ON COLUMN md_partitions.partition_expression IS E'The partition expression';
COMMENT ON COLUMN md_partitions.table_id_fk IS E'The table that this partition refers to //PARENTFIELD';
ALTER  TABLE md_partitions OWNER TO scd_testuser;
ALTER TABLE md_partitions ADD PRIMARY KEY (id);
ALTER TABLE md_partitions ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_partitions ALTER COLUMN TABLE_ID_FK SET NOT NULL;
ALTER TABLE md_partitions ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_partitions ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_privileges (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	privilege_name varchar(4000) NOT NULL,
	privelege_object_id bigint,
	privelegeobjecttype varchar(4000) NOT NULL,
	privelege_type varchar(4000) NOT NULL,
	admin_option char(1),
	native_sql text NOT NULL,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_privileges IS E'This table stores privilege information';
COMMENT ON COLUMN md_privileges.admin_option IS E'Flag to show if this was granted with admin option.  ''Y'' means it was granted with admin option ''N'' means it was NOT granted with admin option.  NULL means not applicable (e.g. not known, not supported by source platform, etc.)';
COMMENT ON COLUMN md_privileges.id IS E'Primary Key';
COMMENT ON COLUMN md_privileges.native_key IS E'An identifier for this object at source.';
COMMENT ON COLUMN md_privileges.native_sql IS E'The SQL used to create this privilege at source';
COMMENT ON COLUMN md_privileges.privelege_object_id IS E'This references the table, view, etc on which the privelege exists.  This can be NULL for things like system wide privileges';
COMMENT ON COLUMN md_privileges.privelege_type IS E'e.g.select';
COMMENT ON COLUMN md_privileges.privelegeobjecttype IS E'The type the privelege is on (e.g. INDEX)';
COMMENT ON COLUMN md_privileges.privilege_name IS E'The name of the privilege //OBJECTNAME';
COMMENT ON COLUMN md_privileges.schema_id_fk IS E'The schema to which this object belongs //PARENTFIELD';
ALTER  TABLE md_privileges OWNER TO scd_testuser;
ALTER TABLE md_privileges ADD PRIMARY KEY (id);
ALTER TABLE md_privileges ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_privileges ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_privileges ALTER COLUMN PRIVILEGE_NAME SET NOT NULL;
ALTER TABLE md_privileges ALTER COLUMN PRIVELEGEOBJECTTYPE SET NOT NULL;
ALTER TABLE md_privileges ALTER COLUMN PRIVELEGE_TYPE SET NOT NULL;
ALTER TABLE md_privileges ALTER COLUMN NATIVE_SQL SET NOT NULL;
ALTER TABLE md_privileges ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_privileges ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_projects (
	id bigint NOT NULL,
	project_name varchar(4000) NOT NULL,
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_projects IS E'This is a top level container for a set of connections.';
COMMENT ON COLUMN md_projects.id IS E'Primary key';
COMMENT ON COLUMN md_projects.project_name IS E'Name of the project //OBJECTNAME';
ALTER  TABLE md_projects OWNER TO scd_testuser;
ALTER TABLE md_projects ADD PRIMARY KEY (id);
ALTER TABLE md_projects ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_projects ALTER COLUMN PROJECT_NAME SET NOT NULL;
ALTER TABLE md_projects ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_projects ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_registry (
	object_type varchar(30) NOT NULL,
	object_name varchar(30) NOT NULL,
	desc_object_name varchar(30)
) ;
COMMENT ON TABLE md_registry IS E'Table to store information on the MD_ repository.  This lists the objects to be dropped if you wish to remove the repository';
ALTER  TABLE md_registry OWNER TO scd_testuser;
ALTER TABLE md_registry ADD PRIMARY KEY (object_type,object_name);
ALTER TABLE md_registry ALTER COLUMN OBJECT_TYPE SET NOT NULL;
ALTER TABLE md_registry ALTER COLUMN OBJECT_NAME SET NOT NULL;


CREATE TABLE md_repoversions (
	revision bigint NOT NULL
) ;
COMMENT ON TABLE md_repoversions IS E'This table is used to version this schema for future requirements.';
ALTER  TABLE md_repoversions OWNER TO scd_testuser;
ALTER TABLE md_repoversions ALTER COLUMN REVISION SET NOT NULL;


CREATE TABLE md_schemas (
	id bigint NOT NULL,
	catalog_id_fk bigint NOT NULL,
	name varchar(4000),
	type char(1),
	character_set varchar(4000),
	version_tag varchar(40),
	native_sql text,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_schemas IS E'This is the holder for schemas';
COMMENT ON COLUMN md_schemas.catalog_id_fk IS E'Catalog to which this schema blongs //PARENTFIELD';
COMMENT ON COLUMN md_schemas.character_set IS E'The characterset of this schema';
COMMENT ON COLUMN md_schemas.id IS E'Primary Key';
COMMENT ON COLUMN md_schemas.name IS E'Name of the schema //OBJECTNAME';
COMMENT ON COLUMN md_schemas.native_key IS E'A unique identifier that this schema is known as in its source state.';
COMMENT ON COLUMN md_schemas.native_sql IS E'The native SQL used to create this schema';
COMMENT ON COLUMN md_schemas.type IS E'Type of this schema.  Eaxamples are ''CAPTURED'' OR ''CONVERTED''';
COMMENT ON COLUMN md_schemas.version_tag IS E'A version string that can be used for tagging/baseling a schema';
ALTER  TABLE md_schemas OWNER TO scd_testuser;
ALTER TABLE md_schemas ADD PRIMARY KEY (id);
ALTER TABLE md_schemas ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_schemas ALTER COLUMN CATALOG_ID_FK SET NOT NULL;
ALTER TABLE md_schemas ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_schemas ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_sequences (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	name varchar(4000) NOT NULL,
	seq_start bigint NOT NULL,
	incr bigint NOT NULL DEFAULT 1,
	native_sql text,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255) NOT NULL DEFAULT '0',
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_sequences IS E'For storing information on sequences.';
COMMENT ON COLUMN md_sequences.id IS E'Primary Key';
COMMENT ON COLUMN md_sequences.incr IS E'Increment value of the sequence';
COMMENT ON COLUMN md_sequences.name IS E'Name of this sequence //OBJECTNAME';
COMMENT ON COLUMN md_sequences.native_key IS E'Identifier for this object at source.';
COMMENT ON COLUMN md_sequences.native_sql IS E'SQL used to create this object at source';
COMMENT ON COLUMN md_sequences.schema_id_fk IS E'The schema to which this object belongs. //PARENTFIELD';
COMMENT ON COLUMN md_sequences.seq_start IS E'Starting point of the sequence';
ALTER  TABLE md_sequences OWNER TO scd_testuser;
ALTER TABLE md_sequences ADD PRIMARY KEY (id);
ALTER TABLE md_sequences ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_sequences ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_sequences ALTER COLUMN NAME SET NOT NULL;
ALTER TABLE md_sequences ALTER COLUMN SEQ_START SET NOT NULL;
ALTER TABLE md_sequences ALTER COLUMN INCR SET NOT NULL;
ALTER TABLE md_sequences ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_sequences ALTER COLUMN CREATED_ON SET NOT NULL;
ALTER TABLE md_sequences ALTER COLUMN CREATED_BY SET NOT NULL;


CREATE TABLE md_stored_programs (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	programtype varchar(20),
	name varchar(4000),
	package_id_fk bigint,
	native_sql text,
	native_key varchar(4000),
	language varchar(40) NOT NULL,
	comments varchar(4000),
	linecount bigint,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_stored_programs IS E'Container for stored programs.';
COMMENT ON COLUMN md_stored_programs.id IS E'Primary Key';
COMMENT ON COLUMN md_stored_programs.language IS E'//PUBLIC';
COMMENT ON COLUMN md_stored_programs.name IS E'Name of the stored program //OBJECTNAME';
COMMENT ON COLUMN md_stored_programs.native_key IS E'A unique indetifier for this object at source';
COMMENT ON COLUMN md_stored_programs.native_sql IS E'The SQL used to create this object at source';
COMMENT ON COLUMN md_stored_programs.package_id_fk IS E'The package to which this object belongs';
COMMENT ON COLUMN md_stored_programs.programtype IS E'Java/TSQL/PLSQL, etc.';
COMMENT ON COLUMN md_stored_programs.schema_id_fk IS E'Schema to which this object belongs.  Note that the PACKAGE_ID_FK (if present also leads us to the relevant schema), however a stored program may or may not belong in a package.  If it is in a package, then the SCHEMA_ID_FK and the SCHEME_ID_FK in the parent package should match //PARENTFIELD';
ALTER  TABLE md_stored_programs OWNER TO scd_testuser;
ALTER TABLE md_stored_programs ADD PRIMARY KEY (id);
ALTER TABLE md_stored_programs ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_stored_programs ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_stored_programs ALTER COLUMN LANGUAGE SET NOT NULL;
ALTER TABLE md_stored_programs ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_stored_programs ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_synonyms (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	name varchar(4000) NOT NULL,
	synonym_for_id bigint NOT NULL,
	for_object_type varchar(4000) NOT NULL,
	private_visibility char(1),
	native_sql text,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_synonyms IS E'For storing synonym information.';
COMMENT ON COLUMN md_synonyms.for_object_type IS E'The type this is a synonym for (e.g. INDEX)';
COMMENT ON COLUMN md_synonyms.id IS E'Primary Key';
COMMENT ON COLUMN md_synonyms.name IS E'Synonym name //OBJECTNAME';
COMMENT ON COLUMN md_synonyms.native_key IS E'An identifier for this object at source.';
COMMENT ON COLUMN md_synonyms.native_sql IS E'The SQL used to create this object at source';
COMMENT ON COLUMN md_synonyms.private_visibility IS E'Visibility - Private or Public.  If Private_visibility = ''Y'' means this is a private synonym.  Anything else means it is a public synonym';
COMMENT ON COLUMN md_synonyms.schema_id_fk IS E'The schema to which this object belongs //PARENTFIELD';
COMMENT ON COLUMN md_synonyms.synonym_for_id IS E'What object this is a synonym for';
ALTER  TABLE md_synonyms OWNER TO scd_testuser;
ALTER TABLE md_synonyms ADD PRIMARY KEY (id);
ALTER TABLE md_synonyms ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_synonyms ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_synonyms ALTER COLUMN NAME SET NOT NULL;
ALTER TABLE md_synonyms ALTER COLUMN SYNONYM_FOR_ID SET NOT NULL;
ALTER TABLE md_synonyms ALTER COLUMN FOR_OBJECT_TYPE SET NOT NULL;
ALTER TABLE md_synonyms ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_synonyms ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_tables (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	table_name varchar(4000) NOT NULL,
	native_sql text,
	native_key varchar(4000),
	qualified_native_name varchar(4000) NOT NULL,
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_tables IS E'Table used to store information about tables.';
COMMENT ON COLUMN md_tables.id IS E'Primary Key';
COMMENT ON COLUMN md_tables.native_key IS E'Unique identifier for this table at source';
COMMENT ON COLUMN md_tables.native_sql IS E'SQL Used to create this table at soruce';
COMMENT ON COLUMN md_tables.schema_id_fk IS E'Schema in which this table resides //PARENTFIELD';
COMMENT ON COLUMN md_tables.table_name IS E'Name of the table //OBJECTNAME';
ALTER  TABLE md_tables OWNER TO scd_testuser;
ALTER TABLE md_tables ADD PRIMARY KEY (id);
ALTER TABLE md_tables ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_tables ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_tables ALTER COLUMN TABLE_NAME SET NOT NULL;
ALTER TABLE md_tables ALTER COLUMN QUALIFIED_NATIVE_NAME SET NOT NULL;
ALTER TABLE md_tables ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_tables ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_tablespaces (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	tablespace_name varchar(4000),
	native_sql text,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_tablespaces IS E'For storing information about tablespaces.';
COMMENT ON COLUMN md_tablespaces.id IS E'Primary Key';
COMMENT ON COLUMN md_tablespaces.native_key IS E'A unique identifier for this object at source';
COMMENT ON COLUMN md_tablespaces.native_sql IS E'The SQL used to create this tablespace';
COMMENT ON COLUMN md_tablespaces.schema_id_fk IS E'Schema to which this tablespace belongs //PARENTFIELD';
COMMENT ON COLUMN md_tablespaces.tablespace_name IS E'Name of the table space //OBJECTNAME';
ALTER  TABLE md_tablespaces OWNER TO scd_testuser;
ALTER TABLE md_tablespaces ADD PRIMARY KEY (id);
ALTER TABLE md_tablespaces ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_tablespaces ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_tablespaces ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_tablespaces ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_triggers (
	id bigint NOT NULL,
	table_or_view_id_fk bigint NOT NULL,
	trigger_on_flag char(1) NOT NULL,
	trigger_name varchar(4000),
	trigger_timing varchar(4000),
	trigger_operation varchar(4000),
	trigger_event varchar(4000),
	native_sql text,
	native_key varchar(4000),
	language varchar(40) NOT NULL,
	comments varchar(4000),
	linecount bigint,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_triggers IS E'For storing information about triggers.';
COMMENT ON COLUMN md_triggers.id IS E'Primary Key';
COMMENT ON COLUMN md_triggers.language IS E'//PUBLIC';
COMMENT ON COLUMN md_triggers.native_key IS E'UInique identifer for this object at source';
COMMENT ON COLUMN md_triggers.native_sql IS E'The full definition ';
COMMENT ON COLUMN md_triggers.table_or_view_id_fk IS E'Table on which this trigger fires';
COMMENT ON COLUMN md_triggers.trigger_event IS E'The actual trigger that gets fired ';
COMMENT ON COLUMN md_triggers.trigger_name IS E'Name of the trigger //OBJECTNAME';
COMMENT ON COLUMN md_triggers.trigger_on_flag IS E'Flag to show iif the trigger is on a table or a view.  If it is a table this should be ''T''. If it is on a view this should be ''V''';
COMMENT ON COLUMN md_triggers.trigger_operation IS E'insert, delete, etc.';
COMMENT ON COLUMN md_triggers.trigger_timing IS E'before, after ,etc.';
ALTER  TABLE md_triggers OWNER TO scd_testuser;
ALTER TABLE md_triggers ADD PRIMARY KEY (id);
ALTER TABLE md_triggers ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_triggers ALTER COLUMN TABLE_OR_VIEW_ID_FK SET NOT NULL;
ALTER TABLE md_triggers ALTER COLUMN TRIGGER_ON_FLAG SET NOT NULL;
ALTER TABLE md_triggers ALTER COLUMN LANGUAGE SET NOT NULL;
ALTER TABLE md_triggers ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_triggers ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_users (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	username varchar(4000) NOT NULL,
	password varchar(4000),
	native_sql text,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_users IS E'User information.';
COMMENT ON COLUMN md_users.id IS E'Primary Key';
COMMENT ON COLUMN md_users.native_key IS E'Unique identifier for this object at source.';
COMMENT ON COLUMN md_users.native_sql IS E'SQL Used to create this object at source';
COMMENT ON COLUMN md_users.password IS E'Password for login';
COMMENT ON COLUMN md_users.schema_id_fk IS E'Shema in which this object belongs //PARENTFIELD';
COMMENT ON COLUMN md_users.username IS E'Username for login //OBJECTNAME';
ALTER  TABLE md_users OWNER TO scd_testuser;
ALTER TABLE md_users ADD PRIMARY KEY (id);
ALTER TABLE md_users ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_users ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_users ALTER COLUMN USERNAME SET NOT NULL;
ALTER TABLE md_users ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_users ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_user_defined_data_types (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	data_type_name varchar(4000) NOT NULL,
	definition varchar(4000) NOT NULL,
	native_sql text NOT NULL,
	native_key varchar(4000),
	comments varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_user_defined_data_types IS E'For storing information on user defined data types.';
COMMENT ON COLUMN md_user_defined_data_types.data_type_name IS E'The name of the data type //OBJECTNAME';
COMMENT ON COLUMN md_user_defined_data_types.definition IS E'The definition of the data type';
COMMENT ON COLUMN md_user_defined_data_types.id IS E'Primary Key';
COMMENT ON COLUMN md_user_defined_data_types.native_key IS E'An unique identifier for this object at source.';
COMMENT ON COLUMN md_user_defined_data_types.native_sql IS E'The native SQL used to create this object';
COMMENT ON COLUMN md_user_defined_data_types.schema_id_fk IS E'Schema to which this object blongs. //PARENTFIELD';
ALTER  TABLE md_user_defined_data_types OWNER TO scd_testuser;
ALTER TABLE md_user_defined_data_types ADD PRIMARY KEY (id);
ALTER TABLE md_user_defined_data_types ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_user_defined_data_types ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_user_defined_data_types ALTER COLUMN DATA_TYPE_NAME SET NOT NULL;
ALTER TABLE md_user_defined_data_types ALTER COLUMN DEFINITION SET NOT NULL;
ALTER TABLE md_user_defined_data_types ALTER COLUMN NATIVE_SQL SET NOT NULL;
ALTER TABLE md_user_defined_data_types ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_user_defined_data_types ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_user_privileges (
	id bigint NOT NULL,
	user_id_fk bigint NOT NULL,
	privilege_id_fk bigint,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_udpated_by varchar(255)
) ;
COMMENT ON TABLE md_user_privileges IS E'This table stores privileges granted to individual users';
COMMENT ON COLUMN md_user_privileges.id IS E'Primary Key';
COMMENT ON COLUMN md_user_privileges.privilege_id_fk IS E'Privilege';
COMMENT ON COLUMN md_user_privileges.user_id_fk IS E'User';
ALTER  TABLE md_user_privileges OWNER TO scd_testuser;
ALTER TABLE md_user_privileges ADD PRIMARY KEY (id);
ALTER TABLE md_user_privileges ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_user_privileges ALTER COLUMN USER_ID_FK SET NOT NULL;
ALTER TABLE md_user_privileges ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_user_privileges ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE md_views (
	id bigint NOT NULL,
	schema_id_fk bigint NOT NULL,
	view_name varchar(4000),
	native_sql text,
	native_key varchar(4000),
	language varchar(40) NOT NULL,
	comments varchar(4000),
	linecount bigint,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE md_views IS E'For storing information on views.';
COMMENT ON COLUMN md_views.id IS E'Primary Key';
COMMENT ON COLUMN md_views.language IS E'//PUBLIC';
COMMENT ON COLUMN md_views.native_key IS E'An identifier for this object at source.';
COMMENT ON COLUMN md_views.native_sql IS E'The SQL used to create this object at source';
COMMENT ON COLUMN md_views.schema_id_fk IS E'The schema to which this obect blongs. //PARENTFIELD';
COMMENT ON COLUMN md_views.view_name IS E'The name of the view //OBJECTNAME';
ALTER  TABLE md_views OWNER TO scd_testuser;
ALTER TABLE md_views ADD PRIMARY KEY (id);
ALTER TABLE md_views ALTER COLUMN ID SET NOT NULL;
ALTER TABLE md_views ALTER COLUMN SCHEMA_ID_FK SET NOT NULL;
ALTER TABLE md_views ALTER COLUMN LANGUAGE SET NOT NULL;
ALTER TABLE md_views ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE md_views ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE migrlog (
	id bigint NOT NULL,
	parent_log_id bigint,
	log_date timestamp NOT NULL,
	severity smallint NOT NULL,
	logtext varchar(4000),
	phase varchar(100),
	ref_object_id bigint,
	ref_object_type varchar(4000),
	connection_id_fk bigint
) ;
ALTER  TABLE migrlog OWNER TO scd_testuser;
ALTER TABLE migrlog ADD PRIMARY KEY (id);
ALTER TABLE migrlog ALTER COLUMN ID SET NOT NULL;
ALTER TABLE migrlog ALTER COLUMN LOG_DATE SET NOT NULL;
ALTER TABLE migrlog ALTER COLUMN SEVERITY SET NOT NULL;


CREATE TABLE migr_datatype_transform_map (
	id bigint NOT NULL,
	project_id_fk bigint NOT NULL,
	map_name varchar(4000),
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON TABLE migr_datatype_transform_map IS E'Table for storing data type maps.  A map is simply a collection of rules';
COMMENT ON COLUMN migr_datatype_transform_map.id IS E'Primary Key';
COMMENT ON COLUMN migr_datatype_transform_map.map_name IS E'A name for the map';
COMMENT ON COLUMN migr_datatype_transform_map.project_id_fk IS E'//PARENTFIELD';
ALTER  TABLE migr_datatype_transform_map OWNER TO scd_testuser;
ALTER TABLE migr_datatype_transform_map ADD PRIMARY KEY (id);
ALTER TABLE migr_datatype_transform_map ALTER COLUMN ID SET NOT NULL;
ALTER TABLE migr_datatype_transform_map ALTER COLUMN PROJECT_ID_FK SET NOT NULL;
ALTER TABLE migr_datatype_transform_map ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE migr_datatype_transform_map ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE migr_datatype_transform_rule (
	id bigint NOT NULL,
	map_id_fk bigint NOT NULL,
	source_data_type_name varchar(4000) NOT NULL,
	source_precision bigint,
	source_scale bigint,
	target_data_type_name varchar(4000) NOT NULL,
	target_precision bigint,
	target_scale bigint,
	security_group_id bigint NOT NULL DEFAULT 0,
	created_on timestamp NOT NULL DEFAULT statement_timestamp(),
	created_by varchar(255),
	last_updated_on timestamp,
	last_updated_by varchar(255)
) ;
COMMENT ON COLUMN migr_datatype_transform_rule.id IS E'Primary Key';
COMMENT ON COLUMN migr_datatype_transform_rule.map_id_fk IS E'The map to which this rule belongs //PARENTFIELD';
COMMENT ON COLUMN migr_datatype_transform_rule.source_data_type_name IS E'Source data type';
COMMENT ON COLUMN migr_datatype_transform_rule.source_precision IS E'Precison to match';
COMMENT ON COLUMN migr_datatype_transform_rule.source_scale IS E'scale to match';
COMMENT ON COLUMN migr_datatype_transform_rule.target_data_type_name IS E'data type name to transform to';
COMMENT ON COLUMN migr_datatype_transform_rule.target_precision IS E'precision to map to ';
COMMENT ON COLUMN migr_datatype_transform_rule.target_scale IS E'scale to map to';
ALTER  TABLE migr_datatype_transform_rule OWNER TO scd_testuser;
ALTER TABLE migr_datatype_transform_rule ADD PRIMARY KEY (id);
ALTER TABLE migr_datatype_transform_rule ALTER COLUMN ID SET NOT NULL;
ALTER TABLE migr_datatype_transform_rule ALTER COLUMN MAP_ID_FK SET NOT NULL;
ALTER TABLE migr_datatype_transform_rule ALTER COLUMN SOURCE_DATA_TYPE_NAME SET NOT NULL;
ALTER TABLE migr_datatype_transform_rule ALTER COLUMN TARGET_DATA_TYPE_NAME SET NOT NULL;
ALTER TABLE migr_datatype_transform_rule ALTER COLUMN SECURITY_GROUP_ID SET NOT NULL;
ALTER TABLE migr_datatype_transform_rule ALTER COLUMN CREATED_ON SET NOT NULL;


CREATE TABLE migr_generation_order (
	id bigint NOT NULL,
	connection_id_fk bigint NOT NULL,
	object_id bigint NOT NULL,
	object_type varchar(4000) NOT NULL,
	generation_order bigint NOT NULL
) ;
COMMENT ON COLUMN migr_generation_order.connection_id_fk IS E'//PARENTFIELD';
ALTER  TABLE migr_generation_order OWNER TO scd_testuser;
ALTER TABLE migr_generation_order ADD UNIQUE (object_id);
ALTER TABLE migr_generation_order ADD PRIMARY KEY (id);
ALTER TABLE migr_generation_order ALTER COLUMN ID SET NOT NULL;
ALTER TABLE migr_generation_order ALTER COLUMN CONNECTION_ID_FK SET NOT NULL;
ALTER TABLE migr_generation_order ALTER COLUMN OBJECT_ID SET NOT NULL;
ALTER TABLE migr_generation_order ALTER COLUMN OBJECT_TYPE SET NOT NULL;
ALTER TABLE migr_generation_order ALTER COLUMN GENERATION_ORDER SET NOT NULL;


CREATE TABLE periodischdaten (
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	durchgefuehrt_am timestamp,
	durchgefuehrt_von varchar(50)
) ;
ALTER  TABLE periodischdaten OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixperiodischdaten ON periodischdaten (vertragsnummer, geschaeftsjahr);
CREATE INDEX ixperiodischdatendurch_am ON periodischdaten (durchgefuehrt_am);
CREATE INDEX ixperiodischdatenv_nr ON periodischdaten (vertragsnummer);


CREATE TABLE protokoll (
	letzte_nutzung timestamp,
	benutzer char(8),
	methode varchar(32),
	verteiler_nummer integer,
	verteiler_name varchar(255),
	meldung varchar(255)
) ;
ALTER  TABLE protokoll OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixprotokoll ON protokoll (letzte_nutzung, benutzer);


CREATE TABLE rahmendaten (
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	aktion bigint,
	am timestamp,
	durch varchar(255),
	sub varchar(255),
	emp varchar(255),
	empt varchar(255),
	anl varchar(255),
	ori varchar(250),
	oricp varchar(255),
	att1 varchar(255),
	att2 varchar(255),
	att3 varchar(255),
	att4 varchar(255),
	preis bigint
) ;
ALTER  TABLE rahmendaten OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixrahmendaten ON rahmendaten (vertragsnummer, geschaeftsjahr, aktion);
CREATE INDEX ixrahmendatenaktion ON rahmendaten (aktion);
CREATE INDEX ixrahmendatenv_nr ON rahmendaten (vertragsnummer);


CREATE TABLE rechte (
	verteiler_nummer integer,
	berechtigung char(1),
	berechtigter char(8)
) ;
ALTER  TABLE rechte OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixrechte ON rechte (verteiler_nummer, berechtigung, berechtigter);


CREATE UNLOGGED TABLE scdx_1 (
	c char(2),
	o varchar(255),
	ou varchar(255),
	l varchar(255),
	cn varchar(255),
	sn varchar(255),
	givenname varchar(255),
	commonnamenational varchar(255),
	initials varchar(255),
	gender char(1),
	personaltitle varchar(255),
	graduatetitle varchar(255),
	mainfunction varchar(255),
	department varchar(255),
	building varchar(255),
	roomnumber varchar(255),
	"x400-address" varchar(255),
	mail varchar(255),
	telephonenumber varchar(255),
	faxnumber varchar(255),
	secretary varchar(255),
	gidsec char(8),
	gidsecflag char(1),
	representation varchar(255),
	gidrep char(8),
	gidrepflag char(1),
	mobile varchar(255),
	videoconferencenumber1 varchar(255),
	videoconferencenumber2 varchar(255),
	publickey varchar(255),
	pager varchar(255),
	costlocation varchar(255),
	personalidnumber varchar(255),
	securephone varchar(255),
	alternatephone varchar(255),
	personalfax varchar(255),
	faxnumbersec varchar(255),
	netmeeting varchar(255),
	scdid varchar(255),
	maident varchar(255),
	gid char(8),
	postofficebox varchar(255),
	costlocationunit varchar(255),
	surnamenational varchar(255),
	givennamenational varchar(255),
	departmenttext varchar(255),
	releaseextern varchar(255),
	personalremark varchar(255),
	labeleduri varchar(255),
	expiredate varchar(255),
	validdate varchar(255),
	leavedate varchar(255),
	joindate varchar(255),
	modifytimestamp varchar(255),
	salid varchar(255),
	recordtype varchar(255),
	recordtypev3 varchar(255),
	konzbet integer,
	utc varchar(255),
	firmstat varchar(255),
	usertype varchar(255),
	contractstatus varchar(255),
	status varchar(255),
	sponsor varchar(255),
	sponsorflag char(1),
	snampre varchar(255),
	snamadd varchar(255),
	lastname varchar(255),
	appkey varchar(255),
	scdversion varchar(255),
	pkiversion varchar(255),
	robinson varchar(255),
	createtimestamp varchar(255),
	ende char(1),
	localityinternational varchar(255),
	localitynational varchar(255),
	deliveryid varchar(255),
	tcgid char(8),
	certindicator varchar(255),
	x509 smallint,
	pgp smallint,
	kaw smallint,
	kraw smallint,
	kueraw smallint,
	kvs smallint,
	krvs smallint,
	kruevs smallint,
	kpost smallint,
	orgid varchar(255),
	orgidflag char(1),
	nickname varchar(255),
	displayname varchar(255),
	departmentnumber varchar(255),
	unitid varchar(255),
	unit varchar(255),
	gidman1 char(8),
	gidman1flag char(1),
	gidman2 char(8),
	gidman2flag char(1),
	gidmanf1 char(8),
	gidmanf2 char(8),
	gidmanf3 char(8),
	departmenttextnational varchar(255),
	delegation varchar(255),
	itacc char(1),
	reqacc char(1),
	reqmail char(1),
	reqmbox char(1),
	reststart varchar(255),
	restend varchar(255),
	vip char(1),
	companycode varchar(255),
	mgmtresp varchar(255),
	notwebvisible char(2),
	gpcompany varchar(255),
	mgmtlevel char(1),
	lifecycleevent varchar(255),
	lifecycledate varchar(255),
	mailpriv varchar(255),
	mobilepriv varchar(255),
	wcunit varchar(255),
	actiontype char(2),
	actionreason char(2),
	actionstartdate varchar(255),
	preferredsn varchar(255),
	orglevela varchar(255),
	orglevelb varchar(255),
	orglevelc varchar(255),
	orgleveld varchar(255),
	orglevelx varchar(255),
	altou varchar(255),
	clientid smallint,
	clientname varchar(255),
	fksource varchar(255),
	prefpronoun varchar(255),
	countryofresidence char(2),
	validationerror varchar(255)
) ;
ALTER  TABLE scdx_1 OWNER TO scd_testuser;

CREATE UNIQUE INDEX ixscdx_1_dn ON scdx_1 (c, o, ou, l, cn);



CREATE UNLOGGED TABLE scd_2 (
	c char(2),
	o varchar(255),
	ou varchar(255),
	l varchar(255),
	cn varchar(255),
	sn varchar(255),
	givenname varchar(255),
	commonnamenational varchar(255),
	initials varchar(255),
	gender char(1),
	personaltitle varchar(255),
	graduatetitle varchar(255),
	mainfunction varchar(255),
	department varchar(255),
	building varchar(255),
	roomnumber varchar(255),
	"x400-address" varchar(255),
	mail varchar(255),
	telephonenumber varchar(255),
	faxnumber varchar(255),
	secretary varchar(255),
	gidsec char(8),
	gidsecflag char(1),
	representation varchar(255),
	gidrep char(8),
	gidrepflag char(1),
	mobile varchar(255),
	videoconferencenumber1 varchar(255),
	videoconferencenumber2 varchar(255),
	publickey varchar(255),
	pager varchar(255),
	costlocation varchar(255),
	personalidnumber varchar(255),
	securephone varchar(255),
	alternatephone varchar(255),
	personalfax varchar(255),
	faxnumbersec varchar(255),
	netmeeting varchar(255),
	scdid varchar(255),
	maident varchar(255),
	gid char(8),
	postofficebox varchar(255),
	costlocationunit varchar(255),
	surnamenational varchar(255),
	givennamenational varchar(255),
	departmenttext varchar(255),
	releaseextern varchar(255),
	personalremark varchar(255),
	labeleduri varchar(255),
	expiredate varchar(255),
	validdate varchar(255),
	leavedate varchar(255),
	joindate varchar(255),
	modifytimestamp varchar(255),
	salid varchar(255),
	recordtype varchar(255),
	recordtypev3 varchar(255),
	konzbet integer,
	utc varchar(255),
	firmstat varchar(255),
	usertype varchar(255),
	contractstatus varchar(255),
	status varchar(255),
	sponsor varchar(255),
	sponsorflag char(1),
	snampre varchar(255),
	snamadd varchar(255),
	lastname varchar(255),
	appkey varchar(255),
	scdversion varchar(255),
	pkiversion varchar(255),
	robinson varchar(255),
	createtimestamp varchar(255),
	ende char(1),
	localityinternational varchar(255),
	localitynational varchar(255),
	deliveryid varchar(255),
	tcgid char(8),
	certindicator varchar(255),
	x509 smallint,
	pgp smallint,
	kaw smallint,
	kraw smallint,
	kueraw smallint,
	kvs smallint,
	krvs smallint,
	kruevs smallint,
	kpost smallint,
	orgid varchar(255),
	orgidflag char(1),
	nickname varchar(255),
	displayname varchar(255),
	departmentnumber varchar(255),
	unitid varchar(255),
	unit varchar(255),
	gidman1 char(8),
	gidman1flag char(1),
	gidman2 char(8),
	gidman2flag char(1),
	gidmanf1 char(8),
	gidmanf2 char(8),
	gidmanf3 char(8),
	departmenttextnational varchar(255),
	delegation varchar(255),
	itacc char(1),
	reqacc char(1),
	reqmail char(1),
	reqmbox char(1),
	reststart varchar(255),
	restend varchar(255),
	vip char(1),
	companycode varchar(255),
	mgmtresp varchar(255),
	notwebvisible char(2),
	gpcompany varchar(255),
	mgmtlevel char(1),
	lifecycleevent varchar(255),
	lifecycledate varchar(255),
	mailpriv varchar(255),
	mobilepriv varchar(255),
	wcunit varchar(255),
	actiontype char(2),
	actionreason char(2),
	actionstartdate varchar(255),
	preferredsn varchar(255),
	orglevela varchar(255),
	orglevelb varchar(255),
	orglevelc varchar(255),
	orgleveld varchar(255),
	orglevelx varchar(255),
	altou varchar(255),
	clientid smallint,
	clientname varchar(255),
	fksource varchar(255),
	prefpronoun varchar(255),
	countryofresidence char(2),
	validationerror varchar(255)
) ;
ALTER  TABLE scd_2 OWNER TO scd_testuser;

CREATE UNIQUE INDEX ixscd_2_dn ON scd_2 (c, o, ou, l, cn);



CREATE TABLE scd_banner (
	contract_number integer,
	image bytea,
	language varchar(2)
) ;
ALTER  TABLE scd_banner OWNER TO scd_testuser;


CREATE TABLE sommerzeit (
	c char(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32),
	utc varchar(9),
	beginnsz timestamp,
	endesz timestamp,
	sz char(1)
) ;
ALTER  TABLE sommerzeit OWNER TO scd_testuser;
CREATE INDEX ixsommerzeit ON sommerzeit (c, o, ou, l);


CREATE TABLE stage_migrlog (
	svrid_fk bigint,
	dbid_gen_fk bigint,
	id bigint NOT NULL,
	ref_object_id bigint,
	ref_object_type varchar(4000),
	log_date timestamp NOT NULL,
	severity smallint NOT NULL,
	logtext varchar(4000),
	phase varchar(20)
) ;
ALTER  TABLE stage_migrlog OWNER TO scd_testuser;
ALTER TABLE stage_migrlog ADD PRIMARY KEY (id);
ALTER TABLE stage_migrlog ALTER COLUMN ID SET NOT NULL;
ALTER TABLE stage_migrlog ALTER COLUMN LOG_DATE SET NOT NULL;
ALTER TABLE stage_migrlog ALTER COLUMN SEVERITY SET NOT NULL;


CREATE TABLE tippderwoche (
	nr bigint NOT NULL,
	url_de varchar(255),
	url_en varchar(255),
	tipptextde varchar(255),
	tipptexten varchar(255),
	tippheadlinede varchar(255),
	tippheadlineen varchar(255),
	aktiv bigint,
	aktiv_ab timestamp,
	sgre_aktiv bigint,
	sgre_aktiv_ab timestamp,
	se_aktiv bigint,
	se_aktiv_ab timestamp,
	fl_aktiv bigint,
	fl_aktiv_ab timestamp
) ;
ALTER  TABLE tippderwoche OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixtippderwoche ON tippderwoche (nr);
ALTER TABLE tippderwoche ALTER COLUMN NR SET NOT NULL;


CREATE TABLE tippderwoche_bak (
	nr bigint NOT NULL,
	url_de varchar(255),
	url_en varchar(255),
	tipptextde varchar(255),
	tipptexten varchar(255),
	tippheadlinede varchar(255),
	tippheadlineen varchar(255),
	aktiv bigint,
	aktiv_ab timestamp
) ;
ALTER  TABLE tippderwoche_bak OWNER TO scd_testuser;
ALTER TABLE tippderwoche_bak ALTER COLUMN NR SET NOT NULL;


CREATE TABLE ts_daten (
	vertragsnummer bigint NOT NULL,
	thema varchar(100),
	sprache varchar(100),
	kommentar varchar(255),
	central_translation varchar(2),
	local_translation varchar(2),
	aud_ws varchar(2),
	aud varchar(2),
	ut_ws varchar(2),
	ut varchar(2)
) ;
ALTER  TABLE ts_daten OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixts_daten ON ts_daten (vertragsnummer);
ALTER TABLE ts_daten ALTER COLUMN VERTRAGSNUMMER SET NOT NULL;


CREATE TABLE users (
	gid char(8)
) ;
ALTER  TABLE users OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixusers ON users (gid);


CREATE TABLE validorgcodes (
	bereich varchar(64),
	ou varchar(64),
	ou_gruppe varchar(64),
	ou_anzeige_de varchar(64),
	ou_anzeige_en varchar(64),
	sonstige varchar(64),
	sort bigint
) ;
ALTER  TABLE validorgcodes OWNER TO scd_testuser;


CREATE TABLE verteiler (
	verteiler_nummer integer,
	verteiler_name varchar(255),
	vn_funktion varchar(32),
	vn_bereich varchar(32),
	vn_standort varchar(32),
	vn_firma varchar(32),
	vn_land char(2),
	beschreibung varchar(128),
	erstellungsdatum timestamp,
	ende_der_nutzung timestamp,
	eigentuemer char(8),
	eigentuemer_name varchar(32),
	eigentuemer_vorname varchar(32),
	stellvertreter char(8),
	stellvertreter_name varchar(32),
	stellvertreter_vorname varchar(32),
	letzte_aenderung timestamp,
	geaendert_von char(8),
	letzte_nutzung timestamp,
	verteiler_inhalt varchar(16),
	vn_kurz varchar(32),
	vn_frei varchar(128)
) ;
ALTER  TABLE verteiler OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixverteiler ON verteiler (verteiler_nummer);


CREATE TABLE vertraege (
	vertragsart char(2),
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	anlagedatum timestamp,
	aenderungsdatum timestamp,
	erstellt_von varchar(50),
	geaendert_von varchar(50),
	durchgefuehrt_am timestamp,
	durchgefuehrt_von varchar(50),
	status varchar(50),
	status_durch varchar(50),
	status_am timestamp,
	freigabe bigint,
	freigabe_durch varchar(50),
	freigabe_am timestamp,
	cancel_durch varchar(50),
	cancel_am timestamp,
	firma varchar(50),
	abteilung varchar(50),
	plz varchar(50),
	ort varchar(50),
	strasse varchar(50),
	asp_name_k varchar(50),
	asp_vorname_k varchar(50),
	asp_gid_k varchar(8),
	asp_mail_k varchar(75),
	asp_l_k varchar(50),
	asp_tel_k varchar(50),
	asp_abt_k varchar(50),
	asp_name_l varchar(50),
	asp_vorname_l varchar(50),
	asp_gid_l varchar(8),
	asp_mail_l varchar(75),
	asp_l_l varchar(50),
	asp_tel_l varchar(50),
	asp_abt_l varchar(50),
	asp_name_k_kaufm varchar(50),
	asp_vorname_k_kaufm varchar(50),
	asp_gid_k_kaufm varchar(8),
	asp_mail_k_kaufm varchar(75),
	asp_l_k_kaufm varchar(50),
	asp_tel_k_kaufm varchar(50),
	asp_abt_k_kaufm varchar(50),
	asp_name_l_kaufm varchar(50),
	asp_vorname_l_kaufm varchar(50),
	asp_gid_l_kaufm varchar(8),
	asp_mail_l_kaufm varchar(75),
	asp_l_l_kaufm varchar(50),
	asp_tel_l_kaufm varchar(50),
	asp_abt_l_kaufm varchar(50),
	vertragsdatum timestamp,
	verwendungszweck_betreff varchar(250),
	umfang_selektion varchar(250),
	preis bigint,
	org_id varchar(50),
	bestellzeichen varchar(50),
	leistungsart varchar(50),
	kontrakt_nummer varchar(50),
	beginn_datum timestamp,
	ende_datum timestamp,
	lieferart varchar(50),
	gepackt bigint,
	asp_name varchar(50),
	asp_vorname varchar(50),
	asp_gid varchar(8),
	asp_mail varchar(75),
	asp_abt varchar(50),
	asp_tel varchar(50),
	asp_l varchar(50),
	emfpaengermail varchar(75),
	server varchar(50),
	benutzername varchar(50),
	kennwort varchar(50),
	verzeichnis varchar(50),
	zugangsberechtigung varchar(50),
	abfragename varchar(50),
	sql varchar(4000),
	anzahl_datensaetze bigint,
	anzahl_de bigint,
	dateiname varchar(50),
	dateityp varchar(50),
	exportspezifikation varchar(50),
	pfad varchar(255),
	ori varchar(250),
	oricp varchar(250),
	sub varchar(250),
	emp varchar(250),
	empt varchar(250),
	anl varchar(250),
	att1 varchar(250),
	att2 varchar(250),
	att3 varchar(250),
	att4 varchar(250),
	anwendungsnummer bigint,
	anwendung varchar(150),
	url varchar(250),
	url_e varchar(250),
	hotline_name varchar(150),
	hotline_vorname varchar(150),
	hotline_mail varchar(150),
	hotline_abt varchar(50),
	hotline_tel varchar(50),
	hotline_gid varchar(8),
	hotline_l varchar(150),
	bemerkung varchar(4000),
	zugriffszeitpunkt varchar(50),
	zugriffsdauer varchar(50),
	zugriffsfrequenz varchar(50),
	zugriffsart varchar(50),
	bildname varchar(250),
	logtext varchar(250),
	bildinfotext varchar(150),
	wb_sprache varchar(50),
	lieferzyklus varchar(50),
	mo bigint,
	di bigint,
	mi bigint,
	"do" bigint,
	fr bigint,
	sa bigint,
	so bigint,
	historygp varchar(4000),
	historyel varchar(4000),
	historye2 varchar(4000),
	tstart timestamp,
	tende timestamp,
	tbetreff varchar(255),
	ttext varchar(4000),
	tprio varchar(50),
	tort varchar(255),
	bildinfotexten varchar(150),
	rabatt bigint,
	positionsnummer varchar(6),
	grant_gov smallint,
	grant_gov_durch varchar(8),
	grant_gov_am timestamp,
	grant_ds smallint,
	grant_ds_durch varchar(8),
	grant_ds_am timestamp,
	internet_access smallint,
	ticket_nr varchar(50),
	local_account_dn varchar(250),
	ad_login varchar(250),
	grant_gov_name varchar(150),
	grant_gov_vorname varchar(150),
	grant_ds_name varchar(150),
	grant_ds_vorname varchar(150),
	grant_scd bigint,
	grant_scd_durch varchar(8),
	grant_scd_am timestamp,
	grant_scd_name varchar(150),
	grant_scd_vorname varchar(150),
	grant_scd_grund bigint,
	future_entries bigint,
	geschaeftszweck varchar(4000),
	selektion varchar(4000),
	filter_scope varchar(2000),
	facts_external_id varchar(40),
	lieferzyklus_bemerkung varchar(255),
	asp_clientid_k varchar(2),
	grant_siemens bigint,
	grant_energy bigint,
	grant_flender bigint,
	grant_carveout smallint
) ;
ALTER  TABLE vertraege OWNER TO scd_testuser;

CREATE UNIQUE INDEX ixvertraegev_nru ON vertraege (vertragsnummer);


CREATE TABLE vertraege_2022_01_26 (
	vertragsart char(2),
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	anlagedatum timestamp,
	aenderungsdatum timestamp,
	erstellt_von varchar(50),
	geaendert_von varchar(50),
	durchgefuehrt_am timestamp,
	durchgefuehrt_von varchar(50),
	status varchar(50),
	status_durch varchar(50),
	status_am timestamp,
	freigabe bigint,
	freigabe_durch varchar(50),
	freigabe_am timestamp,
	cancel_durch varchar(50),
	cancel_am timestamp,
	firma varchar(50),
	abteilung varchar(50),
	plz varchar(50),
	ort varchar(50),
	strasse varchar(50),
	asp_name_k varchar(50),
	asp_vorname_k varchar(50),
	asp_gid_k varchar(8),
	asp_mail_k varchar(75),
	asp_l_k varchar(50),
	asp_tel_k varchar(50),
	asp_abt_k varchar(50),
	asp_name_l varchar(50),
	asp_vorname_l varchar(50),
	asp_gid_l varchar(8),
	asp_mail_l varchar(75),
	asp_l_l varchar(50),
	asp_tel_l varchar(50),
	asp_abt_l varchar(50),
	asp_name_k_kaufm varchar(50),
	asp_vorname_k_kaufm varchar(50),
	asp_gid_k_kaufm varchar(8),
	asp_mail_k_kaufm varchar(75),
	asp_l_k_kaufm varchar(50),
	asp_tel_k_kaufm varchar(50),
	asp_abt_k_kaufm varchar(50),
	asp_name_l_kaufm varchar(50),
	asp_vorname_l_kaufm varchar(50),
	asp_gid_l_kaufm varchar(8),
	asp_mail_l_kaufm varchar(75),
	asp_l_l_kaufm varchar(50),
	asp_tel_l_kaufm varchar(50),
	asp_abt_l_kaufm varchar(50),
	vertragsdatum timestamp,
	verwendungszweck_betreff varchar(250),
	umfang_selektion varchar(250),
	preis bigint,
	org_id varchar(50),
	bestellzeichen varchar(50),
	leistungsart varchar(50),
	kontrakt_nummer varchar(50),
	beginn_datum timestamp,
	ende_datum timestamp,
	lieferart varchar(50),
	gepackt bigint,
	asp_name varchar(50),
	asp_vorname varchar(50),
	asp_gid varchar(8),
	asp_mail varchar(75),
	asp_abt varchar(50),
	asp_tel varchar(50),
	asp_l varchar(50),
	emfpaengermail varchar(75),
	server varchar(50),
	benutzername varchar(50),
	kennwort varchar(50),
	verzeichnis varchar(50),
	zugangsberechtigung varchar(50),
	abfragename varchar(50),
	sql varchar(4000),
	anzahl_datensaetze bigint,
	anzahl_de bigint,
	dateiname varchar(50),
	dateityp varchar(50),
	exportspezifikation varchar(50),
	pfad varchar(255),
	ori varchar(250),
	oricp varchar(250),
	sub varchar(250),
	emp varchar(250),
	empt varchar(250),
	anl varchar(250),
	att1 varchar(250),
	att2 varchar(250),
	att3 varchar(250),
	att4 varchar(250),
	anwendungsnummer bigint,
	anwendung varchar(150),
	url varchar(250),
	url_e varchar(250),
	hotline_name varchar(150),
	hotline_vorname varchar(150),
	hotline_mail varchar(150),
	hotline_abt varchar(50),
	hotline_tel varchar(50),
	hotline_gid varchar(8),
	hotline_l varchar(150),
	bemerkung varchar(4000),
	zugriffszeitpunkt varchar(50),
	zugriffsdauer varchar(50),
	zugriffsfrequenz varchar(50),
	zugriffsart varchar(50),
	bildname varchar(250),
	logtext varchar(250),
	bildinfotext varchar(150),
	wb_sprache varchar(50),
	lieferzyklus varchar(50),
	mo bigint,
	di bigint,
	mi bigint,
	"do" bigint,
	fr bigint,
	sa bigint,
	so bigint,
	historygp varchar(4000),
	historyel varchar(4000),
	historye2 varchar(4000),
	tstart timestamp,
	tende timestamp,
	tbetreff varchar(255),
	ttext varchar(4000),
	tprio varchar(50),
	tort varchar(255),
	bildinfotexten varchar(150),
	rabatt bigint,
	positionsnummer varchar(6),
	grant_gov smallint,
	grant_gov_durch varchar(8),
	grant_gov_am timestamp,
	grant_ds smallint,
	grant_ds_durch varchar(8),
	grant_ds_am timestamp,
	internet_access smallint,
	ticket_nr varchar(50),
	local_account_dn varchar(250),
	ad_login varchar(250),
	grant_gov_name varchar(150),
	grant_gov_vorname varchar(150),
	grant_ds_name varchar(150),
	grant_ds_vorname varchar(150),
	grant_scd bigint,
	grant_scd_durch varchar(8),
	grant_scd_am timestamp,
	grant_scd_name varchar(150),
	grant_scd_vorname varchar(150),
	grant_scd_grund bigint,
	future_entries bigint,
	geschaeftszweck varchar(4000),
	selektion varchar(4000),
	filter_scope varchar(2000),
	facts_external_id varchar(40),
	lieferzyklus_bemerkung varchar(255),
	asp_clientid_k varchar(2),
	grant_siemens bigint,
	grant_energy bigint,
	grant_flender bigint
) ;
ALTER  TABLE vertraege_2022_01_26 OWNER TO scd_testuser;


CREATE TABLE vertraege_bak_20210630 (
	vertragsart char(2),
	vertragsnummer bigint,
	geschaeftsjahr varchar(50),
	anlagedatum timestamp,
	aenderungsdatum timestamp,
	erstellt_von varchar(50),
	geaendert_von varchar(50),
	durchgefuehrt_am timestamp,
	durchgefuehrt_von varchar(50),
	status varchar(50),
	status_durch varchar(50),
	status_am timestamp,
	freigabe bigint,
	freigabe_durch varchar(50),
	freigabe_am timestamp,
	cancel_durch varchar(50),
	cancel_am timestamp,
	firma varchar(50),
	abteilung varchar(50),
	plz varchar(50),
	ort varchar(50),
	strasse varchar(50),
	asp_name_k varchar(50),
	asp_vorname_k varchar(50),
	asp_gid_k varchar(8),
	asp_mail_k varchar(75),
	asp_l_k varchar(50),
	asp_tel_k varchar(50),
	asp_abt_k varchar(50),
	asp_name_l varchar(50),
	asp_vorname_l varchar(50),
	asp_gid_l varchar(8),
	asp_mail_l varchar(75),
	asp_l_l varchar(50),
	asp_tel_l varchar(50),
	asp_abt_l varchar(50),
	asp_name_k_kaufm varchar(50),
	asp_vorname_k_kaufm varchar(50),
	asp_gid_k_kaufm varchar(8),
	asp_mail_k_kaufm varchar(75),
	asp_l_k_kaufm varchar(50),
	asp_tel_k_kaufm varchar(50),
	asp_abt_k_kaufm varchar(50),
	asp_name_l_kaufm varchar(50),
	asp_vorname_l_kaufm varchar(50),
	asp_gid_l_kaufm varchar(8),
	asp_mail_l_kaufm varchar(75),
	asp_l_l_kaufm varchar(50),
	asp_tel_l_kaufm varchar(50),
	asp_abt_l_kaufm varchar(50),
	vertragsdatum timestamp,
	verwendungszweck_betreff varchar(250),
	umfang_selektion varchar(250),
	preis bigint,
	org_id varchar(50),
	bestellzeichen varchar(50),
	leistungsart varchar(50),
	kontrakt_nummer varchar(50),
	beginn_datum timestamp,
	ende_datum timestamp,
	lieferart varchar(50),
	gepackt bigint,
	asp_name varchar(50),
	asp_vorname varchar(50),
	asp_gid varchar(8),
	asp_mail varchar(75),
	asp_abt varchar(50),
	asp_tel varchar(50),
	asp_l varchar(50),
	emfpaengermail varchar(75),
	server varchar(50),
	benutzername varchar(50),
	kennwort varchar(50),
	verzeichnis varchar(50),
	zugangsberechtigung varchar(50),
	abfragename varchar(50),
	sql varchar(4000),
	anzahl_datensaetze bigint,
	anzahl_de bigint,
	dateiname varchar(50),
	dateityp varchar(50),
	exportspezifikation varchar(50),
	pfad varchar(255),
	ori varchar(250),
	oricp varchar(250),
	sub varchar(250),
	emp varchar(250),
	empt varchar(250),
	anl varchar(250),
	att1 varchar(250),
	att2 varchar(250),
	att3 varchar(250),
	att4 varchar(250),
	anwendungsnummer bigint,
	anwendung varchar(150),
	url varchar(250),
	url_e varchar(250),
	hotline_name varchar(150),
	hotline_vorname varchar(150),
	hotline_mail varchar(150),
	hotline_abt varchar(50),
	hotline_tel varchar(50),
	hotline_gid varchar(8),
	hotline_l varchar(150),
	bemerkung varchar(4000),
	zugriffszeitpunkt varchar(50),
	zugriffsdauer varchar(50),
	zugriffsfrequenz varchar(50),
	zugriffsart varchar(50),
	bildname varchar(250),
	logtext varchar(250),
	bildinfotext varchar(150),
	wb_sprache varchar(50),
	lieferzyklus varchar(50),
	mo bigint,
	di bigint,
	mi bigint,
	"do" bigint,
	fr bigint,
	sa bigint,
	so bigint,
	historygp varchar(4000),
	historyel varchar(4000),
	historye2 varchar(4000),
	tstart timestamp,
	tende timestamp,
	tbetreff varchar(255),
	ttext varchar(4000),
	tprio varchar(50),
	tort varchar(255),
	bildinfotexten varchar(150),
	rabatt bigint,
	positionsnummer varchar(6),
	grant_gov smallint,
	grant_gov_durch varchar(8),
	grant_gov_am timestamp,
	grant_ds smallint,
	grant_ds_durch varchar(8),
	grant_ds_am timestamp,
	internet_access smallint,
	ticket_nr varchar(50),
	local_account_dn varchar(250),
	ad_login varchar(250),
	grant_gov_name varchar(150),
	grant_gov_vorname varchar(150),
	grant_ds_name varchar(150),
	grant_ds_vorname varchar(150),
	grant_scd bigint,
	grant_scd_durch varchar(8),
	grant_scd_am timestamp,
	grant_scd_name varchar(150),
	grant_scd_vorname varchar(150),
	grant_scd_grund bigint,
	future_entries bigint,
	geschaeftszweck varchar(4000),
	selektion varchar(4000),
	filter_scope varchar(2000),
	facts_external_id varchar(40),
	lieferzyklus_bemerkung varchar(255),
	asp_clientid_k varchar(2),
	grant_siemens bigint,
	grant_energy bigint,
	grant_flender bigint
) ;
ALTER  TABLE vertraege_bak_20210630 OWNER TO scd_testuser;


CREATE TABLE vertragsarten (
	vertragsart varchar(50),
	vertragsart_text varchar(50),
	verrechnungstext varchar(50),
	verzeichnis varchar(50),
	leistungsart varchar(50)
) ;
ALTER  TABLE vertragsarten OWNER TO scd_testuser;


CREATE TABLE wb_log (
	tagvon timestamp NOT NULL,
	tagbis timestamp NOT NULL,
	anz bigint NOT NULL,
	sourceip varchar(50) NOT NULL,
	serverip varchar(50) NOT NULL,
	logtext varchar(20) NOT NULL
) ;
ALTER  TABLE wb_log OWNER TO scd_testuser;
ALTER TABLE wb_log ALTER COLUMN TAGVON SET NOT NULL;
ALTER TABLE wb_log ALTER COLUMN TAGBIS SET NOT NULL;
ALTER TABLE wb_log ALTER COLUMN ANZ SET NOT NULL;
ALTER TABLE wb_log ALTER COLUMN SOURCEIP SET NOT NULL;
ALTER TABLE wb_log ALTER COLUMN SERVERIP SET NOT NULL;
ALTER TABLE wb_log ALTER COLUMN LOGTEXT SET NOT NULL;


CREATE TABLE ws_admin_users (
	userid varchar(128) NOT NULL,
	comment varchar(256) NOT NULL,
	userrole varchar(128) NOT NULL
) ;
ALTER  TABLE ws_admin_users OWNER TO scd_testuser;
ALTER TABLE ws_admin_users ADD PRIMARY KEY (userid);
ALTER TABLE ws_admin_users ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE ws_admin_users ALTER COLUMN COMMENT SET NOT NULL;
ALTER TABLE ws_admin_users ALTER COLUMN USERROLE SET NOT NULL;


CREATE TABLE ws_audit (
	id numeric(38) NOT NULL,
	entry_time timestamp NOT NULL,
	userid varchar(128) NOT NULL,
	applicationuserid varchar(128),
	remotehost varchar(32),
	operation varchar(256),
	record_count numeric(38),
	category varchar(32),
	duration numeric(38),
	internet_source smallint
) ;
ALTER  TABLE ws_audit OWNER TO scd_testuser;
CREATE INDEX ws_audit_category ON ws_audit (category);
CREATE INDEX ws_audit_time ON ws_audit (entry_time);
CREATE INDEX ws_audit_user ON ws_audit (userid);
ALTER TABLE ws_audit ADD PRIMARY KEY (id);
ALTER TABLE ws_audit ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ws_audit ALTER COLUMN ENTRY_TIME SET NOT NULL;
ALTER TABLE ws_audit ALTER COLUMN USERID SET NOT NULL;


CREATE TABLE ws_certificates (
	provider varchar(64) NOT NULL,
	certificate bytea NOT NULL,
	type varchar(20) NOT NULL,
	password varchar(64) NOT NULL
) ;
ALTER  TABLE ws_certificates OWNER TO scd_testuser;
ALTER TABLE ws_certificates ADD PRIMARY KEY (provider);
ALTER TABLE ws_certificates ALTER COLUMN PROVIDER SET NOT NULL;
ALTER TABLE ws_certificates ALTER COLUMN CERTIFICATE SET NOT NULL;
ALTER TABLE ws_certificates ALTER COLUMN TYPE SET NOT NULL;
ALTER TABLE ws_certificates ALTER COLUMN PASSWORD SET NOT NULL;


CREATE TABLE ws_clients (
	partner_id varchar(128) NOT NULL,
	issuer varchar(128) NOT NULL,
	userid varchar(128) NOT NULL,
	certid varchar(12) NOT NULL,
	service varchar(20) NOT NULL DEFAULT 'SCDWS',
	internal smallint DEFAULT 0,
	expiration_date timestamp
) ;
ALTER  TABLE ws_clients OWNER TO scd_testuser;
ALTER TABLE ws_clients ADD PRIMARY KEY (partner_id,issuer,service);
ALTER TABLE ws_clients ALTER COLUMN PARTNER_ID SET NOT NULL;
ALTER TABLE ws_clients ALTER COLUMN ISSUER SET NOT NULL;
ALTER TABLE ws_clients ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE ws_clients ALTER COLUMN CERTID SET NOT NULL;
ALTER TABLE ws_clients ALTER COLUMN SERVICE SET NOT NULL;


CREATE TABLE ws_clients_historic (
	partner_id varchar(128) NOT NULL,
	issuer varchar(128) NOT NULL,
	userid varchar(128) NOT NULL,
	certid varchar(12) NOT NULL
) ;
ALTER  TABLE ws_clients_historic OWNER TO scd_testuser;
ALTER TABLE ws_clients_historic ALTER COLUMN PARTNER_ID SET NOT NULL;
ALTER TABLE ws_clients_historic ALTER COLUMN ISSUER SET NOT NULL;
ALTER TABLE ws_clients_historic ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE ws_clients_historic ALTER COLUMN CERTID SET NOT NULL;


CREATE TABLE ws_colgroup_column_ids (
	id numeric(38) NOT NULL,
	colgroupid numeric(38) NOT NULL,
	columnid numeric(38) NOT NULL
) ;
ALTER  TABLE ws_colgroup_column_ids OWNER TO scd_testuser;
CREATE INDEX ws_colgroup_column_ids_colid ON ws_colgroup_column_ids (columnid);
CREATE INDEX ws_colgroup_column_ids_groupid ON ws_colgroup_column_ids (colgroupid);
ALTER TABLE ws_colgroup_column_ids ADD PRIMARY KEY (id);
ALTER TABLE ws_colgroup_column_ids ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ws_colgroup_column_ids ALTER COLUMN COLGROUPID SET NOT NULL;
ALTER TABLE ws_colgroup_column_ids ALTER COLUMN COLUMNID SET NOT NULL;


CREATE TABLE ws_column_groups (
	colgroupid numeric(38) NOT NULL,
	entity varchar(56) NOT NULL,
	colgroupname varchar(128) NOT NULL
) ;
ALTER  TABLE ws_column_groups OWNER TO scd_testuser;
CREATE INDEX ws_column_groups_entity ON ws_column_groups (entity);
CREATE INDEX ws_column_groups_name ON ws_column_groups (colgroupname);
ALTER TABLE ws_column_groups ADD PRIMARY KEY (colgroupid);
ALTER TABLE ws_column_groups ALTER COLUMN COLGROUPID SET NOT NULL;
ALTER TABLE ws_column_groups ALTER COLUMN ENTITY SET NOT NULL;
ALTER TABLE ws_column_groups ALTER COLUMN COLGROUPNAME SET NOT NULL;


CREATE TABLE ws_column_names (
	columnid numeric(38) NOT NULL,
	entity varchar(128) NOT NULL,
	columnname varchar(45) NOT NULL
) ;
ALTER  TABLE ws_column_names OWNER TO scd_testuser;
CREATE INDEX ws_column_names_entity ON ws_column_names (entity);
CREATE INDEX ws_column_names_name ON ws_column_names (columnname);
ALTER TABLE ws_column_names ADD PRIMARY KEY (columnid);
ALTER TABLE ws_column_names ALTER COLUMN COLUMNID SET NOT NULL;
ALTER TABLE ws_column_names ALTER COLUMN ENTITY SET NOT NULL;
ALTER TABLE ws_column_names ALTER COLUMN COLUMNNAME SET NOT NULL;


CREATE TABLE ws_config (
	name varchar(128) NOT NULL,
	value varchar(1024) NOT NULL
) ;
ALTER  TABLE ws_config OWNER TO scd_testuser;
ALTER TABLE ws_config ADD PRIMARY KEY (name);
ALTER TABLE ws_config ALTER COLUMN NAME SET NOT NULL;
ALTER TABLE ws_config ALTER COLUMN VALUE SET NOT NULL;


CREATE TABLE ws_contract_mail (
	userid varchar(128) NOT NULL,
	entry_time timestamp NOT NULL,
	reason varchar(40)
) ;
ALTER  TABLE ws_contract_mail OWNER TO scd_testuser;
CREATE INDEX ws_contract_mail_time ON ws_contract_mail (entry_time);
ALTER TABLE ws_contract_mail ADD PRIMARY KEY (userid);
ALTER TABLE ws_contract_mail ALTER COLUMN ENTRY_TIME SET NOT NULL;


CREATE TABLE ws_cumulated_audit (
	id numeric(38) NOT NULL,
	year_month varchar(16) NOT NULL,
	userid varchar(128) NOT NULL,
	record_count numeric(38)
) ;
ALTER  TABLE ws_cumulated_audit OWNER TO scd_testuser;
CREATE INDEX ws_cumulated_audit_userid ON ws_cumulated_audit (userid);
CREATE INDEX ws_cumulated_audit_yearmonth ON ws_cumulated_audit (year_month);
ALTER TABLE ws_cumulated_audit ADD UNIQUE (year_month,userid);
ALTER TABLE ws_cumulated_audit ADD PRIMARY KEY (id);
ALTER TABLE ws_cumulated_audit ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ws_cumulated_audit ALTER COLUMN YEAR_MONTH SET NOT NULL;
ALTER TABLE ws_cumulated_audit ALTER COLUMN USERID SET NOT NULL;


CREATE TABLE ws_export_data (
	cfilename varchar(128) NOT NULL,
	creationdate timestamp,
	creationfinished numeric(38),
	data text,
	datatype varchar(32)
) ;
ALTER  TABLE ws_export_data OWNER TO scd_testuser;
ALTER TABLE ws_export_data ADD PRIMARY KEY (cfilename);


CREATE TABLE ws_myid_config (
	client_id varchar(64) NOT NULL,
	user_id varchar(8) NOT NULL,
	my_id_url varchar(200) NOT NULL
) ;
ALTER  TABLE ws_myid_config OWNER TO scd_testuser;
ALTER TABLE ws_myid_config ADD PRIMARY KEY (client_id);
ALTER TABLE ws_myid_config ALTER COLUMN CLIENT_ID SET NOT NULL;
ALTER TABLE ws_myid_config ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ws_myid_config ALTER COLUMN MY_ID_URL SET NOT NULL;


CREATE TABLE ws_quota_mail (
	user_key varchar(128) NOT NULL,
	entry_time timestamp NOT NULL
) ;
ALTER  TABLE ws_quota_mail OWNER TO scd_testuser;
CREATE INDEX ws_quota_mail_time ON ws_quota_mail (entry_time);
ALTER TABLE ws_quota_mail ADD PRIMARY KEY (user_key);
ALTER TABLE ws_quota_mail ALTER COLUMN ENTRY_TIME SET NOT NULL;


CREATE TABLE ws_usage_per_user (
	userid varchar(128) NOT NULL,
	current_month varchar(45) NOT NULL,
	results_current_month numeric(38) DEFAULT 0
) ;
ALTER  TABLE ws_usage_per_user OWNER TO scd_testuser;
CREATE INDEX ws_usage_per_user_month ON ws_usage_per_user (current_month);
ALTER TABLE ws_usage_per_user ADD PRIMARY KEY (userid);
ALTER TABLE ws_usage_per_user ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE ws_usage_per_user ALTER COLUMN CURRENT_MONTH SET NOT NULL;


CREATE TABLE ws_userid_clientid (
	id bigint GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1 MAXVALUE 9223372036854775807 MINVALUE 1 NO CYCLE CACHE 20 ),
	userid varchar(12) NOT NULL,
	clientid varchar(2) NOT NULL
) ;
ALTER  TABLE ws_userid_clientid OWNER TO scd_testuser;
ALTER TABLE ws_userid_clientid ADD PRIMARY KEY (id);
ALTER TABLE ws_userid_clientid ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ws_userid_clientid ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE ws_userid_clientid ALTER COLUMN CLIENTID SET NOT NULL;


CREATE TABLE ws_user_colgroup_ids (
	id numeric(38) NOT NULL,
	userid varchar(128) NOT NULL,
	colgroupid numeric(38) NOT NULL,
	modified timestamp DEFAULT statement_timestamp()
) ;
ALTER  TABLE ws_user_colgroup_ids OWNER TO scd_testuser;
CREATE INDEX ws_user_colgroup_ids_colid ON ws_user_colgroup_ids (colgroupid);
CREATE INDEX ws_user_colgroup_ids_modified ON ws_user_colgroup_ids (modified);
CREATE INDEX ws_user_colgroup_ids_userid ON ws_user_colgroup_ids (userid);
ALTER TABLE ws_user_colgroup_ids ADD PRIMARY KEY (id);
ALTER TABLE ws_user_colgroup_ids ALTER COLUMN ID SET NOT NULL;
ALTER TABLE ws_user_colgroup_ids ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE ws_user_colgroup_ids ALTER COLUMN COLGROUPID SET NOT NULL;


CREATE TABLE ws_user_service (
	user_id varchar(20) NOT NULL,
	service varchar(20) NOT NULL
) ;
ALTER  TABLE ws_user_service OWNER TO scd_testuser;
ALTER TABLE ws_user_service ADD UNIQUE (user_id,service);
ALTER TABLE ws_user_service ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE ws_user_service ALTER COLUMN SERVICE SET NOT NULL;


CREATE TABLE ws_user_settings (
	userid varchar(128) NOT NULL,
	scd_comment varchar(256),
	allowed_results_per_month numeric(38) NOT NULL,
	additional_filter varchar(1024),
	max_result_count numeric(38) NOT NULL,
	isgroup numeric(38),
	blocksonviolation numeric(38),
	modified timestamp DEFAULT statement_timestamp(),
	expires timestamp,
	starts timestamp,
	blocksonexpiredate bigint NOT NULL DEFAULT 1,
	future_entries bigint NOT NULL DEFAULT 0,
	intranet_access smallint NOT NULL DEFAULT 1,
	internet_access smallint NOT NULL DEFAULT 1,
	paging_allowed smallint NOT NULL DEFAULT 0,
	varian_user smallint DEFAULT 0
) ;
ALTER  TABLE ws_user_settings OWNER TO scd_testuser;
ALTER TABLE ws_user_settings ADD PRIMARY KEY (userid);
ALTER TABLE ws_user_settings ALTER COLUMN INTRANET_ACCESS SET NOT NULL;
ALTER TABLE ws_user_settings ALTER COLUMN INTERNET_ACCESS SET NOT NULL;
ALTER TABLE ws_user_settings ALTER COLUMN PAGING_ALLOWED SET NOT NULL;
ALTER TABLE ws_user_settings ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE ws_user_settings ALTER COLUMN ALLOWED_RESULTS_PER_MONTH SET NOT NULL;
ALTER TABLE ws_user_settings ALTER COLUMN MAX_RESULT_COUNT SET NOT NULL;
ALTER TABLE ws_user_settings ALTER COLUMN BLOCKSONEXPIREDATE SET NOT NULL;
ALTER TABLE ws_user_settings ALTER COLUMN FUTURE_ENTRIES SET NOT NULL;


CREATE TABLE wx_clients (
	partner_id varchar(128) NOT NULL,
	issuer varchar(128) NOT NULL,
	userid varchar(128) NOT NULL,
	certid varchar(12) NOT NULL,
	service varchar(20) NOT NULL,
	internal smallint NOT NULL DEFAULT 0,
	expiration_date timestamp
) ;
ALTER  TABLE wx_clients OWNER TO scd_testuser;
ALTER TABLE wx_clients ALTER COLUMN PARTNER_ID SET NOT NULL;
ALTER TABLE wx_clients ALTER COLUMN ISSUER SET NOT NULL;
ALTER TABLE wx_clients ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE wx_clients ALTER COLUMN CERTID SET NOT NULL;
ALTER TABLE wx_clients ALTER COLUMN SERVICE SET NOT NULL;
ALTER TABLE wx_clients ALTER COLUMN INTERNAL SET NOT NULL;


CREATE TABLE wx_clients_bak (
	partner_id varchar(128) NOT NULL,
	issuer varchar(128) NOT NULL,
	userid varchar(128) NOT NULL,
	certid varchar(12) NOT NULL,
	service varchar(20) NOT NULL,
	internal smallint NOT NULL
) ;
ALTER  TABLE wx_clients_bak OWNER TO scd_testuser;
ALTER TABLE wx_clients_bak ALTER COLUMN PARTNER_ID SET NOT NULL;
ALTER TABLE wx_clients_bak ALTER COLUMN ISSUER SET NOT NULL;
ALTER TABLE wx_clients_bak ALTER COLUMN USERID SET NOT NULL;
ALTER TABLE wx_clients_bak ALTER COLUMN CERTID SET NOT NULL;
ALTER TABLE wx_clients_bak ALTER COLUMN SERVICE SET NOT NULL;
ALTER TABLE wx_clients_bak ALTER COLUMN INTERNAL SET NOT NULL;
ALTER TABLE app_config ADD CONSTRAINT fk_app_config_app_id FOREIGN KEY (app_id) REFERENCES app(app_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE ap_delivery ADD CONSTRAINT fk_ap_delivery_ap_user FOREIGN KEY (user_id) REFERENCES ap_user(user_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE ap_exporter ADD CONSTRAINT fk_ap_exporter_ap_scheduler FOREIGN KEY (scheduler_id) REFERENCES ap_scheduler(scheduler_id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE ap_exporter ADD CONSTRAINT fk_ap_exporter_ap_user FOREIGN KEY (user_id) REFERENCES ap_user(user_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE ap_exporter_log ADD CONSTRAINT fk_ap_exporter_log_ap_delivery FOREIGN KEY (delivery_id) REFERENCES ap_delivery(delivery_id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE ap_exporter_log ADD CONSTRAINT fk_ap_exporter_log_ap_exporter FOREIGN KEY (exporter_id) REFERENCES ap_exporter(exporter_id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE ap_scheduler ADD CONSTRAINT fk_ap_scheduler_ap_delivery FOREIGN KEY (delivery_id) REFERENCES ap_delivery(delivery_id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE ap_scheduler ADD CONSTRAINT fk_ap_scheduler_ap_user FOREIGN KEY (user_id) REFERENCES ap_user(user_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE ap_supp_data ADD CONSTRAINT fk_ap_supp_data_delivery_id FOREIGN KEY (delivery_id) REFERENCES ap_delivery(delivery_id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE ap_supp_metadata ADD CONSTRAINT fk_ap_supp_mdata_delivery_id FOREIGN KEY (delivery_id) REFERENCES ap_delivery(delivery_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE gc_case ADD CONSTRAINT fk_gc_case_run_data_id FOREIGN KEY (run_data_id) REFERENCES gc_run_data(run_data_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE gc_country ADD CONSTRAINT fk_gc_country_lead_country_id FOREIGN KEY (lead_country_id) REFERENCES gc_country(country_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE gc_country ADD CONSTRAINT fk_gc_country_user_id FOREIGN KEY (user_id) REFERENCES gc_user(user_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE gc_email_template ADD CONSTRAINT fk_gc_email_template_user_id FOREIGN KEY (user_id) REFERENCES gc_user(user_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE gc_escalation ADD CONSTRAINT fk_gc_escalation_email_tpl_id FOREIGN KEY (email_template_id) REFERENCES gc_email_template(template_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE gc_escalation ADD CONSTRAINT fk_gc_escalation_user_id FOREIGN KEY (user_id) REFERENCES gc_user(user_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE gc_escalation_cases ADD CONSTRAINT fk_gc_escalation_cases_case_id FOREIGN KEY (case_id) REFERENCES gc_case(case_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE gc_escalation_cases ADD CONSTRAINT fk_gc_escalation_cases_esc_id FOREIGN KEY (escalation_id) REFERENCES gc_escalation(escalation_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE gc_query ADD CONSTRAINT fk_gc_query_err_notif_tpl_id FOREIGN KEY (error_notif_template_id) REFERENCES gc_email_template(template_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE gc_query ADD CONSTRAINT fk_gc_query_notif_tpl_id FOREIGN KEY (notification_template_id) REFERENCES gc_email_template(template_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE gc_query ADD CONSTRAINT fk_gc_query_succ_notif_tpl_id FOREIGN KEY (success_notif_template_id) REFERENCES gc_email_template(template_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE gc_query ADD CONSTRAINT fk_gc_query_user_id FOREIGN KEY (user_id) REFERENCES gc_user(user_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE gc_run ADD CONSTRAINT fk_gc_run_query_id FOREIGN KEY (query_id) REFERENCES gc_query(query_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE gc_run ADD CONSTRAINT fk_gc_run_started_by_user_id FOREIGN KEY (started_by_user_id) REFERENCES gc_user(user_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE gc_run_data ADD CONSTRAINT fk_gc_run_data_run_id FOREIGN KEY (run_id) REFERENCES gc_run(run_id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_additional_properties ADD CONSTRAINT md_additional_properties__fk1 FOREIGN KEY (connection_id_fk) REFERENCES md_connections(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_applicationfiles ADD CONSTRAINT md_file_app_fk FOREIGN KEY (applications_id_fk) REFERENCES md_applications(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_applications ADD CONSTRAINT md_app_proj_fk FOREIGN KEY (project_id_fk) REFERENCES md_projects(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_catalogs ADD CONSTRAINT md_catalogs_md_connection_fk1 FOREIGN KEY (connection_id_fk) REFERENCES md_connections(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_columns ADD CONSTRAINT md_columns_md_tables_fk1 FOREIGN KEY (table_id_fk) REFERENCES md_tables(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_connections ADD CONSTRAINT md_connections_md_project_fk1 FOREIGN KEY (project_id_fk) REFERENCES md_projects(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_constraints ADD CONSTRAINT md_constraints_md_tables_fk1 FOREIGN KEY (table_id_fk) REFERENCES md_tables(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_constraint_details ADD CONSTRAINT md_constraint_details_md__fk1 FOREIGN KEY (constraint_id_fk) REFERENCES md_constraints(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE md_constraint_details ADD CONSTRAINT md_constraint_details_md__fk2 FOREIGN KEY (column_id_fk) REFERENCES md_columns(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_derivatives ADD CONSTRAINT md_derivatives_md_connect_fk1 FOREIGN KEY (derived_connection_id_fk) REFERENCES md_connections(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_file_artifacts ADD CONSTRAINT md_artifact_file_fk FOREIGN KEY (applicationfiles_id) REFERENCES md_applicationfiles(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_groups ADD CONSTRAINT md_groups_md_schemas_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_group_members ADD CONSTRAINT md_groupmembers_md_groups_fk1 FOREIGN KEY (group_id_fk) REFERENCES md_groups(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE md_group_members ADD CONSTRAINT md_groupmembers_md_groups_fk2 FOREIGN KEY (group_member_id_fk) REFERENCES md_groups(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE md_group_members ADD CONSTRAINT md_groupmembers_md_users_fk1 FOREIGN KEY (user_id_fk) REFERENCES md_users(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_group_privileges ADD CONSTRAINT md_group_privileges_md_gr_fk1 FOREIGN KEY (group_id_fk) REFERENCES md_groups(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE md_group_privileges ADD CONSTRAINT md_group_privileges_md_pr_fk1 FOREIGN KEY (privilege_id_fk) REFERENCES md_privileges(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_indexes ADD CONSTRAINT md_indexes_md_tables_fk1 FOREIGN KEY (table_id_fk) REFERENCES md_tables(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_index_details ADD CONSTRAINT md_index_details_md_colum_fk1 FOREIGN KEY (column_id_fk) REFERENCES md_columns(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE md_index_details ADD CONSTRAINT md_index_details_md_index_fk1 FOREIGN KEY (index_id_fk) REFERENCES md_indexes(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_migr_dependency ADD CONSTRAINT migr_dependency_fk FOREIGN KEY (connection_id_fk) REFERENCES md_connections(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_migr_parameter ADD CONSTRAINT migr_parameter_fk FOREIGN KEY (connection_id_fk) REFERENCES md_connections(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_migr_weakdep ADD CONSTRAINT migr_weakdep_fk1 FOREIGN KEY (connection_id_fk) REFERENCES md_connections(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE md_migr_weakdep ADD CONSTRAINT migr_weakdep_fk2 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_other_objects ADD CONSTRAINT md_other_objects_md_schem_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_packages ADD CONSTRAINT md_packages_md_schemas_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_partitions ADD CONSTRAINT md_partitions_md_tables_fk1 FOREIGN KEY (table_id_fk) REFERENCES md_tables(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_privileges ADD CONSTRAINT md_privileges_md_schemas_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_schemas ADD CONSTRAINT md_schemas_md_catalogs_fk1 FOREIGN KEY (catalog_id_fk) REFERENCES md_catalogs(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_sequences ADD CONSTRAINT md_sequences_md_schemas_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_stored_programs ADD CONSTRAINT md_stored_programs_md_pac_fk1 FOREIGN KEY (package_id_fk) REFERENCES md_packages(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE md_stored_programs ADD CONSTRAINT md_stored_programs_md_sch_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_synonyms ADD CONSTRAINT md_synonyms_md_schemas_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_tables ADD CONSTRAINT md_tables_md_schemas_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_tablespaces ADD CONSTRAINT md_tablespaces_md_schemas_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_users ADD CONSTRAINT md_users_md_schemas_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_user_defined_data_types ADD CONSTRAINT md_user_defined_data_type_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_user_privileges ADD CONSTRAINT md_user_privileges_md_pri_fk1 FOREIGN KEY (privilege_id_fk) REFERENCES md_privileges(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE md_user_privileges ADD CONSTRAINT md_user_privileges_md_use_fk1 FOREIGN KEY (user_id_fk) REFERENCES md_users(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE md_views ADD CONSTRAINT md_views_md_schemas_fk1 FOREIGN KEY (schema_id_fk) REFERENCES md_schemas(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE migrlog ADD CONSTRAINT migr_migrlog_fk FOREIGN KEY (parent_log_id) REFERENCES migrlog(id) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE migr_datatype_transform_map ADD CONSTRAINT migr_datatype_transform_m_fk1 FOREIGN KEY (project_id_fk) REFERENCES md_projects(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE migr_datatype_transform_rule ADD CONSTRAINT migr_datatype_transform_r_fk1 FOREIGN KEY (map_id_fk) REFERENCES migr_datatype_transform_map(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE migr_generation_order ADD CONSTRAINT migr_generation_order_md__fk1 FOREIGN KEY (connection_id_fk) REFERENCES md_connections(id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE ws_colgroup_column_ids ADD CONSTRAINT ws_colgroup_column_ids_cgr_fk FOREIGN KEY (colgroupid) REFERENCES ws_column_groups(colgroupid) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE ws_colgroup_column_ids ADD CONSTRAINT ws_colgroup_column_ids_col_fk FOREIGN KEY (columnid) REFERENCES ws_column_names(columnid) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE ws_userid_clientid ADD CONSTRAINT ws_user_settings_clientid_fk FOREIGN KEY (userid) REFERENCES ws_user_settings(userid) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE ws_user_colgroup_ids ADD CONSTRAINT ws_user_colgroup_fk FOREIGN KEY (colgroupid) REFERENCES ws_column_groups(colgroupid) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;

ALTER TABLE ws_user_colgroup_ids ADD CONSTRAINT ws_user_colgroup_ids_user_fk FOREIGN KEY (userid) REFERENCES ws_user_settings(userid) ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;



SET client_encoding TO 'UTF8';

SET search_path = vrt,oracle,public;

SET check_function_bodies = false;

CREATE OR REPLACE VIEW vrt.scd AS SELECT * FROM vrt.scd_2;
ALTER VIEW vrt.scd OWNER TO scd_testuser;
CREATE OR REPLACE VIEW vrt.scdx AS SELECT * FROM vrt.scdx_1;
ALTER VIEW vrt.scdx OWNER TO scd_testuser;





/* Section 4.1.1 - CFG Table Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';


SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS cfg;
ALTER SCHEMA cfg OWNER TO scd_testuser;

SET search_path = cfg,oracle,public;


CREATE TABLE app_roles (
	role_name varchar(30) NOT NULL,
	app_id bigint,
	app_name varchar(100) NOT NULL
) ;
ALTER  TABLE app_roles OWNER TO scd_testuser;
ALTER TABLE app_roles ADD PRIMARY KEY (role_name,app_name);
ALTER TABLE app_roles ALTER COLUMN ROLE_NAME SET NOT NULL;
ALTER TABLE app_roles ALTER COLUMN APP_NAME SET NOT NULL;


CREATE TABLE app_role_clientid (
	role_name varchar(40) NOT NULL,
	role_attr varchar(40),
	clientid bigint NOT NULL,
	app_id bigint NOT NULL,
	app_name varchar(100) NOT NULL
) ;
ALTER  TABLE app_role_clientid OWNER TO scd_testuser;
ALTER TABLE app_role_clientid ADD UNIQUE (role_name,role_attr,clientid);
ALTER TABLE app_role_clientid ALTER COLUMN CLIENTID SET NOT NULL;
ALTER TABLE app_role_clientid ALTER COLUMN ROLE_NAME SET NOT NULL;
ALTER TABLE app_role_clientid ALTER COLUMN APP_ID SET NOT NULL;
ALTER TABLE app_role_clientid ALTER COLUMN APP_NAME SET NOT NULL;


CREATE TABLE app_role_map (
	user_id char(8) NOT NULL,
	role_name varchar(30) NOT NULL,
	role_attr varchar(128) NOT NULL,
	app_id bigint,
	reason varchar(4000),
	app_name varchar(100) NOT NULL
) ;
ALTER  TABLE app_role_map OWNER TO scd_testuser;
CREATE UNIQUE INDEX app_role_map_pk ON app_role_map (user_id, role_name, role_attr, app_name);
ALTER TABLE app_role_map ADD PRIMARY KEY (user_id,role_attr,role_name,app_name);
ALTER TABLE app_role_map ALTER COLUMN ROLE_ATTR SET NOT NULL;
ALTER TABLE app_role_map ALTER COLUMN ROLE_NAME SET NOT NULL;
ALTER TABLE app_role_map ALTER COLUMN USER_ID SET NOT NULL;
ALTER TABLE app_role_map ALTER COLUMN APP_NAME SET NOT NULL;


CREATE TABLE app_users (
	user_id char(8) NOT NULL,
	disabled smallint NOT NULL DEFAULT 0
) ;
ALTER  TABLE app_users OWNER TO scd_testuser;
ALTER TABLE app_users ADD PRIMARY KEY (user_id);
ALTER TABLE app_users ALTER COLUMN DISABLED SET NOT NULL;
ALTER TABLE app_users ALTER COLUMN USER_ID SET NOT NULL;


/* CFG Synonymous Creation - Section 4.1.2 */


SET client_encoding TO 'UTF8';

SET search_path = cfg,oracle,public;

SET check_function_bodies = false;

CREATE OR REPLACE VIEW cfg.konfig AS SELECT * FROM sds.konfig;
ALTER VIEW cfg.konfig OWNER TO scd_testuser;
CREATE OR REPLACE VIEW cfg.liefnt AS SELECT * FROM sds.liefnt;
ALTER VIEW cfg.liefnt OWNER TO scd_testuser;
CREATE OR REPLACE VIEW cfg.mesg AS SELECT * FROM sds.mesg;
ALTER VIEW cfg.mesg OWNER TO scd_testuser;




/* Section 4.6 - CFG Triggers Creation */


-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = cfg,oracle,public;

SET check_function_bodies = false;

DROP TRIGGER IF EXISTS app_role_map_app_id ON app_role_map CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_app_role_map_app_id() RETURNS trigger AS $BODY$
BEGIN
  UPDATE APP_ROLE_MAP ARM SET APP_ID = (SELECT APP_ID FROM VRT.APP A WHERE A.NAME = ARM.APP_NAME);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_app_role_map_app_id() FROM PUBLIC;

ALTER FUNCTION trigger_fct_app_role_map_app_id() OWNER TO scd_testuser;

CREATE TRIGGER app_role_map_app_id
	AFTER INSERT ON app_role_map FOR EACH STATEMENT
	EXECUTE PROCEDURE trigger_fct_app_role_map_app_id();



/* Section 5.1 - SCD Table Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';


SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS scd;
ALTER SCHEMA scd OWNER TO scd_testuser;

SET search_path = scd,oracle,public;


CREATE TABLE gid_priv_chcm (
	gid char(8),
	mailpriv varchar(120),
	mobilepriv varchar(40)
) ;
ALTER  TABLE gid_priv_chcm OWNER TO scd_testuser;


CREATE TABLE orgids (
	c char(2),
	o varchar(16),
	ou varchar(16),
	l varchar(16),
	gid char(8),
	sn varchar(40),
	givenname varchar(40),
	usertype char(1),
	recordtype char(1),
	status char(1),
	costlocationunit char(4),
	costlocation char(8),
	orgid char(8),
	orgid_neu char(8)
) ;
ALTER  TABLE orgids OWNER TO scd_testuser;


/* Section 6.1 - Stat Table Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';


SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS stat;
ALTER SCHEMA stat OWNER TO scd_testuser;

SET search_path = stat,oracle,public;


CREATE TABLE anzahl_ds_scd_pro_monat (
	datum timestamp,
	anzahl bigint,
	clientid bigint
) ;
ALTER  TABLE anzahl_ds_scd_pro_monat OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixanzahl_ds_scd_pro_monat ON anzahl_ds_scd_pro_monat (datum, clientid);


CREATE TABLE anzahl_ds_scd_pro_tag (
	datum timestamp,
	anzahl bigint,
	clientid bigint
) ;
ALTER  TABLE anzahl_ds_scd_pro_tag OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixanzahl_ds_scd_pro_tag ON anzahl_ds_scd_pro_tag (datum, clientid);


CREATE TABLE calendar (
	day_id timestamp,
	day_time_span bigint,
	day_end_date timestamp,
	day_num_of_week bigint,
	day_num_of_month bigint,
	day_num_of_year bigint,
	week_day_full varchar(40),
	week_day_short varchar(8),
	month_id varchar(20),
	month_time_span bigint,
	month_end_date timestamp,
	month_short_desc varchar(20),
	month_long_desc varchar(60),
	month_short varchar(16),
	month_long varchar(40),
	month_num_of_year bigint,
	quarter_id varchar(8),
	quarter_time_span bigint,
	quarter_end_date timestamp,
	quarter_num_of_year bigint,
	year_id char(4),
	year_time_span bigint,
	year_end_date timestamp,
	fiscal_year varchar(12),
	sort varchar(12)
) ;
ALTER  TABLE calendar OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixcalendar ON calendar (day_id);


CREATE TABLE luz_apache (
	datum timestamp NOT NULL DEFAULT statement_timestamp(),
	last_7_days bigint,
	last_month bigint
) ;
ALTER  TABLE luz_apache OWNER TO scd_testuser;
ALTER TABLE luz_apache ALTER COLUMN DATUM SET NOT NULL;


CREATE TABLE querydat (
	shadow varchar(64),
	port numeric(38),
	typ char(4),
	datevon timestamp,
	timevon numeric(38),
	datebis timestamp,
	timebis numeric(38),
	anz numeric(38),
	anzok numeric(38),
	dns numeric(38),
	ip varchar(16),
	ping numeric(38),
	ldapreply numeric(38),
	ldaprows numeric(38),
	ldapsize numeric(38),
	mesg char(10),
	lang char(2)
) ;
ALTER  TABLE querydat OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixquerydat ON querydat (datevon, timevon, shadow, port, typ);


CREATE TABLE scd_feldinhalte (
	c char(2),
	o varchar(255),
	ou varchar(255),
	mailadressen bigint,
	scdid bigint,
	telefon bigint,
	telefon2 bigint,
	telefax bigint,
	handy bigint,
	zertifikate bigint,
	pgp bigint,
	x509 bigint,
	rs bigint,
	pki1 bigint,
	pki2 bigint,
	anzahleintraege bigint,
	anzahlhaupteintraege bigint,
	anzahlzusatzeintraege bigint,
	clientid bigint
) ;
ALTER  TABLE scd_feldinhalte OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixscd_feldinhalte ON scd_feldinhalte (c, o, ou, clientid);


CREATE TABLE scd_tagesstatistik (
	datum timestamp,
	eintraege bigint,
	scdids bigint,
	telefon bigint,
	telefax bigint,
	handy bigint,
	mailadressen bigint,
	zertifikate bigint,
	pgp bigint,
	x509 bigint,
	geliefertedaten bigint,
	eingetragenedaten bigint,
	clientid bigint
) ;
ALTER  TABLE scd_tagesstatistik OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixscd_tagesstatistik ON scd_tagesstatistik (datum, clientid);


CREATE TABLE shadow (
	name varchar(64),
	port numeric(38),
	protocol varchar(64),
	url varchar(255),
	txt varchar(255),
	use char(4)
) ;
ALTER  TABLE shadow OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixshadow ON shadow (name, port);


CREATE TABLE sla_auswertung (
	typ varchar(4),
	jahr varchar(4),
	monat varchar(2),
	von timestamp,
	bis timestamp,
	anzahl bigint,
	noping bigint,
	ldap0 bigint,
	ldap1 bigint,
	ldap2 bigint,
	ldap10 bigint,
	ldaperr bigint,
	http0 bigint,
	http1 bigint,
	http2 bigint,
	http10 bigint,
	httperr bigint
) ;
ALTER  TABLE sla_auswertung OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixsla_auswertung ON sla_auswertung (typ, jahr, monat);


CREATE TABLE statistik_are (
	are varchar(255),
	anz_i bigint,
	anz_x bigint,
	anz_t bigint,
	clientid smallint
) ;
ALTER  TABLE statistik_are OWNER TO scd_testuser;


CREATE TABLE statistik_gid (
	zeitraum timestamp,
	geschaeftsjahr varchar(10),
	gesamtanzahl_gids bigint,
	gesamtanz_akt_u_zukunft bigint,
	gid_neuvergaben bigint,
	gesamtanzahl_bisherige_nutzer bigint,
	confirmgid bigint,
	deletegidentry bigint,
	forcenewgid bigint,
	getgid bigint,
	getgidbykey bigint,
	getnewgid bigint,
	getnewgidbatch bigint,
	getnewgidex bigint,
	getnewgidnotowner bigint,
	searchforentries bigint,
	updategidentry bigint,
	updategiduseronly bigint,
	summemethoden bigint,
	updategidcurrent bigint,
	clientid bigint
) ;
ALTER  TABLE statistik_gid OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixstatistik_gid ON statistik_gid (zeitraum, clientid);


CREATE TABLE statistik_gid_new__del (
	zeitraum timestamp,
	geschaeftsjahr varchar(10),
	gesamtanzahl_gids bigint,
	gesamtanz_akt_u_zukunft bigint,
	gid_neuvergaben bigint,
	gesamtanzahl_bisherige_nutzer bigint,
	confirmgid bigint,
	deletegidentry bigint,
	forcenewgid bigint,
	getgid bigint,
	getgidbykey bigint,
	getnewgid bigint,
	getnewgidbatch bigint,
	getnewgidex bigint,
	getnewgidnotowner bigint,
	searchforentries bigint,
	updategidentry bigint,
	updategiduseronly bigint,
	summemethoden bigint,
	updategidcurrent bigint,
	clientid bigint
) ;
ALTER  TABLE statistik_gid_new__del OWNER TO scd_testuser;


CREATE TABLE statistik_laender (
	c char(2),
	c_name_intern varchar(64),
	c_name_national varchar(64),
	anzahl_i bigint,
	anzahl_x bigint,
	anzahl_t bigint,
	clientid bigint
) ;
ALTER  TABLE statistik_laender OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixstatistik_laender ON statistik_laender (c, clientid);


CREATE TABLE statistik_scd (
	zeitraum timestamp,
	gj varchar(10),
	zugriffe_standard bigint,
	byte_standard bigint,
	zugriffe_eldap bigint,
	byte_eldap bigint,
	pgp1 bigint,
	pgp2 bigint,
	pgp3 bigint,
	pgp4 bigint,
	pgp5 bigint,
	pgp6 bigint,
	pgp7 bigint,
	pgp8 bigint,
	scdlogin bigint,
	anzahl_anwendungen_scdlogin bigint,
	pkilogin bigint,
	anzahl_anwendungen_pkilogin bigint,
	scd_pki_login_kunden bigint,
	gelieferte_daten bigint,
	eingetragene_daten bigint,
	mw_durchsatz_datenpruefung bigint,
	max_durchsatz_datenpruefung bigint,
	mw_durchsatz_mak bigint,
	max_durchsatz_mak bigint,
	revocationlist_anzahl bigint,
	revocationlist_bytes bigint
) ;
ALTER  TABLE statistik_scd OWNER TO scd_testuser;
CREATE UNIQUE INDEX ixstatistik_scd ON statistik_scd (zeitraum);



/*Section 6.4 - STAT Procedures Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = stat,oracle,public;

SET check_function_bodies = false;





CREATE OR REPLACE PROCEDURE stat.querydat_v ( von timestamp , bis timestamp ) AS $body$
DECLARE

  CC CURSOR FOR
  SELECT 	Shadow,	Port,	Typ,
--
	Trunc(Min(DateVon)),		   	Trunc(TimeVon/60/60) * '6 days'::interval0*60,
	Trunc(Max(DateBis))+1-1/24/60/60,  	Trunc(TimeVon/60/60) * '6 days'::interval0*60+60*60-1,
	Sum(Anz),	Sum(AnzOK),
	Avg(DNS),  IP,	Avg(Ping),
	Avg(LDAPReply),	Avg(LDAPRows),	Avg(LDAPSize),
--
	NULL,	NULL		from	QueryDat
  where	 DateVon >=	von
  and	 DateBis <	bis
  group	 by		Shadow,	Port,	Typ,	IP,
	Trunc(TimeVon/60/60) * '6 days'::interval0*60,		Trunc(TimeVon/60/60) * '6 days'::interval0*60+60*60-1	;

  procedure	VV	is
  row	QueryDat%rowtype;

BEGIN
  fetch	CC	into	row;
  if NOT FOUND then	delete	from	QueryDat
	where	DateVon >=	von
	and	DateBis <	bis;
  else	VV;
	insert	into	QueryDat
	values	(row.*);
  end	if;
  end;

  begin	 open	CC;
  VV;	close	CC;
  commit work;
  end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER PROCEDURE stat.querydat_v ( von timestamp , bis timestamp ) OWNER TO scd_testuser;
-- REVOKE ALL ON PROCEDURE stat.querydat_v ( von timestamp , bis timestamp ) FROM PUBLIC;







/* Section 7.1 - TCG Table Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';


SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS tcg;
ALTER SCHEMA tcg OWNER TO scd_testuser;

SET search_path = tcg,oracle,public;


CREATE TABLE pa_blob_config (
	key varchar(30) NOT NULL,
	next_refresh timestamp NOT NULL,
	content bytea NOT NULL
) ;
ALTER  TABLE pa_blob_config OWNER TO scd_testuser;
ALTER TABLE pa_blob_config ADD PRIMARY KEY (key);
ALTER TABLE pa_blob_config ALTER COLUMN NEXT_REFRESH SET NOT NULL;
ALTER TABLE pa_blob_config ALTER COLUMN CONTENT SET NOT NULL;


CREATE TABLE pa_circle (
	pa_circle_id bigint NOT NULL,
	pa_circle_name varchar(50) NOT NULL
) ;
ALTER  TABLE pa_circle OWNER TO scd_testuser;
ALTER TABLE pa_circle ADD UNIQUE (pa_circle_name);
ALTER TABLE pa_circle ADD PRIMARY KEY (pa_circle_id);
ALTER TABLE pa_circle ALTER COLUMN PA_CIRCLE_NAME SET NOT NULL;
ALTER TABLE pa_circle ALTER COLUMN PA_CIRCLE_ID SET NOT NULL;


CREATE TABLE pa_faq (
	locale varchar(5),
	content text
) ;
ALTER  TABLE pa_faq OWNER TO scd_testuser;


CREATE TABLE pa_file (
	pa_file_id bigint NOT NULL,
	pa_file_name varchar(255) NOT NULL,
	pa_file_type varchar(100) NOT NULL,
	pa_file_data bytea NOT NULL,
	pa_file_language varchar(2) NOT NULL,
	pa_file_extension varchar(10),
	pa_file_size bigint GENERATED ALWAYS AS (LENGTH(PA_FILE_DATA)) STORED
) ;
ALTER  TABLE pa_file OWNER TO scd_testuser;
ALTER TABLE pa_file ADD PRIMARY KEY (pa_file_id);
ALTER TABLE pa_file ADD UNIQUE (pa_file_name,pa_file_language);
ALTER TABLE pa_file ALTER COLUMN PA_FILE_LANGUAGE SET NOT NULL;
ALTER TABLE pa_file ALTER COLUMN PA_FILE_DATA SET NOT NULL;
ALTER TABLE pa_file ALTER COLUMN PA_FILE_TYPE SET NOT NULL;
ALTER TABLE pa_file ALTER COLUMN PA_FILE_NAME SET NOT NULL;
ALTER TABLE pa_file ALTER COLUMN PA_FILE_ID SET NOT NULL;


CREATE TABLE pa_file_circle (
	pa_file bigint NOT NULL,
	pa_circle bigint NOT NULL
) ;
ALTER  TABLE pa_file_circle OWNER TO scd_testuser;
ALTER TABLE pa_file_circle ADD UNIQUE (pa_circle,pa_file);
ALTER TABLE pa_file_circle ALTER COLUMN PA_CIRCLE SET NOT NULL;
ALTER TABLE pa_file_circle ALTER COLUMN PA_FILE SET NOT NULL;


CREATE TABLE pa_file_group (
	pa_file bigint NOT NULL,
	pa_group bigint NOT NULL
) ;
ALTER  TABLE pa_file_group OWNER TO scd_testuser;
ALTER TABLE pa_file_group ADD UNIQUE (pa_file,pa_group);
ALTER TABLE pa_file_group ALTER COLUMN PA_GROUP SET NOT NULL;
ALTER TABLE pa_file_group ALTER COLUMN PA_FILE SET NOT NULL;


CREATE TABLE pa_file_juper (
	pa_file bigint NOT NULL,
	pa_juper bigint NOT NULL
) ;
ALTER  TABLE pa_file_juper OWNER TO scd_testuser;
ALTER TABLE pa_file_juper ADD UNIQUE (pa_file,pa_juper);
ALTER TABLE pa_file_juper ALTER COLUMN PA_JUPER SET NOT NULL;
ALTER TABLE pa_file_juper ALTER COLUMN PA_FILE SET NOT NULL;


CREATE TABLE pa_group (
	pa_group_id bigint NOT NULL,
	pa_group_name varchar(50) NOT NULL
) ;
ALTER  TABLE pa_group OWNER TO scd_testuser;
ALTER TABLE pa_group ADD PRIMARY KEY (pa_group_id);
ALTER TABLE pa_group ADD UNIQUE (pa_group_name);
ALTER TABLE pa_group ALTER COLUMN PA_GROUP_NAME SET NOT NULL;
ALTER TABLE pa_group ALTER COLUMN PA_GROUP_ID SET NOT NULL;


CREATE TABLE pa_juper (
	pa_juper_id bigint NOT NULL,
	pa_juper_name varchar(50) NOT NULL
) ;
ALTER  TABLE pa_juper OWNER TO scd_testuser;
ALTER TABLE pa_juper ADD PRIMARY KEY (pa_juper_id);
ALTER TABLE pa_juper ADD UNIQUE (pa_juper_name);
ALTER TABLE pa_juper ALTER COLUMN PA_JUPER_NAME SET NOT NULL;
ALTER TABLE pa_juper ALTER COLUMN PA_JUPER_ID SET NOT NULL;


CREATE TABLE pa_role (
	pa_role_id bigint NOT NULL,
	pa_role_name varchar(50) NOT NULL
) ;
ALTER  TABLE pa_role OWNER TO scd_testuser;
ALTER TABLE pa_role ADD PRIMARY KEY (pa_role_id);
ALTER TABLE pa_role ADD UNIQUE (pa_role_name);
ALTER TABLE pa_role ALTER COLUMN PA_ROLE_NAME SET NOT NULL;
ALTER TABLE pa_role ALTER COLUMN PA_ROLE_ID SET NOT NULL;


CREATE TABLE pa_tresor (
	pa_tresor_id bigint NOT NULL,
	pa_tresor_user_gid varchar(8) NOT NULL,
	pa_tresor_type bigint NOT NULL,
	pa_tresor_date timestamp NOT NULL
) ;
ALTER  TABLE pa_tresor OWNER TO scd_testuser;
ALTER TABLE pa_tresor ADD PRIMARY KEY (pa_tresor_id);
ALTER TABLE pa_tresor ALTER COLUMN PA_TRESOR_DATE SET NOT NULL;
ALTER TABLE pa_tresor ALTER COLUMN PA_TRESOR_TYPE SET NOT NULL;
ALTER TABLE pa_tresor ALTER COLUMN PA_TRESOR_USER_GID SET NOT NULL;
ALTER TABLE pa_tresor ALTER COLUMN PA_TRESOR_ID SET NOT NULL;


CREATE TABLE pa_upload_document_types (
	label_key varchar(50) NOT NULL,
	ma_gruppen varchar(150) NOT NULL,
	ma_kreise varchar(150) NOT NULL,
	juper varchar(150) NOT NULL,
	id bigint NOT NULL,
	gruppen_kreise varchar(200),
	label_de varchar(200),
	label_en varchar(200),
	label_es varchar(200),
	label_fr varchar(200),
	label_pt varchar(200),
	sort bigint
) ;
ALTER  TABLE pa_upload_document_types OWNER TO scd_testuser;
ALTER TABLE pa_upload_document_types ADD PRIMARY KEY (id);
ALTER TABLE pa_upload_document_types ALTER COLUMN ID SET NOT NULL;
ALTER TABLE pa_upload_document_types ALTER COLUMN JUPER SET NOT NULL;
ALTER TABLE pa_upload_document_types ALTER COLUMN MA_KREISE SET NOT NULL;
ALTER TABLE pa_upload_document_types ALTER COLUMN MA_GRUPPEN SET NOT NULL;
ALTER TABLE pa_upload_document_types ALTER COLUMN LABEL_KEY SET NOT NULL;


CREATE TABLE pa_user (
	pa_user_id bigint NOT NULL,
	pa_user_gid varchar(8) NOT NULL,
	pa_user_givenname varchar(20) NOT NULL,
	pa_user_surname varchar(20) NOT NULL
) ;
ALTER  TABLE pa_user OWNER TO scd_testuser;
ALTER TABLE pa_user ADD UNIQUE (pa_user_gid);
ALTER TABLE pa_user ADD PRIMARY KEY (pa_user_id);
ALTER TABLE pa_user ALTER COLUMN PA_USER_SURNAME SET NOT NULL;
ALTER TABLE pa_user ALTER COLUMN PA_USER_GIVENNAME SET NOT NULL;
ALTER TABLE pa_user ALTER COLUMN PA_USER_GID SET NOT NULL;
ALTER TABLE pa_user ALTER COLUMN PA_USER_ID SET NOT NULL;


CREATE TABLE pa_user_role (
	pa_user_role_id bigint NOT NULL,
	pa_user bigint NOT NULL,
	pa_role bigint NOT NULL
) ;
ALTER  TABLE pa_user_role OWNER TO scd_testuser;
ALTER TABLE pa_user_role ADD UNIQUE (pa_user,pa_role);
ALTER TABLE pa_user_role ADD PRIMARY KEY (pa_user_role_id);
ALTER TABLE pa_user_role ALTER COLUMN PA_ROLE SET NOT NULL;
ALTER TABLE pa_user_role ALTER COLUMN PA_USER SET NOT NULL;
ALTER TABLE pa_user_role ALTER COLUMN PA_USER_ROLE_ID SET NOT NULL;

/* End of Tables Schemas Creation */








/* Section 2.2 - VRT Types Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = vrt,oracle,public;

SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS vrt;


CREATE TYPE namelist AS (namelist varchar(40)[]);
ALTER TYPE namelist OWNER TO scd_testuser;


CREATE TYPE name_and_count_t AS (
OBJECT_NAME varchar(30),
  UPDATE_COUNT integer
);
ALTER TYPE name_and_count_t OWNER TO scd_testuser;

CREATE TYPE objectidlist AS (objectidlist integer[]);
ALTER TYPE objectidlist OWNER TO scd_testuser;

CREATE TYPE name_and_count_array AS (name_and_count_array name_and_count_t[30]);
ALTER TYPE name_and_count_array OWNER TO scd_testuser;



CREATE TYPE migr_filter AS (
FILTER_TYPE integer, -- Filter Types are 0-> ALL, 1->NAMELIST, 2->WHERE CLAUSE, 3->OBJECTID LIST
  OBJTYPE varchar(40),
  OBJECTIDS OBJECTIDLIST,
  NAMES NAMELIST,
  WHERECLAUSE varchar(1000)
);
ALTER TYPE migr_filter OWNER TO scd_testuser;

CREATE TYPE migr_filter_set AS (migr_filter_set MIGR_FILTER[]);
ALTER TYPE migr_filter_set OWNER TO scd_testuser;

CREATE TYPE migr_report_detail_row AS (
CAPTURED_ID            numeric(38),
  CAPTURED_NAME          varchar(4000),
  CONVERTED_NAME          varchar(4000),
  CAPTURED_TYPE          varchar(4000),
  CONVERTED_TYPE          varchar(4000),
  CAPTURE_STATUS         varchar(20),
  CONVERT_STATUS         varchar(20),
  GENERATE_STATUS        varchar(20),
  LOGTEXT               varchar(4000)
 
);
ALTER TYPE migr_report_detail_row OWNER TO scd_testuser;

CREATE TYPE migr_report_sum_row AS (
LABEL           varchar(50),
	    SCHEMA_SUM      bigint,
        TABLE_SUM       bigint,
		INDEX_SUM       bigint,
		CONSTRAINT_SUM  bigint,
		VIEW_SUM        bigint,
		TRIGGER_SUM     bigint,
		SP_SUM          bigint		
        
);
ALTER TYPE migr_report_sum_row OWNER TO scd_testuser;

CREATE TYPE migr_report_sum_table AS (migr_report_sum_table MIGR_REPORT_SUM_ROW[]);
ALTER TYPE migr_report_sum_table OWNER TO scd_testuser;


/* Section 1.3 - SDS Sequences Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = sds,oracle,public;

SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS sds;
CREATE SEQUENCE batch_job_execution_seq INCREMENT 1 MINVALUE 0 MAXVALUE 9223372036854775807 START 16402 CACHE 20;
ALTER SEQUENCE batch_job_execution_seq OWNER TO scd_testuser;
CREATE SEQUENCE batch_job_seq INCREMENT 1 MINVALUE 0 MAXVALUE 9223372036854775807 START 16731 CACHE 20;
ALTER SEQUENCE batch_job_seq OWNER TO scd_testuser;
CREATE SEQUENCE batch_step_execution_seq INCREMENT 1 MINVALUE 0 MAXVALUE 9223372036854775807 START 59296 CACHE 20;
ALTER SEQUENCE batch_step_execution_seq OWNER TO scd_testuser;
CREATE SEQUENCE bpr_exclude_rule_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1 CACHE 20;
ALTER SEQUENCE bpr_exclude_rule_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE bpr_gids_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1732324 CACHE 20;
ALTER SEQUENCE bpr_gids_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE bpr_konfig_rule_nr_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 41 CACHE 20;
ALTER SEQUENCE bpr_konfig_rule_nr_sequence OWNER TO scd_testuser;
CREATE SEQUENCE bpr_status_fiona_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 922878 CACHE 20;
ALTER SEQUENCE bpr_status_fiona_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE fits_events_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 5708883 CACHE 20;
ALTER SEQUENCE fits_events_seq OWNER TO scd_testuser;
CREATE SEQUENCE fits_trigger_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 3814763 CACHE 20;
ALTER SEQUENCE fits_trigger_seq OWNER TO scd_testuser;
CREATE SEQUENCE ggw_chart_data_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 381 CACHE 20;
ALTER SEQUENCE ggw_chart_data_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_gid_batch_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 381 CACHE 20;
ALTER SEQUENCE ggw_gid_batch_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_job_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 461 CACHE 20;
ALTER SEQUENCE ggw_job_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_log_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 421 CACHE 20;
ALTER SEQUENCE ggw_log_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_method_count_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 301511620 CACHE 20;
ALTER SEQUENCE ggw_method_count_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_properties_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 381 CACHE 20;
ALTER SEQUENCE ggw_properties_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_report_config_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 381 CACHE 20;
ALTER SEQUENCE ggw_report_config_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_rfc_servers_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 381 CACHE 20;
ALTER SEQUENCE ggw_rfc_servers_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_role_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 381 CACHE 20;
ALTER SEQUENCE ggw_role_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_user_id_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 381 CACHE 20;
ALTER SEQUENCE ggw_user_id_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ggw_user_role_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 381 CACHE 20;
ALTER SEQUENCE ggw_user_role_sequence OWNER TO scd_testuser;
CREATE SEQUENCE konfig_log_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1 CACHE 20;
ALTER SEQUENCE konfig_log_seq OWNER TO scd_testuser;
CREATE SEQUENCE request_id_seq INCREMENT 1 MINVALUE 10000000 MAXVALUE 99999999 START 10072351 CACHE 20;
ALTER SEQUENCE request_id_seq OWNER TO scd_testuser;
CREATE SEQUENCE scd_data_request_seq INCREMENT 1 MINVALUE 10000000 MAXVALUE 99999999 START 10001080 CACHE 20;
ALTER SEQUENCE scd_data_request_seq OWNER TO scd_testuser;
CREATE SEQUENCE seq_bookmarked_employees INCREMENT 1 MINVALUE 1 MAXVALUE 2147483647 START 10140;
ALTER SEQUENCE seq_bookmarked_employees OWNER TO scd_testuser;
CREATE SEQUENCE seq_webui_user_settings INCREMENT 1 MINVALUE 1 MAXVALUE 999999999999999 START 2 CACHE 20;
ALTER SEQUENCE seq_webui_user_settings OWNER TO scd_testuser;
CREATE SEQUENCE webui_countries_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 481 CACHE 20;
ALTER SEQUENCE webui_countries_seq OWNER TO scd_testuser;
CREATE SEQUENCE write INCREMENT 1 MINVALUE 1 NO MAXVALUE START 19586979494 CACHE 20;
ALTER SEQUENCE write OWNER TO scd_testuser;



/* Section 2.3 - VRT Sequences Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = vrt,oracle,public;

SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS vrt;
CREATE SEQUENCE app_config_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1280 CACHE 20;
ALTER SEQUENCE app_config_sequence OWNER TO scd_testuser;
CREATE SEQUENCE app_sequence INCREMENT 2 MINVALUE 1 NO MAXVALUE START 804 CACHE 20;
ALTER SEQUENCE app_sequence OWNER TO scd_testuser;
CREATE SEQUENCE app_user_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 161 CACHE 20;
ALTER SEQUENCE app_user_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ap_delivery_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 2575 CACHE 20;
ALTER SEQUENCE ap_delivery_seq OWNER TO scd_testuser;
CREATE SEQUENCE ap_exporter_log_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 86708 CACHE 20;
ALTER SEQUENCE ap_exporter_log_seq OWNER TO scd_testuser;
CREATE SEQUENCE ap_exporter_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 2613 CACHE 20;
ALTER SEQUENCE ap_exporter_seq OWNER TO scd_testuser;
CREATE SEQUENCE ap_scheduler_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 2531 CACHE 20;
ALTER SEQUENCE ap_scheduler_seq OWNER TO scd_testuser;
CREATE SEQUENCE ap_supp_data_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 41518374 CACHE 20;
ALTER SEQUENCE ap_supp_data_seq OWNER TO scd_testuser;
CREATE SEQUENCE ap_supp_metadata_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 191 CACHE 20;
ALTER SEQUENCE ap_supp_metadata_seq OWNER TO scd_testuser;
CREATE SEQUENCE ap_user_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1 CACHE 20;
ALTER SEQUENCE ap_user_seq OWNER TO scd_testuser;
CREATE SEQUENCE as_billing_id_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1 CACHE 20;
ALTER SEQUENCE as_billing_id_seq OWNER TO scd_testuser;
CREATE SEQUENCE dbobjectid_sequence INCREMENT 50 MINVALUE 1 NO MAXVALUE START 1 CACHE 50;
ALTER SEQUENCE dbobjectid_sequence OWNER TO scd_testuser;
CREATE SEQUENCE gc_case_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 171072 CACHE 20;
ALTER SEQUENCE gc_case_sequence OWNER TO scd_testuser;
CREATE SEQUENCE gc_country_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 6227 CACHE 20;
ALTER SEQUENCE gc_country_sequence OWNER TO scd_testuser;
CREATE SEQUENCE gc_email_template_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 21 CACHE 20;
ALTER SEQUENCE gc_email_template_sequence OWNER TO scd_testuser;
CREATE SEQUENCE gc_escalation_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 223 CACHE 20;
ALTER SEQUENCE gc_escalation_sequence OWNER TO scd_testuser;
CREATE SEQUENCE gc_query_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 21 CACHE 20;
ALTER SEQUENCE gc_query_sequence OWNER TO scd_testuser;
CREATE SEQUENCE gc_run_data_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1684767 CACHE 20;
ALTER SEQUENCE gc_run_data_sequence OWNER TO scd_testuser;
CREATE SEQUENCE gc_run_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 4307 CACHE 20;
ALTER SEQUENCE gc_run_sequence OWNER TO scd_testuser;
CREATE SEQUENCE tippderwoche_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 843 CACHE 20;
ALTER SEQUENCE tippderwoche_seq OWNER TO scd_testuser;
CREATE SEQUENCE ws_audit_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 2561748540 CACHE 20;
ALTER SEQUENCE ws_audit_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ws_colgroup_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 51101 CACHE 20;
ALTER SEQUENCE ws_colgroup_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ws_exportdata_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 103530 CACHE 20;
ALTER SEQUENCE ws_exportdata_sequence OWNER TO scd_testuser;
CREATE SEQUENCE ws_user_columns_sequence INCREMENT 1 MINVALUE 1 NO MAXVALUE START 14995 CACHE 20;
ALTER SEQUENCE ws_user_columns_sequence OWNER TO scd_testuser;


/* Section 5.3 - SCD Sequences Creation */

SET client_encoding TO 'UTF8';

SET search_path = scd,oracle,public;

SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS scd;
CREATE SEQUENCE seq_last_viewed_employees INCREMENT 1 MINVALUE 1 NO MAXVALUE START 2518667 CACHE 20;
ALTER SEQUENCE seq_last_viewed_employees OWNER TO scd_testuser;
CREATE SEQUENCE seq_webui_user_settings INCREMENT 1 MINVALUE 1 NO MAXVALUE START 149005 CACHE 20;
ALTER SEQUENCE seq_webui_user_settings OWNER TO scd_testuser;


/* Section 7.3 - TCG Sequences Creation */


SET client_encoding TO 'UTF8';

SET search_path = tcg,oracle,public;

SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS tcg;
CREATE SEQUENCE pa_circle_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1514 CACHE 20;
ALTER SEQUENCE pa_circle_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_file_circle_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1394 CACHE 20;
ALTER SEQUENCE pa_file_circle_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_file_group_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1756 CACHE 20;
ALTER SEQUENCE pa_file_group_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_file_juper_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 4510 CACHE 20;
ALTER SEQUENCE pa_file_juper_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_file_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1011 CACHE 20;
ALTER SEQUENCE pa_file_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_group_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1916 CACHE 20;
ALTER SEQUENCE pa_group_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_juper_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 5971 CACHE 20;
ALTER SEQUENCE pa_juper_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_role_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1 CACHE 20;
ALTER SEQUENCE pa_role_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_tresor_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 126877 CACHE 20;
ALTER SEQUENCE pa_tresor_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_user_role_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1 CACHE 20;
ALTER SEQUENCE pa_user_role_seq OWNER TO scd_testuser;
CREATE SEQUENCE pa_user_seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1 CACHE 20;
ALTER SEQUENCE pa_user_seq OWNER TO scd_testuser;






/* Section 1.4 - SDS Procedure Creation */


-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = sds,oracle,public;

SET check_function_bodies = false;





CREATE OR REPLACE PROCEDURE sds.ggw_method_count_v ( von timestamp , bis timestamp ) AS $body$
DECLARE

  CC CURSOR FOR
  SELECT 	Min(id),	Sum(counter),	von,	method,	requestor,	u_id	from	GGW_METHOD_COUNT
  where	 event_date >=	von
  and	 event_date <	bis
  group	 by	method,	requestor,	u_id;

  procedure	VV	is
  row	GGW_METHOD_COUNT%rowtype;

BEGIN
  fetch	CC	into	row;
  if NOT FOUND then	delete	from	GGW_METHOD_COUNT
	where	event_date >=	von
	and	event_date <	bis;
  else	VV;
	insert	into	GGW_METHOD_COUNT
	values	(row.*);
  end	if;
  end;

  begin	 open	CC;
  VV;	close	CC;
  commit work;
  end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER PROCEDURE sds.ggw_method_count_v ( von timestamp , bis timestamp ) OWNER TO scd_testuser;
-- REVOKE ALL ON PROCEDURE sds.ggw_method_count_v ( von timestamp , bis timestamp ) FROM PUBLIC;






CREATE OR REPLACE PROCEDURE sds.refresh_user_clientid () AS $body$
BEGIN

    BEGIN
        EXECUTE 'DROP MATERIALIZED VIEW SDS.USER_CLIENTID';
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
     END;

     BEGIN
        EXECUTE 'DROP MATERIALIZED VIEW SDS.USER_CLIENTID_FUTURE';
        EXCEPTION
            WHEN OTHERS THEN
                NULL;
     END;

    BEGIN
      EXECUTE 'CREATE MATERIALIZED VIEW USER_CLIENTID 
      AS
      SELECT users.gid, d.c, d.o, d.ou, d.l, NVL(d."CLIENT_ID", 1) AS "client_id", d.clientname, d.rank FROM gid_user users LEFT JOIN 
    (SELECT t.gid, 
            t.c, 
            t.o, 
            t.ou,
            t.l, 
            t.rank,
            CASE WHEN sal.clientid IS NOT null THEN sal.clientid
                ELSE 
                    CASE WHEN clientidperorganization.co > 1 THEN 1 
                         WHEN clientidperorganization.co is null THEN 1 
                         WHEN clientidperorganization.co = 0 THEN 1 
                         ELSE organizationclientid.oc
                    END
                END	
            AS "CLIENT_ID",
            s.clientname        

        FROM (SELECT gid, c, o, ou, l, valid_date, leave_date, delete_date, RANK() OVER 
                 (PARTITION BY gid  order by 
                     CASE 
                          WHEN to_char(valid_date, ''DD/MM/YYYY'') = to_char(sysdate, ''DD/MM/YYYY'') THEN 0
                          WHEN valid_date < sysdate AND (leave_date > sysdate OR to_char(leave_date, ''DD/MM/YYYY'') = to_char(sysdate, ''DD/MM/YYYY'') )THEN 1                        
                          WHEN valid_date > sysdate THEN 2
                          WHEN valid_date < sysdate THEN 3
                          WHEN valid_date is null THEN 4
                          ELSE 5
                        END , valid_date desc , rowid desc) AS rank FROM gid_data WHERE delete_date is null) t

        LEFT JOIN (select c, o ,ou, l, clientid, MAX(typ) FROM stmgendn GROUP BY c, o, ou, l, clientid) sal  
            ON t.c = sal.c AND t.o = sal.o AND t.ou = sal.ou AND t.l = sal.l

        LEFT JOIN (select o, COUNT(distinct(clientid)) AS co FROM stmgendn GROUP BY o) clientidperorganization ON clientidperorganization.o = t.o

        LEFT JOIN (select o,  MAX(clientid) oc FROM stmgendn WHERE clientid IS NOT null GROUP BY o ) organizationclientid ON t.o = organizationclientid.o 

        LEFT JOIN STMGEN s ON s.c = t.c and s.o = t.o and s.ou = t.ou and s.l = t.l

        WHERE t.delete_date IS NULL
    ) d ON d.gid = users.gid';

    END;

    BEGIN
      EXECUTE 'CREATE MATERIALIZED VIEW USER_CLIENTID_FUTURE 
      AS
      SELECT users.gid, d.c, d.o, d.ou, d.l, NVL(d."CLIENT_ID", 1) AS "client_id", d.clientname, d.rank FROM gid_user users LEFT JOIN 
    (SELECT t.gid, 
            t.c, 
            t.o, 
            t.ou,
            t.l, 
            t.rank,

            CASE WHEN sal.clientid IS NOT null THEN sal.clientid
                ELSE 
                    CASE WHEN clientidperorganization.co > 1 THEN 1 
                         WHEN clientidperorganization.co is null THEN 1 
                         WHEN clientidperorganization.co = 0 THEN 1 
                         ELSE organizationclientid.oc
                    END
                END	

            AS "CLIENT_ID",
            s.clientname        

        FROM (SELECT gid, c, o, ou, l, valid_date, leave_date, delete_date, RANK() OVER 
                 (PARTITION BY gid  order by 
                     CASE 
                          WHEN to_char(valid_date, ''DD/MM/YYYY'') = to_char(sysdate, ''DD/MM/YYYY'') THEN 1
                          WHEN valid_date < sysdate THEN 2                        
                          WHEN valid_date > sysdate THEN 0
                          WHEN valid_date is null THEN 3
                          ELSE 4
                        END , valid_date desc , rowid desc) AS rank FROM gid_data WHERE delete_date is null) t

        LEFT JOIN (select c, o ,ou, l, clientid, MAX(typ) FROM stmgendn GROUP BY c, o, ou, l, clientid) sal  
            ON t.c = sal.c AND t.o = sal.o AND t.ou = sal.ou AND t.l = sal.l

        LEFT JOIN (select o, COUNT(distinct(clientid)) AS co FROM stmgendn GROUP BY o) clientidperorganization ON clientidperorganization.o = t.o

        LEFT JOIN (select o,  MAX(clientid) oc FROM stmgendn WHERE clientid IS NOT null GROUP BY o ) organizationclientid ON t.o = organizationclientid.o 

        LEFT JOIN STMGEN s ON s.c = t.c and s.o = t.o and s.ou = t.ou and s.l = t.l

        WHERE t.delete_date IS NULL
    ) d ON d.gid = users.gid';

    END;



    BEGIN
      EXECUTE 'CREATE INDEX USER_CLIENTID_INDEX_C ON USER_CLIENTID (C ASC) 
                        LOGGING 
                        TABLESPACE DATA 
                        PCTFREE 10 
                        INITRANS 2 
                        STORAGE 
                        ( 
                          INITIAL 65536 
                          NEXT 1048576 
                          MINEXTENTS 1 
                          MAXEXTENTS UNLIMITED 
                          BUFFER_POOL DEFAULT 
                        ) 
                        NOPARALLEL';
    END;

    BEGIN
        EXECUTE '
            CREATE INDEX USER_CLIENTID_INDEX_GID ON USER_CLIENTID (GID ASC) 
            LOGGING 
            TABLESPACE DATA 
            PCTFREE 10 
            INITRANS 2 
            STORAGE 
            ( 
              INITIAL 65536 
              NEXT 1048576 
              MINEXTENTS 1 
              MAXEXTENTS UNLIMITED 
              BUFFER_POOL DEFAULT 
            ) 
            NOPARALLEL';
    END;

    BEGIN
        EXECUTE '
            CREATE INDEX USER_CLIENTID_INDEX_L ON USER_CLIENTID (L ASC) 
            LOGGING 
            TABLESPACE DATA 
            PCTFREE 10 
            INITRANS 2 
            STORAGE 
            ( 
              INITIAL 65536 
              NEXT 1048576 
              MINEXTENTS 1 
              MAXEXTENTS UNLIMITED 
              BUFFER_POOL DEFAULT 
            ) 
            NOPARALLEL';
    END;

    BEGIN
        EXECUTE '
            CREATE INDEX USER_CLIENTID_INDEX_O ON USER_CLIENTID (O ASC) 
            LOGGING 
            TABLESPACE DATA 
            PCTFREE 10 
            INITRANS 2 
            STORAGE 
            ( 
              INITIAL 65536 
              NEXT 1048576 
              MINEXTENTS 1 
              MAXEXTENTS UNLIMITED 
              BUFFER_POOL DEFAULT 
            ) 
            NOPARALLEL';
    END;

    BEGIN
        EXECUTE '
            CREATE INDEX USER_CLIENTID_INDEX_OU ON USER_CLIENTID (OU ASC) 
            LOGGING 
            TABLESPACE DATA 
            PCTFREE 10 
            INITRANS 2 
            STORAGE 
            ( 
              INITIAL 65536 
              NEXT 1048576 
              MINEXTENTS 1 
              MAXEXTENTS UNLIMITED 
              BUFFER_POOL DEFAULT 
            ) 
            NOPARALLEL';
    END;




      BEGIN
      EXECUTE 'CREATE INDEX USER_CLIENTID_FUTURE_INDEX_C ON USER_CLIENTID_FUTURE (C ASC) 
                        LOGGING 
                        TABLESPACE DATA 
                        PCTFREE 10 
                        INITRANS 2 
                        STORAGE 
                        ( 
                          INITIAL 65536 
                          NEXT 1048576 
                          MINEXTENTS 1 
                          MAXEXTENTS UNLIMITED 
                          BUFFER_POOL DEFAULT 
                        ) 
                        NOPARALLEL';
    END;

    BEGIN
        EXECUTE '
            CREATE INDEX USER_CLIENTID_FUTURE_INDEX_GID ON USER_CLIENTID_FUTURE (GID ASC) 
            LOGGING 
            TABLESPACE DATA 
            PCTFREE 10 
            INITRANS 2 
            STORAGE 
            ( 
              INITIAL 65536 
              NEXT 1048576 
              MINEXTENTS 1 
              MAXEXTENTS UNLIMITED 
              BUFFER_POOL DEFAULT 
            ) 
            NOPARALLEL';
    END;

    BEGIN
        EXECUTE '
            CREATE INDEX USER_CLIENTID_FUTURE_INDEX_L ON USER_CLIENTID_FUTURE (L ASC) 
            LOGGING 
            TABLESPACE DATA 
            PCTFREE 10 
            INITRANS 2 
            STORAGE 
            ( 
              INITIAL 65536 
              NEXT 1048576 
              MINEXTENTS 1 
              MAXEXTENTS UNLIMITED 
              BUFFER_POOL DEFAULT 
            ) 
            NOPARALLEL';
    END;

    BEGIN
        EXECUTE '
            CREATE INDEX USER_CLIENTID_FUTURE_INDEX_O ON USER_CLIENTID_FUTURE (O ASC) 
            LOGGING 
            TABLESPACE DATA 
            PCTFREE 10 
            INITRANS 2 
            STORAGE 
            ( 
              INITIAL 65536 
              NEXT 1048576 
              MINEXTENTS 1 
              MAXEXTENTS UNLIMITED 
              BUFFER_POOL DEFAULT 
            ) 
            NOPARALLEL';
    END;

    BEGIN
        EXECUTE '
            CREATE INDEX USER_CLIENTID_FUTURE_INDEX_OU ON USER_CLIENTID_FUTURE (OU ASC) 
            LOGGING 
            TABLESPACE DATA 
            PCTFREE 10 
            INITRANS 2 
            STORAGE 
            ( 
              INITIAL 65536 
              NEXT 1048576 
              MINEXTENTS 1 
              MAXEXTENTS UNLIMITED 
              BUFFER_POOL DEFAULT 
            ) 
            NOPARALLEL';
    END;

    BEGIN
        EXECUTE 'GRANT SELECT ON USER_CLIENTID TO VRT';
        EXECUTE 'GRANT SELECT ON USER_CLIENTID_FUTURE TO VRT';
    END;


END;
$body$
LANGUAGE PLPGSQL
;
ALTER PROCEDURE sds.refresh_user_clientid () OWNER TO scd_testuser;
-- REVOKE ALL ON PROCEDURE sds.refresh_user_clientid () FROM PUBLIC;





CREATE OR REPLACE PROCEDURE sds.snapref ( vTab text ) AS $body$
BEGIN
DBMS_SNAPSHOT.REFRESH(vTab);
END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER PROCEDURE sds.snapref ( vTab text ) OWNER TO scd_testuser;
-- REVOKE ALL ON PROCEDURE sds.snapref ( vTab text ) FROM PUBLIC;


/* Section 2.4 - VRT Procedure Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = vrt,oracle,public;

SET check_function_bodies = false;





CREATE OR REPLACE PROCEDURE vrt.ap9965_avature_update (vClientID integer) AS $body$
DECLARE


	vGidCount integer := 0;

	cr		varchar(1) := chr(13);
	crlf	varchar(2) := cr||chr(10);	


	/* Selection der Daten: muss genau mit der Query im AP Tool übereinstimmen */

	gelieferte_daten_cur CURSOR(clientIDParam integer)
    FOR
	SELECT gid AS gid 
		,sn AS surname 
		,givenname AS name 
		,mail AS email
		,costlocationunit AS are 
		,C AS country 
		,usertype AS employeetype 
		,contractstatus AS contractstatus 
		,substr(leavedate,7,2) || '/' || substr(leavedate,5,2) || '/' || substr(leavedate,1,4) AS exitdate 
		,'active' AS status 
        ,clientID as clientID
		FROM v_scd 
		WHERE usertype='X' 
        AND clientID=clientIDParam
		AND status='A' 
		AND recordtype='H' 
		AND firmstat='M' 
		AND (mail AND mail::text <> '') 
		AND contractstatus <> 'R' 
		AND (costlocationunit AND costlocationunit::text <> '')
        AND gid not in (SELECT gid from v_scd s where S.clientname = 'VARIAN' and S.notwebvisible like '1%')
		-- --------------------------------
		-- und noch nicht früher geliefert
		-- --------------------------------
		AND gid NOT IN (SELECT gid FROM AP9965_AVATURE WHERE status='active' and clientID=clientIDParam)
		-- -----------------------------------------------
		-- bereits früher geliefert, aber seitdem geändert
		-- -----------------------------------------------
		
UNION
 
		SELECT S.gid AS gid
		,S.sn  AS surname
		,S.givenname AS name
		,S.mail AS email
		,S.costlocationunit  AS are
		,S.C as country
		,S.usertype AS employeetype
		,S.contractstatus AS contractstatus
		,substr(leavedate,7,2) || '/' || substr(leavedate,5,2) || '/' || substr(leavedate,1,4)  as exitdate
		,'active' AS status
        ,S.clientID as clientID
		FROM AP9965_AVATURE B 
		LEFT JOIN v_scd S 
		ON B.gid=S.gid and B.clientID=S.clientID 
		WHERE 
		S.usertype='X' 
        AND S.clientID=clientIDParam
		AND S.status='A' 
		AND S.recordtype='H' 
		AND S.firmstat='M' 
		AND (S.mail AND S.mail::text <> '') 
		AND S.contractstatus <> 'R'  
		AND (costlocationunit AND costlocationunit::text <> '')
		AND ( 
		B.name <> S.givenname 
		OR B.surname <> S.sn 
		OR B.email <> S.mail 
		OR B.contractstatus <> S.contractstatus 
		OR B.exitdate <> substr(S.leavedate ,7,2) || '/' || substr(S.leavedate ,5,2) || '/' || substr(S.leavedate ,1,4)
		)
		-- ----------------------------------------------------------
		-- früher aktiv gemeldet, jetzt aber nicht mehr den 
		-- notwendigen Kriterien entsprechend (nicht mehr in ARE-Liste,
		-- Contractstatus "R=ruhend", Usertyp nicht "X=extern", "Gamesa"
		-- Mitarbeiter)
		-- oder für die GID ausschließlich historische Sätze existieren.
		-- 
		-- ----------------------------------------------------------
		
UNION

		SELECT B.gid 
		,B.surname
		,B.name
		,B.email
		,B.are
		,B.country
		,B.employeetype 
		,B.CONTRACTSTATUS
		,b.exitdate
		,'inactive' AS status
        ,S.clientID as clientID
		FROM AP9965_AVATURE B 
		LEFT JOIN v_scd S
		ON S.gid=B.gid AND S.clientID=B.clientID
		where B.status='active'
        AND S.clientID=clientIDParam
		AND S.recordtype='H' 
		AND (S.contractstatus AND S.contractstatus::text <> '')
		AND S.status <> 'F'
		AND (   S.status = 'A' AND (S.contractstatus = 'R' OR 
				S.usertype <> 'X') 
			OR ( S.status='H' AND S.gid NOT IN (SELECT gid FROM v_scd WHERE status = 'A' AND (gid AND gid::text <> '') AND clientID=clientIDParam)
			)
		)
		AND B.gid NOT IN (SELECT gid FROM v_scd WHERE usertype <> 'X' and clientID=clientIDParam)
		-- -------------------------------- 
		-- GIDs, die früher geliefert wurden aber jetzt im SCD unbekannt sind 
		-- -------------------------------- 
		
UNION
 
		SELECT B.gid 
		,B.surname 
		,B.name 
		,B.email 
		,B.are 
		,B.country 
		,B.employeetype 
		,B.CONTRACTSTATUS 
		,b.exitdate 
		,'inactive' as status 
        ,clientIDParam as clientID
		FROM AP9965_AVATURE B 
		WHERE status='active' AND 
        B.clientID=clientIDParam AND 
        gid NOT IN (SELECT gid FROM v_scd WHERE (gid AND gid::text <> '') AND clientID=clientIDParam)
		;


	gelieferte_daten   gelieferte_daten_cur%ROWTYPE;


	
BEGIN

    dbms_output.put_line(crlf|| 'Beginn AP9965_AVATURE tabelle ...');

	OPEN gelieferte_daten_cur(vClientID);

	dbms_output.put_line('Schleife über alle gelieferten Sätze ...');

	LOOP

        FETCH gelieferte_daten_cur INTO gelieferte_daten;
        EXIT WHEN NOT FOUND; /* apply on gelieferte_daten_cur */

		dbms_output.put_line('gid: ' || gelieferte_daten.gid || ' status: '  || gelieferte_daten.status );

		/* wenn GID nicht in der Basistabelle enthalten ist, dann aufnehmen */

		SELECT COUNT(gid) INTO STRICT vGidCount FROM AP9965_AVATURE WHERE gid= gelieferte_daten.gid;
		IF vGidCount = 0 THEN
			dbms_output.put_line('GID noch nicht in Basistabelle. Wird aufgenommen!');
			INSERT INTO AP9965_AVATURE(gid, surname, name, email,
			 are, country, employeetype, 
			 contractstatus, exitdate,status,clientID,
			 ts
			 )
			VALUES (gelieferte_daten.gid, gelieferte_daten.surname,gelieferte_daten.name, gelieferte_daten.email,
			gelieferte_daten.are, gelieferte_daten.country,gelieferte_daten.employeetype,
			gelieferte_daten.contractstatus, gelieferte_daten.exitdate,gelieferte_daten.status,gelieferte_daten.clientID,
			LOCALTIMESTAMP);
		END IF;

		/* wenn GID bereits in der Basistabelle enthalten ist, dann aktualisieren */

		IF vGidCount = 1 THEN
			dbms_output.put_line('GID bereits vorhanden. Update!');
			UPDATE AP9965_AVATURE
			  SET surname = gelieferte_daten.surname,
				  name  = gelieferte_daten.name,
				  email = gelieferte_daten.email,
				  are   = gelieferte_daten.are,
				  country = gelieferte_daten.country,
				  employeetype = gelieferte_daten.employeetype, 
				  contractstatus = gelieferte_daten.contractstatus, 
				  exitdate= gelieferte_daten.exitdate,
				  status= gelieferte_daten.status,
                  clientID=gelieferte_daten.clientID,
				  ts=LOCALTIMESTAMP
			WHERE gid=gelieferte_daten.gid;
		END IF;



	END LOOP;

	COMMIT;	
	CLOSE gelieferte_daten_cur;

	dbms_output.put_line(crlf|| 'Fertig AP9965_AVATURE Table!');

	END;
$body$
LANGUAGE PLPGSQL
;
ALTER PROCEDURE vrt.ap9965_avature_update (vClientID integer) OWNER TO scd_testuser;
-- REVOKE ALL ON PROCEDURE vrt.ap9965_avature_update (vClientID integer) FROM PUBLIC;





CREATE OR REPLACE PROCEDURE vrt.ap9965_update_basistabelle () AS $body$
DECLARE

   
    vNameAbfrage    varchar(100);
	vDeliveryIDinAP varchar(10);
	vGidCount integer := 0;
	vDBName  		varchar(50);


	vBoolInt integer;
	vDateMinus24h		timestamp;

	cr		varchar(1) := chr(13);
	crlf	varchar(2) := cr||chr(10);	

	/* Selection der Daten: muss genau mit der Query im AP Tool übereinstimmen */

	gelieferte_daten_cur CURSOR(vDeliveryIDInAP text)
    FOR
	SELECT gid AS gid 
		,sn AS surname 
		,givenname AS name 
		,mail AS email
		,costlocationunit AS are 
		,C AS country 
		,usertype AS employeetype 
		,contractstatus AS contractstatus 
		,substr(leavedate,7,2) || '/' || substr(leavedate,5,2) || '/' || substr(leavedate,1,4) AS exitdate 
		,'active' AS status 
		FROM v_scd 
		WHERE usertype='X' 
		AND status='A' 
		AND recordtype='H' 
		AND firmstat='M' 
		AND (mail AND mail::text <> '') 
		AND contractstatus <> 'R' 
		AND c||o NOT IN (SELECT c||o from sds.mandant_dn_mapping 
		where mandant = 'Gamesa') 
		AND costlocationunit IN (SELECT col1 FROM ap_supp_data WHERE delivery_id=vDeliveryIDInAP AND (col1 AND col1::text <> '')) 
		AND (costlocationunit AND costlocationunit::text <> '')
		-- --------------------------------
		-- und noch nicht früher geliefert
		-- --------------------------------
		AND gid NOT IN (SELECT gid FROM ap9965_basis WHERE status='active')
		-- -----------------------------------------------
		-- bereits früher geliefert, aber seitdem geändert
		-- -----------------------------------------------
		
UNION
 
		SELECT S.gid AS gid
		,S.sn  AS surname
		,S.givenname AS name
		,S.mail AS email
		,S.costlocationunit  AS are
		,S.C as country
		,S.usertype AS employeetype
		,S.contractstatus AS contractstatus
		,substr(leavedate,7,2) || '/' || substr(leavedate,5,2) || '/' || substr(leavedate,1,4)  as exitdate
		,'active' AS status
		FROM ap9965_basis B 
		LEFT JOIN v_scd S 
		ON B.gid=S.gid 
		WHERE 
		S.usertype='X' 
		AND S.status='A' 
		AND S.recordtype='H' 
		AND S.firmstat='M' 
		AND (S.mail AND S.mail::text <> '') 
		AND S.contractstatus <> 'R' 
		AND c||o NOT IN (select c||o from sds.mandant_dn_mapping 
		where mandant = 'Gamesa')
		AND costlocationunit IN (SELECT col1 FROM ap_supp_data WHERE delivery_id=vDeliveryIDInAP AND (col1 AND col1::text <> '')) 
		AND (costlocationunit AND costlocationunit::text <> '')
		AND ( 
		B.name <> S.givenname 
		OR B.surname <> S.sn 
		OR B.email <> S.mail 
		OR B.contractstatus <> S.contractstatus 
		OR B.exitdate <> substr(S.leavedate ,7,2) || '/' || substr(S.leavedate ,5,2) || '/' || substr(S.leavedate ,1,4)
		)
		-- ----------------------------------------------------------
		-- früher aktiv gemeldet, jetzt aber nicht mehr den 
		-- notwendigen Kriterien entsprechend (nicht mehr in ARE-Liste,
		-- Contractstatus "R=ruhend", Usertyp nicht "X=extern", "Gamesa"
		-- Mitarbeiter)
		-- oder für die GID ausschließlich historische Sätze existieren.
		-- 
		-- ----------------------------------------------------------
		
UNION

		SELECT B.gid 
		,B.surname
		,B.name
		,B.email
		,B.are
		,B.country
		,B.employeetype 
		,B.CONTRACTSTATUS
		,b.exitdate
		,'inactive' AS status
		FROM ap9965_basis B 
		LEFT JOIN v_scd S
		ON S.gid=B.gid
		where B.status='active'
		AND S.recordtype='H' 
		AND (S.contractstatus AND S.contractstatus::text <> '')
		AND S.status <> 'F'
		AND (   S.status = 'A' AND (S.contractstatus = 'R' OR 
				S.usertype <> 'X' OR 
				S.costlocationunit NOT IN ( SELECT col1 FROM ap_supp_data WHERE delivery_id=vDeliveryIDInAP AND (col1 AND col1::text <> '')) OR
				S.c || S.o IN (SELECT c||o from sds.mandant_dn_mapping where mandant = 'Gamesa') ) 
			OR ( S.status='H' AND S.gid NOT IN (SELECT gid FROM v_scd WHERE status = 'A' AND (gid AND gid::text <> ''))
			)
		)
		AND B.gid NOT IN (SELECT gid FROM v_scd WHERE usertype <> 'X')
		-- -------------------------------- 
		-- GIDs, die früher geliefert wurden aber jetzt im SCD unbekannt sind 
		-- -------------------------------- 
		
UNION
 
		SELECT B.gid 
		,B.surname 
		,B.name 
		,B.email 
		,B.are 
		,B.country 
		,B.employeetype 
		,B.CONTRACTSTATUS 
		,b.exitdate 
		,'inactive' as status 
		FROM ap9965_basis B 
		WHERE status='active' AND gid NOT IN (SELECT gid FROM scd WHERE (gid AND gid::text <> ''))
		;



	gelieferte_daten   gelieferte_daten_cur%ROWTYPE;


	
BEGIN

    dbms_output.put_line(crlf|| 'Beginn ap9965_update_basistabelle ...');

	SELECT sys_context('userenv','db_name') INTO STRICT vDBName;

	CASE vDBName
			WHEN 'sds_dev'  THEN vDeliveryIDInAP:= '';
			WHEN 'sds_qa'   THEN vDeliveryIDInAP:= '924';
			ELSE vDeliveryIDInAP:='813';
	END CASE;

	dbms_output.put_line(crlf|| 'DeliveryID in AP-Tool: ' || vDeliveryIDInAP);

	OPEN gelieferte_daten_cur(vDeliveryIDInAP);

	dbms_output.put_line('Schleife über alle gelieferten Sätze ...');

	LOOP

        FETCH gelieferte_daten_cur INTO gelieferte_daten;
        EXIT WHEN NOT FOUND; /* apply on gelieferte_daten_cur */

		dbms_output.put_line('gid: ' || gelieferte_daten.gid || ' status: '  || gelieferte_daten.status );

		/* wenn GID nicht in der Basistabelle enthalten ist, dann aufnehmen */

		SELECT COUNT(gid) INTO STRICT vGidCount FROM ap9965_basis WHERE gid= gelieferte_daten.gid;
		IF vGidCount = 0 THEN
			dbms_output.put_line('GID noch nicht in Basistabelle. Wird aufgenommen!');
			INSERT INTO ap9965_basis(gid, surname, name, email,
			 are, country, employeetype, 
			 contractstatus, exitdate,status,
			 ts
			 )
			VALUES (gelieferte_daten.gid, gelieferte_daten.surname,gelieferte_daten.name, gelieferte_daten.email,
			gelieferte_daten.are, gelieferte_daten.country,gelieferte_daten.employeetype,
			gelieferte_daten.contractstatus, gelieferte_daten.exitdate,gelieferte_daten.status,
			LOCALTIMESTAMP);
		END IF;

		/* wenn GID bereits in der Basistabelle enthalten ist, dann aktualisieren */

		IF vGidCount = 1 THEN
			dbms_output.put_line('GID bereits vorhanden. Update!');
			UPDATE ap9965_basis
			  SET surname = gelieferte_daten.surname,
				  name  = gelieferte_daten.name,
				  email = gelieferte_daten.email,
				  are   = gelieferte_daten.are,
				  country = gelieferte_daten.country,
				  employeetype = gelieferte_daten.employeetype, 
				  contractstatus = gelieferte_daten.contractstatus, 
				  exitdate= gelieferte_daten.exitdate,
				  status= gelieferte_daten.status,
				  ts=LOCALTIMESTAMP
			WHERE gid=gelieferte_daten.gid;
		END IF;



	END LOOP;

	COMMIT;	
	CLOSE gelieferte_daten_cur;

	dbms_output.put_line(crlf|| 'Fertig ap9965_update_basistabelle!');

	END;
$body$
LANGUAGE PLPGSQL
;
ALTER PROCEDURE vrt.ap9965_update_basistabelle () OWNER TO scd_testuser;
-- REVOKE ALL ON PROCEDURE vrt.ap9965_update_basistabelle () FROM PUBLIC;








CREATE OR REPLACE PROCEDURE vrt.clobfromblob () AS $body$
DECLARE

      l_clob         text;
      l_dest_offsset integer := 1;
      l_src_offsset  integer := 1;
      l_lang_context integer := dbms_lob.default_lang_ctx;
      l_warning      integer;
        p_blob bytea;
         l_offset bigint;

BEGIN

      select output into STRICT p_blob 
      from check_mon_exp_log
        where startexec = '2019-03-26 12:35:03';

      --if p_blob is null then
      --   return null;
      --end if;
      dbms_lob.createTemporary(lob_loc => l_clob
                              ,cache   => false);

      dbms_lob.converttoclob(dest_lob     => l_clob
                            ,src_blob     => p_blob
                            ,amount       => dbms_lob.lobmaxsize
                            ,dest_offset  => l_dest_offsset
                            ,src_offset   => l_src_offsset
                            ,blob_csid    => dbms_lob.default_csid
                            ,lang_context => l_lang_context
                            ,warning      => l_warning);

      -- return l_clob;
      l_offset:=1;
       loop
         exit when l_offset > octet_length(l_clob);
         dbms_output.put_line( substr(l_clob, l_offset , 255) );
         l_offset := l_offset + 255;
       end loop;

   end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER PROCEDURE vrt.clobfromblob () OWNER TO scd_testuser;
-- REVOKE ALL ON PROCEDURE vrt.clobfromblob () FROM PUBLIC;





CREATE OR REPLACE PROCEDURE vrt.printscheduleroutput (exectime text) AS $body$
DECLARE


/*  Print out the column OUTPUT of  view CHECK_MON_EXP_LOG.
    Parameter is value of column EXECTIME of the view.
    Before executing the procedure in call
        SET SERVEROUTPUT ON  SIZE 1000000;
    Example for procedure call:
        exec printscheduleroutput('2019-03-19 09:35:04'); 

	After every 255 chars a linefeed is added, so
	the output can look a bit strange!
*/
      l_clob         text;
      l_dest_offsset integer := 1;
      l_src_offsset  integer := 1;
      l_lang_context integer := dbms_lob.default_lang_ctx;
      l_warning      integer;
        p_blob bytea;
         l_offset bigint;

BEGIN

      select output into STRICT p_blob 
      from check_mon_exp_log
      where startexec = exectime;


      dbms_lob.createTemporary(lob_loc => l_clob
                              ,cache   => false);

      dbms_lob.converttoclob(dest_lob     => l_clob
                            ,src_blob     => p_blob
                            ,amount       => dbms_lob.lobmaxsize
                            ,dest_offset  => l_dest_offsset
                            ,src_offset   => l_src_offsset
                            ,blob_csid    => dbms_lob.default_csid
                            ,lang_context => l_lang_context
                            ,warning      => l_warning);

      -- return l_clob;
      l_offset:=1;
       loop
         exit when l_offset > octet_length(l_clob);
         dbms_output.put_line( substr(l_clob, l_offset , 255) );
         l_offset := l_offset + 255;
       end loop;

   end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER PROCEDURE vrt.printscheduleroutput (exectime text) OWNER TO scd_testuser;
-- REVOKE ALL ON PROCEDURE vrt.printscheduleroutput (exectime text) FROM PUBLIC;



/* Section 1.5 - SDS Function Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = sds,oracle,public;

SET check_function_bodies = false;






--  get attribute value from set
CREATE OR REPLACE FUNCTION sds.strword ( vals text , pos bigint ) RETURNS varchar AS $body$
DECLARE

  val	varchar(4096) := '!'|| vals ||'!';
  p0	bigint;
  p1	bigint;


BEGIN
  p0 := InStr(val, '!', 1, pos) + 1;
  p1 := InStr(val, '!', p0);
  RETURN  SubStr(val, p0, p1 - p0);

EXCEPTION
  WHEN	OTHERS	THEN	RETURN  NULL;
END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER FUNCTION sds.strword ( vals text , pos bigint ) OWNER TO scd_testuser;
-- REVOKE ALL ON FUNCTION sds.strword ( vals text , pos bigint ) FROM PUBLIC;


CREATE OR REPLACE FUNCTION sds.attchk ( atts text 		--  Name einer Attributmenge
 , vals text 		--  Attributwerte, durch '!' getrennt
 , msg text 		--  Basisschlüssel für Fehlermeldungen
 ) RETURNS varchar AS $body$
DECLARE

  att	AttrChk%ROWTYPE;
  val	varchar(1024);
  ret	varchar(4096);


BEGIN	FOR att  IN (
  SELECT * FROM AttrChk
    WHERE  Bez	=  atts
    AND	   Dat	=  atts
    ORDER  BY	FeldNr	)

  LOOP	val := StrWord(vals, att.FeldNr);
    ret := ret|| FldPrf(att, trim(both val), msg) ||'!';
    IF	Length(ret)  >	4000	THEN EXIT;
    END IF;
  END	LOOP;

  IF	coalesce(ret::text, '') = ''	THEN
    ret :=' '||atts||' '||msg|| '10!';
  END	IF;
  RETURN  ret;
END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER FUNCTION sds.attchk ( atts text 
 , vals text 
 , msg text 
 ) OWNER TO scd_testuser;
-- REVOKE ALL ON FUNCTION sds.attchk ( atts text  , vals text  , msg text  ) FROM PUBLIC;








/* Section 1.6 - SDS Trigger Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = sds,oracle,public;

SET check_function_bodies = false;

DROP TRIGGER IF EXISTS gid_data_log_v2 ON gid_data CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gid_data_log_v2() RETURNS trigger AS $BODY$
DECLARE
   v_operation  varchar(25);
   v_actdatetime timestamp;
   v_changedby varchar(128);
BEGIN

	-- CURRENT DATE
	SELECT CURRENT_TIMESTAMP INTO STRICT v_actdatetime;

	-- GET USER THAT MADE THE OPERATION (INSERT, DELETE, UPDATE)
    SELECT UPPER(SYS_CONTEXT('userenv','client_identifier')) INTO STRICT v_changedby;

    IF (coalesce(v_changedby::text, '') = '') THEN
        SELECT UPPER(sys_context( 'userenv', 'os_user' )) INTO STRICT v_changedby;
    END IF;

	-- INSERT TRIGGER
	IF TG_OP = 'INSERT' THEN
		v_operation :='insert';

		IF (NEW.valid_date AND NEW.valid_date::text <> '')
		THEN
		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'VALID_DATE',
            NULL,
            to_char(NEW.valid_date,'DD.MM.YYYY HH24:MI:SS'),
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.leave_date AND NEW.leave_date::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'LEAVE_DATE',
            NULL,
			to_char(NEW.leave_date,'DD.MM.YYYY HH24:MI:SS'),
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.user_type AND NEW.user_type::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'USER_TYPE',
            NULL,
			NEW.user_type, 
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.owner AND NEW.owner::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'OWNER',
            NULL,
			NEW.owner, 
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.join_date AND NEW.join_date::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'JOIN_DATE',
            NULL,
			to_char(NEW.join_date, 'DD.MM.YYYY HH24:MI:SS'),
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.sponsor AND NEW.sponsor::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'SPONSOR',
            NULL,
			NEW.sponsor, 
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.c AND NEW.c::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'C',
            NULL,
			NEW.c, 
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.o AND NEW.o::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'O',
            NULL,
			NEW.o, 
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.ou AND NEW.ou::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'OU',
            NULL,
			NEW.ou, 
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.l AND NEW.l::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'L',
            NULL,
			NEW.l, 
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.appl_internal_id AND NEW.appl_internal_id::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'APPL_INTERNAL_ID',
            NULL,
			NEW.appl_internal_id,
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.appl_name AND NEW.appl_name::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'APPL_NAME',
            NULL,
			NEW.appl_name,
            v_changedby, 
            'GID_DATA');
         END IF;

		IF (NEW.confirmed AND NEW.confirmed::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'CONFIRMED',
            NULL,
			NEW.confirmed,
            v_changedby, 
            'GID_DATA');
         END IF;

		IF (NEW.scd AND NEW.scd::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'SCD',
            NULL,
			NEW.scd,
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.isinscd AND NEW.isinscd::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'ISINSCD',
            NULL,
			NEW.isinscd,
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.delete_date AND NEW.delete_date::text <> '')
		THEN  			
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'DELETE_DATE',
            NULL,
			to_char(NEW.delete_date,'DD.MM.YYYY HH24:MI:SS'),
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.delete_uid AND NEW.delete_uid::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'DELETE_UID',
            NULL,
			NEW.delete_uid,
            v_changedby, 
            'GID_DATA');
        END IF;

		IF (NEW.modify_data_date AND NEW.modify_data_date::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'MODIFY_DATA_DATE',
            NULL,
			to_char(NEW.modify_data_date,'DD.MM.YYYY HH24:MI:SS'),
            v_changedby, 
            'GID_DATA');
         END IF;

		IF (NEW.modify_data_uid AND NEW.modify_data_uid::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'MODIFY_DATA_UID',
            NULL,
			NEW.modify_data_uid,
            v_changedby, 
            'GID_DATA');
         END IF;

		IF (NEW.confirm_date AND NEW.confirm_date::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'CONFIRM_DATE',
            NULL,
			to_char(NEW.confirm_date,'DD.MM.YYYY HH24:MI:SS'),            
            v_changedby, 
            'GID_DATA');
         END IF;

		IF (NEW.sync_date AND NEW.sync_date::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'SYNC_DATE',
            NULL,
			to_char(NEW.sync_date,'DD.MM.YYYY HH24:MI:SS'),            
            v_changedby, 
            'GID_DATA');
        END IF;

	END IF;

	-- DELETE TRIGGER
	IF TG_OP = 'DELETE' THEN
		v_operation :='delete';

		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'VALID_DATE',
            to_char(OLD.valid_date,'DD.MM.YYYY HH24:MI:SS'),
            NULL,
            v_changedby, 
            'GID_DATA');


        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'LEAVE_DATE',
			to_char(OLD.leave_date,'DD.MM.YYYY HH24:MI:SS'),
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'USER_TYPE',
			OLD.user_type, 
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'OWNER',
			OLD.owner, 
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'JOIN_DATE',
			to_char(OLD.join_date, 'DD.MM.YYYY HH24:MI:SS'),
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'SPONSOR',
			OLD.sponsor, 
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'C',
			OLD.c, 
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'O',
			OLD.o, 
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'OU',
			OLD.ou, 
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'L',
			OLD.l, 
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'APPL_INTERNAL_ID',
			OLD.appl_internal_id,
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'APPL_NAME',
			OLD.appl_name,
            NULL,
            v_changedby, 
            'GID_DATA');


        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'CONFIRMED',
			OLD.confirmed,
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'SCD',
			OLD.scd,
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'ISINSCD',
			OLD.isinscd,
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'DELETE_DATE',
			to_char(OLD.delete_date,'DD.MM.YYYY HH24:MI:SS'),
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'DELETE_UID',
			OLD.delete_uid,
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'MODIFY_DATA_DATE',
			to_char(OLD.modify_data_date,'DD.MM.YYYY HH24:MI:SS'),
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'MODIFY_DATA_UID',
			OLD.modify_data_uid,
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'CONFIRM_DATE',
            to_char(OLD.confirm_date,'DD.MM.YYYY HH24:MI:SS'),
            NULL,
            v_changedby, 
            'GID_DATA');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
        	v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'SYNC_DATE',
            to_char(OLD.sync_date,'DD.MM.YYYY HH24:MI:SS'),
            NULL,
            v_changedby, 
            'GID_DATA');
	END IF;

	-- UPDATE TRIGGER
	IF TG_OP = 'UPDATE' THEN
		v_operation :='update';

		IF ( 	
            OLD.user_type != NEW.user_type
			OR ( coalesce(OLD.user_type::text, '') = '' AND (NEW.user_type AND NEW.user_type::text <> ''))
			OR ( (OLD.user_type AND OLD.user_type::text <> '') AND coalesce(NEW.user_type::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'USER_TYPE',
               OLD.user_type,
               NEW.user_type,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
            OLD.owner != NEW.owner
			OR ( coalesce(OLD.owner::text, '') = '' AND (NEW.owner AND NEW.owner::text <> ''))
			OR ( (OLD.owner AND OLD.owner::text <> '') AND coalesce(NEW.owner::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'OWNER',
               OLD.owner,
               NEW.owner,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
            OLD.sponsor != NEW.sponsor
			OR ( coalesce(OLD.sponsor::text, '') = '' AND (NEW.sponsor AND NEW.sponsor::text <> ''))
			OR ( (OLD.sponsor AND OLD.sponsor::text <> '') AND coalesce(NEW.sponsor::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'SPONSOR',
               OLD.sponsor,
               NEW.sponsor,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
            OLD.c != NEW.c
			OR ( coalesce(OLD.c::text, '') = '' AND (NEW.c AND NEW.c::text <> ''))
			OR ( (OLD.c AND OLD.c::text <> '') AND coalesce(NEW.c::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'C',
               OLD.c,
               NEW.c,
               v_changedby, 
            'GID_DATA');
        END IF;
        	-- 
		IF ( 	
            OLD.o != NEW.o
			OR ( coalesce(OLD.o::text, '') = '' AND (NEW.o AND NEW.o::text <> ''))
			OR ( (OLD.o AND OLD.o::text <> '') AND coalesce(NEW.o::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'O',
               OLD.o,
               NEW.o,
               v_changedby, 
            'GID_DATA');
        END IF;
        	-- 
		IF ( 	
            OLD.ou != NEW.ou
			OR ( coalesce(OLD.ou::text, '') = '' AND (NEW.ou AND NEW.ou::text <> ''))
			OR ( (OLD.ou AND OLD.ou::text <> '') AND coalesce(NEW.ou::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'OU',
               OLD.ou,
               NEW.ou,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
            OLD.l != NEW.l
			OR ( coalesce(OLD.l::text, '') = '' AND (NEW.l AND NEW.l::text <> ''))
			OR ( (OLD.l AND OLD.l::text <> '') AND coalesce(NEW.l::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'L',
               OLD.l,
               NEW.l,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
			OLD.appl_internal_id != NEW.appl_internal_id
			OR ( coalesce(OLD.appl_internal_id::text, '') = '' AND (NEW.appl_internal_id AND NEW.appl_internal_id::text <> ''))
			OR ( (OLD.appl_internal_id AND OLD.appl_internal_id::text <> '') AND coalesce(NEW.appl_internal_id::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'APPL_INTERNAL_ID',
               OLD.appl_internal_id,
               NEW.appl_internal_id,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
			 OLD.appl_name != NEW.appl_name
			OR ( coalesce(OLD.appl_name::text, '') = '' AND (NEW.appl_name AND NEW.appl_name::text <> ''))
			OR ( (OLD.appl_name AND OLD.appl_name::text <> '') AND coalesce(NEW.appl_name::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'APPL_NAME',
               OLD.appl_name,
               NEW.appl_name,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
            OLD.confirmed != NEW.confirmed
			OR ( coalesce(OLD.confirmed::text, '') = '' AND (NEW.confirmed AND NEW.confirmed::text <> ''))
			OR ( (OLD.confirmed AND OLD.confirmed::text <> '') AND coalesce(NEW.confirmed::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'CONFIRMED',
               OLD.confirmed,
               NEW.confirmed,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
            OLD.scd != NEW.scd
			OR ( coalesce(OLD.scd::text, '') = '' AND (NEW.scd AND NEW.scd::text <> ''))
			OR ( (OLD.scd AND OLD.scd::text <> '') AND coalesce(NEW.scd::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'SCD',
               OLD.scd,
               NEW.scd,
               v_changedby, 
            'GID_DATA');
        END IF;

		IF ( 	
            OLD.isinscd != NEW.isinscd
			OR ( coalesce(OLD.isinscd::text, '') = '' AND (NEW.isinscd AND NEW.isinscd::text <> ''))
			OR ( (OLD.isinscd AND OLD.isinscd::text <> '') AND coalesce(NEW.isinscd::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'ISINSCD',
               OLD.isinscd,
               NEW.isinscd,
               v_changedby, 
            'GID_DATA');
        END IF;

		IF ( 	
            OLD.delete_uid != NEW.delete_uid
			OR ( coalesce(OLD.delete_uid::text, '') = '' AND (NEW.delete_uid AND NEW.delete_uid::text <> ''))
			OR ( (OLD.delete_uid AND OLD.delete_uid::text <> '') AND coalesce(NEW.delete_uid::text, '') = '') 
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'DELETE_UID',
               OLD.delete_uid,
               NEW.delete_uid,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
            OLD.modify_data_uid != NEW.modify_data_uid
			OR ( coalesce(OLD.modify_data_uid::text, '') = '' AND (NEW.modify_data_uid AND NEW.modify_data_uid::text <> ''))
			OR ( (OLD.modify_data_uid AND OLD.modify_data_uid::text <> '') AND coalesce(NEW.modify_data_uid::text, '') = '') 	
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'MODIFY_DATA_UID',
               OLD.modify_data_uid,
               NEW.modify_data_uid,
               v_changedby, 
            'GID_DATA');
        END IF;
        	--
		IF ( 	
			 OLD.valid_date != NEW.valid_date
			OR ( coalesce(OLD.valid_date::text, '') = '' AND (NEW.valid_date AND NEW.valid_date::text <> ''))
			OR ( (OLD.valid_date AND OLD.valid_date::text <> '') AND coalesce(NEW.valid_date::text, '') = '') 			
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'VALID_DATE',
			   to_char(OLD.valid_date,'DD.MM.YYYY HH24:MI:SS'),
			   to_char(NEW.valid_date,'DD.MM.YYYY HH24:MI:SS'),
               v_changedby, 
            'GID_DATA');
        END IF;
        	-- 		
		IF ( 	
			OLD.leave_date != NEW.leave_date
			OR ( coalesce(OLD.leave_date::text, '') = '' AND (NEW.leave_date AND NEW.leave_date::text <> ''))
			OR ( (OLD.leave_date AND OLD.leave_date::text <> '') AND coalesce(NEW.leave_date::text, '') = '')
		) THEN
            INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'LEAVE_DATE',
			   to_char(OLD.leave_date,'DD.MM.YYYY HH24:MI:SS'),
			   to_char(NEW.leave_date,'DD.MM.YYYY HH24:MI:SS'),
               v_changedby, 
            'GID_DATA');
        END IF;
        	-- 
		IF ( 	
			OLD.delete_date != NEW.delete_date
			OR ( coalesce(OLD.delete_date::text, '') = '' AND (NEW.delete_date AND NEW.delete_date::text <> ''))
			OR ( (OLD.delete_date AND OLD.delete_date::text <> '') AND coalesce(NEW.delete_date::text, '') = '')
		) THEN
            INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'DELETE_DATE',
			   to_char(OLD.delete_date,'DD.MM.YYYY HH24:MI:SS'),
			   to_char(NEW.delete_date,'DD.MM.YYYY HH24:MI:SS'),
               v_changedby, 
            'GID_DATA');
        END IF;
        	-- 
		IF ( 	
			OLD.modify_data_date != NEW.modify_data_date
			OR ( coalesce(OLD.modify_data_date::text, '') = '' AND (NEW.modify_data_date AND NEW.modify_data_date::text <> ''))
			OR ( (OLD.modify_data_date AND OLD.modify_data_date::text <> '') AND coalesce(NEW.modify_data_date::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'MODIFY_DATA_DATE',
			   to_char(OLD.modify_data_date,'DD.MM.YYYY HH24:MI:SS'),
			   to_char(NEW.modify_data_date,'DD.MM.YYYY HH24:MI:SS'),
               v_changedby, 
            'GID_DATA');
        END IF;
        	-- 
		IF ( 	
			OLD.confirm_date != NEW.confirm_date
			OR ( coalesce(OLD.confirm_date::text, '') = '' AND (NEW.confirm_date AND NEW.confirm_date::text <> ''))
			OR ( (OLD.confirm_date AND OLD.confirm_date::text <> '') AND coalesce(NEW.confirm_date::text, '') = '')
		) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'CONFIRM_DATE',
			   to_char(OLD.confirm_date,'DD.MM.YYYY HH24:MI:SS'),
			   to_char(NEW.confirm_date,'DD.MM.YYYY HH24:MI:SS'),
               v_changedby, 
            'GID_DATA');
		END IF;

        IF ( 	
			OLD.sync_date != NEW.sync_date
			OR ( coalesce(OLD.sync_date::text, '') = '' AND (NEW.sync_date AND NEW.sync_date::text <> ''))
			OR ( (OLD.sync_date AND OLD.sync_date::text <> '') AND coalesce(NEW.sync_date::text, '') = '')
		) THEN
            INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			   v_operation,
			   v_actdatetime,
			   OLD.rowid,
               OLD.gid,
               'SYNC_DATE',
			   to_char(OLD.sync_date,'DD.MM.YYYY HH24:MI:SS'),
			   to_char(NEW.sync_date,'DD.MM.YYYY HH24:MI:SS'),
               v_changedby, 
            'GID_DATA');
		END IF;
	END IF;

IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_gid_data_log_v2() FROM PUBLIC;

ALTER FUNCTION trigger_fct_gid_data_log_v2() OWNER TO scd_testuser;

CREATE TRIGGER gid_data_log_v2
	AFTER INSERT OR UPDATE OR DELETE ON gid_data FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_gid_data_log_v2();

DROP TRIGGER IF EXISTS gid_user_log_v2 ON gid_user CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gid_user_log_v2() RETURNS trigger AS $BODY$
DECLARE
   v_operation  varchar(25);
   v_actdatetime timestamp;
   v_changedby varchar(128);

BEGIN

	-- CURRENT DATE
	SELECT CURRENT_TIMESTAMP INTO STRICT v_actdatetime;

    -- GET USER THAT MADE THE OPERATION (INSERT, DELETE, UPDATE)
    SELECT UPPER(SYS_CONTEXT('userenv','client_identifier')) INTO STRICT v_changedby;

    IF (coalesce(v_changedby::text, '') = '') THEN
        SELECT UPPER(sys_context( 'userenv', 'os_user' )) INTO STRICT v_changedby;
    END IF;

	-- INSERT TRIGGER	
	IF TG_OP = 'INSERT' THEN
		v_operation :='insert';

		IF (NEW.gid AND NEW.gid::text <> '')
		THEN
		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'GID',
            NULL,
            NEW.gid,
            v_changedby,
            'GID_USER');
        END IF;

		IF (NEW.surname AND NEW.surname::text <> '')
		THEN
		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'SURNAME',
            NULL,
            NEW.surname,
            v_changedby,
            'GID_USER');
        END IF;

		IF (NEW.given_name AND NEW.given_name::text <> '')
		THEN 		
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'GIVEN_NAME',
            NULL,
            NEW.given_name,
            v_changedby,
            'GID_USER');
        END IF;

		IF (NEW.name_prefix AND NEW.name_prefix::text <> '')
		THEN
		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'NAME_PREFIX',
            NULL,
            NEW.name_prefix,
            v_changedby,
            'GID_USER');
         END IF;

		IF (NEW.name_suffix AND NEW.name_suffix::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'NAME_SUFFIX',
            NULL,
            NEW.name_suffix,
            v_changedby,
            'GID_USER');
         END IF;

		IF (NEW.birth_date AND NEW.birth_date::text <> '')
		THEN
		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'BIRTH_DATE',
            NULL,
            to_char(NEW.birth_date,'DD.MM.YYYY'),
            v_changedby,
            'GID_USER');
          END IF;

		IF (NEW.birth_place AND NEW.birth_place::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'BIRTH_PLACE',
            NULL,
            NEW.birth_place,
            v_changedby,
            'GID_USER');
         END IF;

		IF (NEW.birth_name AND NEW.birth_name::text <> '')
		THEN
		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'BIRTH_NAME',
            NULL,
            NEW.birth_name,
            v_changedby,
            'GID_USER');
          END IF;

		IF (NEW.gender AND NEW.gender::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'GENDER',
            NULL,
            NEW.gender,
            v_changedby,
            'GID_USER');
        END IF;

		IF (NEW.modify_user_date AND NEW.modify_user_date::text <> '')
		THEN
		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'MODIFY_USER_DATE',
            NULL,
            to_char(NEW.modify_user_date,'DD.MM.YYYY HH24:MI:SS'),
            v_changedby,
            'GID_USER');
         END IF;

		IF (NEW.modify_user_uid AND NEW.modify_user_uid::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'MODIFY_USER_UID',
            NULL,
            NEW.modify_user_uid,
            v_changedby,
            'GID_USER');
         END IF;

		IF (NEW.orig_gid AND NEW.orig_gid::text <> '')
		THEN			
		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'ORIG_GID',
            NULL,
            NEW.orig_gid,
            v_changedby,
            'GID_USER');
        END IF;

		IF (NEW.clientid AND NEW.clientid::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'CLIENTID',
            NULL,
            NEW.clientid,
            v_changedby,
            'GID_USER');
		END IF;

		IF (NEW.creator AND NEW.creator::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'CREATOR',
            NULL,
            NEW.creator,
            v_changedby,
            'GID_USER');
		END IF;

		IF (NEW.creation_date AND NEW.creation_date::text <> '')
		THEN
        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            NEW.gid,
            'CREATION_DATE',
            NULL,
			to_char(NEW.creation_date,'DD.MM.YYYY HH24:MI:SS'),
            v_changedby,
            'GID_USER');
		END IF;
	END IF;

    -- DELETE TRIGGER
	IF TG_OP = 'DELETE' THEN
		v_operation :='delete';

		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'SURNAME',
            OLD.surname,
            NULL,
            v_changedby,
            'GID_USER');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'GIVEN_NAME',
            OLD.given_name,
            NULL,
            v_changedby,
            'GID_USER');

		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'NAME_PREFIX',
            OLD.name_prefix,
            NULL,
            v_changedby,
            'GID_USER');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'NAME_SUFFIX',
            OLD.name_suffix,
            NULL,
            v_changedby,
            'GID_USER');

		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'BIRTH_DATE',
            to_char(OLD.birth_date,'DD.MM.YYYY'),
            NULL,
            v_changedby,
            'GID_USER');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'BIRTH_PLACE',
            OLD.birth_place,
            NULL,
            v_changedby,
            'GID_USER');

		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'BIRTH_NAME',
            OLD.birth_name,
            NULL,
            v_changedby,
            'GID_USER');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'GENDER',
            OLD.gender,
            NULL,
            v_changedby,
            'GID_USER');

		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'MODIFY_USER_DATE',
            to_char(OLD.modify_user_date,'DD.MM.YYYY HH24:MI:SS'),
            NULL,
            v_changedby,
            'GID_USER');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'MODIFY_USER_UID',
            OLD.modify_user_uid,
            NULL,
            v_changedby,
            'GID_USER');

		INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'ORIG_GID',
            OLD.orig_gid,
            NULL,
            v_changedby,
            'GID_USER');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'CLIENTID',
            OLD.clientid,
            NULL,
            v_changedby,
            'GID_USER');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'CREATOR',
            OLD.creator,
            NULL,
            v_changedby,
            'GID_USER');

        INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'CREATION_DATE',
			to_char(OLD.creation_date,'DD.MM.YYYY HH24:MI:SS'),
            NULL,
            v_changedby,
            'GID_USER');
	END IF;

    -- UPDATE TRIGGER	
	IF TG_OP = 'UPDATE' THEN
		v_operation :='update';

		IF ( 	
			OLD.surname != NEW.surname
			OR ( coalesce(OLD.surname::text, '') = '' AND (NEW.surname AND NEW.surname::text <> ''))
			OR ( (OLD.surname AND OLD.surname::text <> '') AND coalesce(NEW.surname::text, '') = '')
        ) THEN
           INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		    VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'SURNAME',
            OLD.surname,
            NEW.surname,
            v_changedby,
            'GID_USER');
        END IF;


        IF ( OLD.given_name != NEW.given_name
			OR ( coalesce(OLD.given_name::text, '') = '' AND (NEW.given_name AND NEW.given_name::text <> ''))
			OR ( (OLD.given_name AND OLD.given_name::text <> '') AND coalesce(NEW.given_name::text, '') = '')
       ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'GIVEN_NAME',
            OLD.given_name,
            NEW.given_name,
            v_changedby,
            'GID_USER');
        END IF;

		IF ( OLD.name_prefix != NEW.name_prefix
			OR ( coalesce(OLD.name_prefix::text, '') = '' AND (NEW.name_prefix AND NEW.name_prefix::text <> ''))
			OR ( (OLD.name_prefix AND OLD.name_prefix::text <> '') AND coalesce(NEW.name_prefix::text, '') = '')
       ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'NAME_PREFIX',
            OLD.name_prefix,
            NEW.name_prefix,
            v_changedby,
            'GID_USER');
        END IF;			

		IF ( OLD.name_suffix != NEW.name_suffix
			OR ( coalesce(OLD.name_suffix::text, '') = '' AND (NEW.name_suffix AND NEW.name_suffix::text <> ''))
			OR ( (OLD.name_suffix AND OLD.name_suffix::text <> '') AND coalesce(NEW.name_suffix::text, '') = '')
       ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'NAME_SUFFIX',
            OLD.name_suffix,
            NEW.name_suffix,
            v_changedby,
            'GID_USER');
        END IF;			

		IF (OLD.birth_date != NEW.birth_date
			OR ( coalesce(OLD.birth_date::text, '') = '' AND (NEW.birth_date AND NEW.birth_date::text <> ''))
			OR ( (OLD.birth_date AND OLD.birth_date::text <> '') AND coalesce(NEW.birth_date::text, '') = '')
       ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'BIRTH_DATE',
            to_char(OLD.birth_date,'DD.MM.YYYY'),
            to_char(NEW.birth_date,'DD.MM.YYYY'),
            v_changedby,
            'GID_USER');
        END IF;			

		IF (  OLD.birth_place != NEW.birth_place
			OR ( coalesce(OLD.birth_place::text, '') = '' AND (NEW.birth_place AND NEW.birth_place::text <> ''))
			OR ( (OLD.birth_place AND OLD.birth_place::text <> '') AND coalesce(NEW.birth_place::text, '') = '')
       ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'BIRTH_PLACE',
            OLD.birth_place,
            NEW.birth_place,
            v_changedby,
            'GID_USER');
        END IF;	

		IF ( OLD.birth_name != NEW.birth_name
			OR ( coalesce(OLD.birth_name::text, '') = '' AND (NEW.birth_name AND NEW.birth_name::text <> ''))
			OR ( (OLD.birth_name AND OLD.birth_name::text <> '') AND coalesce(NEW.birth_name::text, '') = '')
       ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'BIRTH_NAME',
            OLD.birth_name,
            NEW.birth_name,
            v_changedby,
            'GID_USER');
        END IF;			

		IF (OLD.gender != NEW.gender
			OR ( coalesce(OLD.gender::text, '') = '' AND (NEW.gender AND NEW.gender::text <> ''))
			OR ( (OLD.gender AND OLD.gender::text <> '') AND coalesce(NEW.gender::text, '') = '')
       ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)  
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'GENDER',
            OLD.gender,
            NEW.gender,
            v_changedby,
            'GID_USER');
        END IF;			

		IF ( OLD.modify_user_date != NEW.modify_user_date
			OR ( coalesce(OLD.modify_user_date::text, '') = '' AND (NEW.modify_user_date AND NEW.modify_user_date::text <> ''))
			OR ( (OLD.modify_user_date AND OLD.modify_user_date::text <> '') AND coalesce(NEW.modify_user_date::text, '') = '')
       ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'MODIFY_USER_DATE',
            to_char(OLD.modify_user_date,'DD.MM.YYYY HH24:MI:SS'),
            to_char(NEW.modify_user_date,'DD.MM.YYYY HH24:MI:SS'),
            v_changedby,
            'GID_USER');
        END IF;			

		IF ( OLD.modify_user_uid != NEW.modify_user_uid
			OR ( coalesce(OLD.modify_user_uid::text, '') = '' AND (NEW.modify_user_uid AND NEW.modify_user_uid::text <> ''))
			OR ( (OLD.modify_user_uid AND OLD.modify_user_uid::text <> '') AND coalesce(NEW.modify_user_uid::text, '') = '')
       ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'MODIFY_USER_UID',
            OLD.modify_user_uid,
            NEW.modify_user_uid,
            v_changedby,
            'GID_USER');
        END IF;

		IF ( OLD.orig_gid != NEW.orig_gid
			OR ( coalesce(OLD.orig_gid::text, '') = '' AND (NEW.orig_gid AND NEW.orig_gid::text <> ''))
			OR ( (OLD.orig_gid AND OLD.orig_gid::text <> '') AND coalesce(NEW.orig_gid::text, '') = '')
        ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'ORIG_GID',
            OLD.orig_gid,
            NEW.orig_gid,
            v_changedby,
            'GID_USER');
        END IF;

        IF ( OLD.clientid != NEW.clientid
			OR ( coalesce(OLD.clientid::text, '') = '' AND (NEW.clientid AND NEW.clientid::text <> ''))
			OR ( (OLD.clientid AND OLD.clientid::text <> '') AND coalesce(NEW.clientid::text, '') = '')
        ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'CLIENTID',
            OLD.clientid,
            NEW.clientid,
            v_changedby,
            'GID_USER');
        END IF;

		IF ( OLD.creator != NEW.creator
			OR ( coalesce(OLD.creator::text, '') = '' AND (NEW.creator AND NEW.creator::text <> ''))
			OR ( (OLD.creator AND OLD.creator::text <> '') AND coalesce(NEW.creator::text, '') = '')
        ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'CREATOR',
            OLD.creator,
            NEW.creator,
            v_changedby,
            'GID_USER');
        END IF;

		IF ( OLD.creation_date != NEW.creation_date
			OR ( coalesce(OLD.creation_date::text, '') = '' AND (NEW.creation_date AND NEW.creation_date::text <> ''))
			OR ( (OLD.creation_date AND OLD.creation_date::text <> '') AND coalesce(NEW.creation_date::text, '') = '')
        ) THEN
          INSERT INTO gid_log(operation ,ts, row_id, gid, attribute, old_val,new_val, changed_by, origin_table)
		   VALUES (
			v_operation,
			v_actdatetime,
			OLD.rowid,
            OLD.gid,
            'CREATION_DATE',
			to_char(OLD.creation_date,'DD.MM.YYYY HH24:MI:SS'),
            to_char(NEW.creation_date,'DD.MM.YYYY HH24:MI:SS'),
            v_changedby,
            'GID_USER');
        END IF;

	END IF;	

IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_gid_user_log_v2() FROM PUBLIC;

ALTER FUNCTION trigger_fct_gid_user_log_v2() OWNER TO scd_testuser;

CREATE TRIGGER gid_user_log_v2
	AFTER INSERT OR UPDATE OR DELETE ON gid_user FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_gid_user_log_v2();

DROP TRIGGER IF EXISTS trg_fits_giddata ON gid_data CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_fits_giddata() RETURNS trigger AS $BODY$
BEGIN
if (	NEW.C = 'DE' or OLD.C = 'DE'
        or NEW.C = 'US' or OLD.C = 'US' 
        or NEW.C = 'CA' or OLD.C = 'CA' 
        or NEW.C = 'CZ' or OLD.C = 'CZ'
        or NEW.C = 'DZ' or OLD.C = 'DZ'
        or NEW.C = 'PL' or OLD.C = 'PL'
        or NEW.C = 'RO' or OLD.C = 'RO'
        or NEW.C = 'AT' or OLD.C = 'AT'
    )	then
if (	NEW.C  <> OLD.C
or	NEW.O  <> OLD.O
or	NEW.OU <> OLD.OU
or	NEW.L  <> OLD.L
or	NEW.valid_date <> OLD.valid_date
or	NEW.leave_date <> OLD.leave_date
    )	then
if (	to_char(OLD.valid_date, 'dd.mm.yyyy') = '01.01.1970'
and	to_char(OLD.leave_date, 'dd.mm.yyyy') = '31.12.9999'
and	coalesce(OLD.o::text, '') = ''  and  coalesce(OLD.l::text, '') = ''
    )	then			-- ignore initial time frame
	Null	;
else	insert	into	fits_trigger	values (	nextval('fits_trigger_seq'),	NEW.GID
,	OLD.valid_date,	NEW.valid_date
,	OLD.leave_date,	NEW.leave_date
,	OLD.user_type,		NEW.user_type
,	OLD.c,			NEW.c
,	OLD.o,			NEW.o
,	OLD.ou,		NEW.ou
,	OLD.l,			NEW.l
,	Null,			Null		-- AREs
,	statement_timestamp(),		Null , Null, Null
,NEW.owner
)	;
end	if	;
end	if	;
end	if	;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_fits_giddata() FROM PUBLIC;

ALTER FUNCTION trigger_fct_trg_fits_giddata() OWNER TO scd_testuser;

CREATE TRIGGER trg_fits_giddata
	AFTER UPDATE ON gid_data FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_fits_giddata();

DROP TRIGGER IF EXISTS trg_fits_giduser ON gid_user CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_fits_giduser() RETURNS trigger AS $BODY$
BEGIN
  IF (NEW.surname<>OLD.surname) THEN
    IF (substr(OLD.surname,0,2)='X1' and OLD.surname=OLD.given_name and OLD.surname=OLD.birth_name and OLD.surname=OLD.birth_place) THEN
      NULL;
    ELSE
      insert into FITS_TRIGGER(id,gid,surname_new,surname_old,modifydate) values (nextval('fits_trigger_seq'),NEW.gid, NEW.surname, OLD.surname, statement_timestamp());
    END IF;
  END IF;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_fits_giduser() FROM PUBLIC;

ALTER FUNCTION trigger_fct_trg_fits_giduser() OWNER TO scd_testuser;

CREATE TRIGGER trg_fits_giduser
	AFTER UPDATE OF surname ON gid_user FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_fits_giduser();

DROP TRIGGER IF EXISTS trg_giddata ON gid_data CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trg_giddata() RETURNS trigger AS $BODY$
BEGIN
  IF (NEW.LEAVE_DATE<>OLD.LEAVE_DATE) OR (NEW.L <> OLD.L) OR (NEW.C <> OLD.C) OR (NEW.VALID_DATE <> OLD.VALID_DATE) OR (NEW.USER_TYPE <> OLD.USER_TYPE) OR (NEW.O <> OLD.O) THEN
    IF (NEW.c='DE' OR OLD.c='DE') THEN
      IF (to_char(OLD.VALID_DATE,'dd.mm.yyyy')='01.01.1970' and to_char(OLD.LEAVE_DATE,'dd.mm.yyyy')='31.12.9999' and coalesce(OLD.o::text, '') = '' and coalesce(OLD.l::text, '') = '') THEN
        insert into bpr_gids_temp(id,gid,leave_new, leave_old, l_new,l_old,valid_new, valid_old,ut_new, ut_old, o_old, o_new, modifydate, ou_old, ou_new)
          values (999,NEW.gid, NEW.leave_date, OLD.leave_date, NEW.L, OLD.L,NEW.valid_date, OLD.valid_date, NEW.user_type, OLD.user_type, OLD.o, NEW.o, statement_timestamp(), OLD.ou, NEW.ou );
      ELSE
      insert into bpr_gids(id,gid,leave_new, leave_old, l_new,l_old,valid_new, valid_old,ut_new, ut_old, o_old, o_new, modifydate, ou_old, ou_new, c_old, c_new) 
        values (nextval('bpr_gids_id_sequence'),NEW.gid, NEW.leave_date, OLD.leave_date, NEW.L, OLD.L,NEW.valid_date, OLD.valid_date, NEW.user_type, OLD.user_type, OLD.o, NEW.o, statement_timestamp(), OLD.ou, NEW.ou, OLD.c, NEW.c);
      END IF;
    END IF;
  END IF;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trg_giddata() FROM PUBLIC;

ALTER FUNCTION trigger_fct_trg_giddata() OWNER TO scd_testuser;

CREATE TRIGGER trg_giddata
	AFTER UPDATE OF leave_date,l,c,valid_date,user_type,o ON gid_data FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trg_giddata();





/* SCD Function Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = scd,oracle,public;

SET check_function_bodies = false;



--
-- dblink wrapper to call function scd.system as an autonomous transaction
--

CREATE OR REPLACE FUNCTION scd.system ( cmd text ) RETURNS bigint AS $body$
DECLARE
	-- Change this to reflect the dblink connection string
	v_conn_str  text := format('port=%s dbname=%s user=%s', current_setting('port'), current_database(), current_user);
	v_query     text;

	v_ret	bigint;
BEGIN
	v_query := 'SELECT * FROM system_atx ( ' || quote_nullable(cmd) || ' )';
	SELECT * INTO v_ret FROM dblink(v_conn_str, v_query) AS p (ret bigint);
	RETURN v_ret;

END;
$body$ LANGUAGE plpgsql SECURITY DEFINER;


--  client - system call
CREATE OR REPLACE FUNCTION scd.system_atx ( cmd text ) RETURNS bigint AS $body$
DECLARE

ret	bigint;
BEGIN
INSERT	INTO	sds.CltRun
VALUES (	'(cd /share/sds;'
||	cmd		-- don't use "&" !!
||	') </dev/null >/dev/null 2>/dev/null'
,	nextval('scd.write')
)
RETURNING  ID	INTO	ret;
COMMIT	WORK;
RETURN	ret;
END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER FUNCTION scd.system ( cmd text ) OWNER TO scd_testuser;
ALTER FUNCTION scd.system_atx ( cmd text ) OWNER TO scd_testuser;
-- REVOKE ALL ON FUNCTION scd.system ( cmd text ) FROM PUBLIC; -- REVOKE ALL ON FUNCTION scd.system_atx ( cmd text ) FROM PUBLIC;


/* PLEASE REVIEW */

SET client_encoding TO 'UTF8';

SET search_path = sds,oracle,public;

SET check_function_bodies = false;

CREATE OR REPLACE VIEW lftgid (liefntnr, liefntmin, liefntmax, senderid, stellvid, nick, mailsds, mailsuz, notify, sprache, zchnsatz, lieferart, lieferset, lieferkey, mainid, delta, bdsg, aptool, dgetid, isv3, txv3, ftread, pagids, updcurr) AS SELECT	LIEFNTNR,LIEFNTMIN,LIEFNTMAX,SENDERID,STELLVID,NICK,MAILSDS,MAILSUZ,NOTIFY,SPRACHE,ZCHNSATZ,LIEFERART,LIEFERSET,LIEFERKEY,MAINID,DELTA,BDSG,APTOOL,DGETID,ISV3,TXV3,FTREAD,PAGIDS,UPDCURR	FROM	Liefnt
WHERE	LieferArt  LIKE	'_G%'
OR	LieferArt  LIKE	'_S%';

ALTER VIEW lftgid OWNER TO scd_testuser; 


CREATE OR REPLACE VIEW liefntstv (liefntnr, nick, gid_lv, lieferart) AS SELECT	LiefntNR, Nick
,	MainID		GID_LV
,	LieferArt
FROM	Liefnt
WHERE	(MainID::text <> '')

UNION

SELECT	LiefntNr, Nick
,	DGetID		GID_LV
,	LieferArt
FROM	Liefnt
WHERE	DGetID	<> MainID;

ALTER VIEW liefntstv OWNER TO scd_testuser;


CREATE OR REPLACE VIEW dnliefnt (c, o, ou, l, typ, bv_num, bv_gid, bv, lv_num, lv_gid, lv_mail, lv, lv_art, lv_set, gv_num, gv_gid, gv, gv_art, gv_set, jv_num, jv_gid, jv_mail, jv, jv_art, jv_set, joinbez, joinlfd, joinset, userset, urlsuz) AS SELECT	C, O, OU, L, Typ
,	DN.BerchNr	BV_Num
,	BV.BerchID	BV_GID
,	BV.Nick		BV
--
,	DN.LiefntNr	LV_Num
,	LV.MainID	LV_GID
,	LV.SenderID	LV_mail
,	LV.Nick		LV
,	LV.LieferArt	LV_Art
,	LV.LieferSet	LV_Set
--
,	GV.LiefntNr	GV_Num
,	DN.MainID	GV_GID
,	GV.Nick		GV
,	GV.LieferArt	GV_Art
,	GV.LieferSet	GV_Set
--
,	JV.LiefntNr	JV_Num
,	JV.MainID	JV_GID
,	JV.SenderID	JV_mail
,	JV.Nick		JV
,	JV.LieferArt	JV_Art
,	JV.LieferSet	JV_Set
--
,	JoinS		JoinBez
,	Lfd		JoinLfd
,	JoinSet
,	UserSet
,	UrlSuz
--
FROM sds.dn
LEFT OUTER JOIN sds."join" ON (DN.JoinS = "join".Bez)
LEFT OUTER JOIN sds.berch bv ON (DN.BerchNr = BV.BerchNr)
LEFT OUTER JOIN sds.liefnt lv ON (DN.LiefntNr = LV.LiefntNr)
LEFT OUTER JOIN sds.lftgid gv ON (DN.MainID = GV.MainID)
LEFT OUTER JOIN sds.liefnt jv ON ("join".LiefntNr = JV.LiefntNr)

;

ALTER VIEW dnliefnt OWNER TO scd_testuser;




CREATE MATERIALIZED VIEW gid_data_scd AS
SELECT		GID, S.C, S.O, S.OU, S.L
,	CN		"Common Name"
,	sn		Surname
,	GivenName	"Given Name"
,	mail
,	usertype,	recordType
,	scdId		"SCD-ID"
,	maIdent	"MA-Ident"
,	personalIdnumber		"Personal-ID"
,	contractstatus
,	status
		,	TO_NUMBER("deliveryid", '999999')	LiefntNr
,			deliveryid
FROM	VRT.SCD	 S
WHERE	deliveryid	IS NOT	Null
--
UNION
	-- gid_rumpf_v3_all
SELECT		GID, S.C, S.O, S.OU, S.L
,	CN		"Common Name"
,	sn		Surname
,	GivenName	"Given Name"
,	mail
,	usertype,	recordType
,	scdId		"SCD-ID"
,	maIdent	"MA-Ident"
,	personalIdnumber		"Personal-ID"
,	contractstatus
,	status
,	DN.	LiefntNr
,	'GID'		deliveryid
FROM	VRT.SCD  S
LEFT	JOIN	DN
ON	S.C =	DN.C
AND	S.O =	DN.O
AND	S.OU =	DN.OU
AND	S.L = 	DN.L
WHERE	coalesce(deliveryId::text, '') = ''
AND	trim(both Typ)	LIKE	'_'
--
UNION
	-- gid_rumpf_v3
SELECT		GID, S.C, S.O, S.OU, S.L
,	CN		"Common Name"
,	sn		Surname
,	GivenName	"Given Name"
,	mail
,	usertype,	recordType
,	scdId		"SCD-ID"
,	maIdent	"MA-Ident"
,	personalIdnumber		"Personal-ID"
,	contractstatus
,	status
,	DN.	LiefntNr
,	'GID'		deliveryId
FROM	VRT.SCD	 S
JOIN	DN
ON	S.C =	DN.C
AND	S.O =	DN.O
AND	S.OU =	DN.OU
AND	S.L = 	DN.L
AND	trim(both Typ) =
	trim(both usertype)
||	trim(both recordType)
WHERE	coalesce(deliveryId::text, '') = ''
--
UNION
	-- gid_join_v3
SELECT		GID, S.C, S.O, S.OU, S.L
,	CN		"Common Name"
,	sn		Surname
,	GivenName	"Given Name"
,	mail
,	usertype,	recordType
,	scdId		"SCD-ID"
,	maIdent	"MA-Ident"
,	personalIdnumber		"Personal-ID"
,	contractstatus
,	status
		,	JV_Num		LiefntNr
,	JV_Num	||''	deliveryId
FROM	VRT.SCD	 S
JOIN	dnliefnt J
ON	trim(both S.C || S.O || S.OU || S.L
||	usertype
||	recordType
) =	trim(both J.C || J.O || J.OU || J.L
||	Typ
)	;


ALTER MATERIALIZED VIEW gid_data_scd OWNER TO scd_testuser;


CREATE OR REPLACE VIEW gid_datauser (gid, valid_date, leave_date, user_type, owner, join_date, sponsor, c, o, ou, l, appl_internal_id, appl_name, confirmed, scd, isinscd, delete_date, delete_uid, modify_data_date, modify_data_uid, confirm_date, sync_date, creator, creation_date, surname, given_name, name_prefix, name_suffix, birth_date, birth_place, birth_name, gender, modify_user_date, modify_user_uid, orig_gid, clientid) AS SELECT	d.GID,d.VALID_DATE,d.LEAVE_DATE,d.USER_TYPE,d.OWNER,d.JOIN_DATE,d.SPONSOR,d.C,d.O,d.OU,d.L,d.APPL_INTERNAL_ID,d.APPL_NAME,d.CONFIRMED,d.SCD,d.ISINSCD,d.DELETE_DATE,d.DELETE_UID,d.MODIFY_DATA_DATE,d.MODIFY_DATA_UID,d.CONFIRM_DATE,d.SYNC_DATE,
	u.creator,
	u.creation_date,
	u.surname,
	u.given_name,
	u.name_prefix,
	u.name_suffix,
	u.birth_date,
	u.birth_place,
	u.birth_name,
	u.gender,
	u.modify_user_date,
	u.modify_user_uid,
	u.orig_gid,
	u.clientid
--
FROM	gid_data d, gid_user u
WHERE	u.gid = d.gid;

ALTER VIEW gid_datauser OWNER TO scd_testuser;

CREATE OR REPLACE VIEW v_gid_db_dep (gid, creation_date, sponsor, valid_date, leave_date, c, o, ou, l, user_type, surname, given_name, department, itacc, delegation) AS SELECT  X.GID ,
    creation_date,
    X.Sponsor ,
    valid_date,
    leave_date ,
    X.C,
    X.O,
    X.OU,
    X.L ,
    user_type ,
    surname,
    given_name ,
    S.Department department,
   S.itAcc  ITacc,
   S.delegation delegation
  FROM gid_datauser X
  LEFT JOIN vrt.scd S
  ON S.GID          = X.GID
  AND  substr(S.validDate,0,8) = to_char(X.valid_date,'yyyymmdd')
  AND S.recordType='H'
  WHERE coalesce(delete_uid::text, '') = ''
  AND scd           = '1'
  AND confirmed     = '1'
  AND (X.valid_date::text <> '');

ALTER VIEW v_gid_db_dep OWNER TO scd_testuser;


CREATE MATERIALIZED VIEW mv_gid_db_dep AS
select * FROM v_gid_db_dep;
CREATE INDEX i_mv_gid_db_dep ON mv_gid_db_dep (gid);

ALTER MATERIALIZED VIEW mv_gid_db_dep OWNER TO scd_testuser;






CREATE OR REPLACE VIEW gid_db_akt (gid, creation_date, sponsor, valid_date, leave_date, c, o, ou, l, user_type, surname, given_name, department, itacc, delegation) AS SELECT DISTINCT GID,CREATION_DATE,SPONSOR,VALID_DATE,LEAVE_DATE,C,O,OU,L,USER_TYPE,SURNAME,GIVEN_NAME,DEPARTMENT,ITACC,DELEGATION
FROM	mv_gid_db_dep	X1
where	valid_date	=	(
select	max(valid_date)
from	mv_gid_db_dep	X2
where	X1.GID	=	X2.GID	);

ALTER VIEW gid_db_akt OWNER TO scd_testuser;

CREATE OR REPLACE VIEW gid_db_vor (gid, creation_date, sponsor, valid_date, leave_date, c, o, ou, l, user_type, surname, given_name, department, itacc, delegation) AS SELECT DISTINCT GID,CREATION_DATE,SPONSOR,VALID_DATE,LEAVE_DATE,C,O,OU,L,USER_TYPE,SURNAME,GIVEN_NAME,DEPARTMENT,ITACC,DELEGATION
FROM	mv_gid_db_dep	X1
where	valid_date	=	(
select	max(X2.valid_date)
from	mv_gid_db_dep	X2	inner
join	gid_db_akt	X3
on	X2.GID	=	X3.GID
where	X2.valid_date
  <	X3.valid_date
and	X1.GID	=	X2.GID	);

ALTER VIEW gid_db_vor OWNER TO scd_testuser;


CREATE OR REPLACE VIEW gid_db_last (gid, creation_date, sponsor, valid_date, leave_date, c, o, ou, l, user_type, surname, given_name, department, itacc, delegation, sep, sponsor_old, valid_old, leave_old, c_old, o_old, ou_old, l_old, typ_old, sn_old, gn_old, dep_old, it_old, del_old) AS select	A.GID,A.CREATION_DATE,A.SPONSOR,A.VALID_DATE,A.LEAVE_DATE,A.C,A.O,A.OU,A.L,A.USER_TYPE,A.SURNAME,A.GIVEN_NAME,A.DEPARTMENT,A.ITACC, A.DELEGATION,	'!'	SEP
,	V.Sponsor	sponsor_old
,	V.valid_date	valid_old
,	V.leave_date	leave_old
,	V.C		C_old
,	V.O		O_old
,	V.OU		OU_old
,	V.L		L_old
,	V.user_type	typ_old
,	V.surname	sn_old
,	V.given_name	gn_old
,	V.Department	dep_old
,	V.ITacc		IT_old
,                    V.Delegation                      del_old
FROM	gid_db_akt	A	left
join	gid_db_vor	V
on	A.GID	=	V.GID
where (A.c='DE' and A.user_type='X'
or V.c='DE' and V.user_type='X');

ALTER VIEW gid_db_last OWNER TO scd_testuser;




CREATE MATERIALIZED VIEW mv_gid_db_last AS
select * FROM GID_DB_LAST;


ALTER MATERIALIZED VIEW mv_gid_db_last OWNER TO scd_testuser;






/* Section 1.7.1 - MVIEW Creation */




/*
CREATE MATERIALIZED VIEW mv_bpr_konfig AS
select * FROM V_BPR_KONFIG;


ALTER MATERIALIZED VIEW mv_bpr_konfig OWNER TO scd_testuser;
*/

CREATE MATERIALIZED VIEW ssd AS
SELECT	1		Period
--
,	OrgID
,	CostLocUnit
,	GCC
,	Division
,	OrgIDclass
--
,	CASE WHEN 	position('!' in CostLocation)	=0 THEN  CostLocation	  ELSE SubStr(CostLocation, 1, position('!' in CostLocation) - 1) END 	CostCenterRange
,	CASE WHEN 	position('!' in CostLocation)	=0 THEN  Null	  ELSE SubStr(CostLocation, InStr(CostLocation, '!',-1) + 1) END 	CostCenterRange_Count
--
FROM	AdrDat
WHERE	LiefntNr =		10

UNION

SELECT	0		Period
--
,	OrgID
,	CostLocUnit
,	GCC
,	Division
,	OrgIDclass
--
,	CASE WHEN 	position('!' in CostLocation)	=0 THEN  CostLocation	  ELSE SubStr(CostLocation, 1, position('!' in CostLocation) - 1) END 	CostCenterRange
,	CASE WHEN 	position('!' in CostLocation)	=0 THEN  Null	  ELSE SubStr(CostLocation, InStr(CostLocation, '!',-1) + 1) END 	CostCenterRange_Count
--
FROM	AdrDat
WHERE	LiefntNr =		20
AND	OrgIDperiod =	(
SELECT	Max(OrgIDperiod)
FROM	AdrDat
WHERE	LiefntNr = 20	);
CREATE INDEX ixssd ON ssd (costlocunit, gcc, division);

ALTER MATERIALIZED VIEW ssd OWNER TO scd_testuser;
CREATE MATERIALIZED VIEW stmgenou AS
SELECT	* FROM	StmDat
WHERE	LiefNr	=
(
SELECT	Max(LiefNr)	FROM Prot
WHERE	LiefntNr  =	1
AND	Status	  =	'Prt.000260'
)	;


ALTER MATERIALIZED VIEW stmgenou OWNER TO scd_testuser;
/*
CREATE MATERIALIZED VIEW user_clientid AS
SELECT users.gid, d.c, d.o, d.ou, d.l, coalesce(d.CLIENT_ID, 1) AS client_id, d.clientname, d.rank FROM gid_user users LEFT JOIN(SELECT t.gid,
            t.c, 
            t.o, 
            t.ou,
            t.l, 
            t.rank,
            CASE WHEN (sal.clientid AND sal.clientid::text <> '') THEN sal.clientid
                ELSE 
                    CASE WHEN clientidperorganization.co > 1 THEN 1 
                         WHEN coalesce(clientidperorganization.co::text, '') = '' THEN 1 
                         WHEN clientidperorganization.co = 0 THEN 1 
                         ELSE organizationclientid.oc
                    END
                END	
            AS CLIENT_ID,
            s.clientname        

        FROM (SELECT gid, c, o, ou, l, valid_date, leave_date, delete_date, RANK() OVER (PARTITION BY gid  order by 
                     CASE 
                          WHEN to_char(valid_date, 'DD/MM/YYYY') = to_char(statement_timestamp(), 'DD/MM/YYYY') THEN 0
                          WHEN valid_date < statement_timestamp() AND (leave_date > statement_timestamp() OR to_char(leave_date, 'DD/MM/YYYY') = to_char(statement_timestamp(), 'DD/MM/YYYY') )THEN 1                        
                          WHEN valid_date > statement_timestamp() THEN 2
                          WHEN valid_date < statement_timestamp() THEN 3
                          WHEN coalesce(valid_date::text, '') = '' THEN 4
                          ELSE 5
                        END , valid_date desc , rowid desc) AS rank FROM gid_data WHERE coalesce(delete_date::text, '') = '') t

        LEFT JOIN(select c, o ,ou, l, clientid, MAX(typ) FROM stmgendn GROUP BY c, o, ou, l, clientid) sal  
            ON t.c = sal.c AND t.o = sal.o AND t.ou = sal.ou AND t.l = sal.l

        LEFT JOIN(select o, COUNT(distinct(clientid)) AS co FROM stmgendn GROUP BY o) clientidperorganization ON clientidperorganization.o = t.o

        LEFT JOIN(select o,  MAX(clientid) oc FROM stmgendn WHERE (clientid AND clientid::text <> '') GROUP BY o ) organizationclientid ON t.o = organizationclientid.o 

        LEFT JOIN STMGEN s ON s.c = t.c and s.o = t.o and s.ou = t.ou and s.l = t.l

        WHERE coalesce(t.delete_date::text, '') = ''
    ) d ON d.gid = users.gid;
CREATE INDEX user_clientid_index_c ON user_clientid (c);
CREATE INDEX user_clientid_index_gid ON user_clientid (gid);
CREATE INDEX user_clientid_index_l ON user_clientid (l);
CREATE INDEX user_clientid_index_o ON user_clientid (o);
CREATE INDEX user_clientid_index_ou ON user_clientid (ou);

ALTER MATERIALIZED VIEW user_clientid OWNER TO scd_testuser;
*/

/*
CREATE MATERIALIZED VIEW user_clientid_future AS
SELECT users.gid, d.c, d.o, d.ou, d.l, coalesce(d.CLIENT_ID, 1) AS client_id, d.clientname, d.rank FROM gid_user users LEFT JOIN(SELECT t.gid,
            t.c, 
            t.o, 
            t.ou,
            t.l, 
            t.rank,

            CASE WHEN (sal.clientid AND sal.clientid::text <> '') THEN sal.clientid
                ELSE 
                    CASE WHEN clientidperorganization.co > 1 THEN 1 
                         WHEN coalesce(clientidperorganization.co::text, '') = '' THEN 1 
                         WHEN clientidperorganization.co = 0 THEN 1 
                         ELSE organizationclientid.oc
                    END
                END	

            AS CLIENT_ID,
            s.clientname        

        FROM (SELECT gid, c, o, ou, l, valid_date, leave_date, delete_date, RANK() OVER (PARTITION BY gid  order by 
                     CASE 
                          WHEN to_char(valid_date, 'DD/MM/YYYY') = to_char(statement_timestamp(), 'DD/MM/YYYY') THEN 1
                          WHEN valid_date < statement_timestamp() THEN 2                        
                          WHEN valid_date > statement_timestamp() THEN 0
                          WHEN coalesce(valid_date::text, '') = '' THEN 3
                          ELSE 4
                        END , valid_date desc , rowid desc) AS rank FROM gid_data WHERE coalesce(delete_date::text, '') = '') t

        LEFT JOIN(select c, o ,ou, l, clientid, MAX(typ) FROM stmgendn GROUP BY c, o, ou, l, clientid) sal  
            ON t.c = sal.c AND t.o = sal.o AND t.ou = sal.ou AND t.l = sal.l

        LEFT JOIN(select o, COUNT(distinct(clientid)) AS co FROM stmgendn GROUP BY o) clientidperorganization ON clientidperorganization.o = t.o

        LEFT JOIN(select o,  MAX(clientid) oc FROM stmgendn WHERE (clientid AND clientid::text <> '') GROUP BY o ) organizationclientid ON t.o = organizationclientid.o 

        LEFT JOIN STMGEN s ON s.c = t.c and s.o = t.o and s.ou = t.ou and s.l = t.l

        WHERE coalesce(t.delete_date::text, '') = ''
    ) d ON d.gid = users.gid;
CREATE INDEX user_clientid_future_index_c ON user_clientid_future (c);
CREATE INDEX user_clientid_future_index_gid ON user_clientid_future (gid);
CREATE INDEX user_clientid_future_index_l ON user_clientid_future (l);
CREATE INDEX user_clientid_future_index_o ON user_clientid_future (o);
CREATE INDEX user_clientid_future_index_ou ON user_clientid_future (ou);

ALTER MATERIALIZED VIEW user_clientid_future OWNER TO scd_testuser;


*/


/* Section 1.7.2 - SDS Views Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = sds,oracle,public;

SET check_function_bodies = false;

/*
CREATE OR REPLACE VIEW validorgcodes (department, enddate, origin) AS select DEPARTMENT,max(LEAVEDATE),min(ORIGIN) FROM (
select department, leavedate, '1:SOM' origin
from sds.adrdat
where liefntnr=9

union

select department, enddate, '2:CHCM' origin
from validorgcodeschcm

union

select department, enddate, '3:MAN' origin
from validorgcodesmanual
)
--where department not like 'SGRE %'
group by department
order by department;

ALTER VIEW validorgcodes OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW v_fits_mastat (gid, givenname, sn, nickname, department, l, o, c, salid, building, roomnumber, usertype, recordtypev3, contractstatus, sponsor, gidman1, costlocationunit, costlocation, ou, unit, mail, telephonenumber, mobile, status, leavedate, validdate, orgid, gpcompany, personalidnumber, ofk, lifecycleevent, lifecycledate, privatemail, privatemobile, pkiversion, certindicator, mastat, azubiend, companycode, firmstat) AS (
SELECT s.GID, s.GivenName, s.sn, coalesce(s.nickName,s.GivenName) nickName, s.Department
, s.L, s.O, s.C, s.salid, s.building, s.roomNumber, s.usertype, s.recordTypeV3
,s.contractstatus, s.sponsor, s.gidMan1, s.costLocationUnit, s.costLocation
,s.OU, s.unit, s.mail, s.telephoneNumber, s.mobile, s.status, s.leaveDate, s.validDate
,s.orgid, s.gpCompany, s.personalIdnumber
,CASE WHEN s.mgmtLevel='A' THEN '1' WHEN s.mgmtLevel='B' THEN '1'  ELSE '0' END  OFK
,coalesce(s.lifeCycleEvent)	lifeCycleEvent, s.lifeCycleDate
,'' privateMail, '' privateMobile, s.pkiversion, s.certIndicator
, coalesce(a.Mastat,'0') Mastat, a.Azubiend, s.companyCode,s.firmstat
FROM vrt.scd s  Left Join adrdat a On a.Liefntnr=2 and s.gid=a.gid
  and s.c=a.c and s.o=a.o and s.ou=a.ou and s.l=a.l 
  and s.recordTypeV3=a.recordtype
  );

ALTER VIEW v_fits_mastat OWNER TO scd_testuser;



CREATE OR REPLACE VIEW v_fits_base (gid, sponsor, valid_date, leave_date, c, o, ou, l, user_type, owner) AS SELECT	GID,	Sponsor
,	valid_date
,	leave_date
,	C, O, OU, L
,	user_type
, owner
FROM	gid_data

WHERE	coalesce(delete_uid::text, '') = ''
AND	scd	    =	  '1'
AND	confirmed   =	  '1'
AND	user_type   <>	  'T'
--AND	GID	NOT LIKE  'ZTST%'
AND ( valid_date  >	statement_timestamp() - interval '30 days' AND valid_date < statement_timestamp() + interval '30 days'
 OR (
	leave_date  >	statement_timestamp() - interval '90 days'	-- cut very old ones
AND	leave_date  <	statement_timestamp() + interval '30 days'	-- cut long actives
)	);

ALTER VIEW v_fits_base OWNER TO scd_testuser;


CREATE OR REPLACE VIEW v_country_details (country_abb, name_nat, name_eng, dial_code) AS (SELECT COUNTRY_ABB,NAME_NAT,NAME_ENG,DIAL_CODE FROM (
select b.c country_abb, b.cnamenat name_nat, b.cnameeng name_eng, replace(a.phonenumex, '(','') dial_code
from (select c, cnamenat, cnameeng, phonenumex, max(count) count
from (select distinct c, cnamenat, cnameeng, trim(both substr(phonenumex,1,4)) phonenumex, count(phonenumex) count
from sds.stmdat where (phonenumex::text <> '') and (clientid IN ('1','2') or coalesce(clientid::text, '') = '') group by c, cnamenat, cnameeng, phonenumex) alias9
group by c, cnamenat, cnameeng, phonenumex) a,
(select c, cnamenat, cnameeng, max(count) count from (select c, cnamenat, cnameeng, phonenumex, max(count) count from (select distinct c, cnamenat, cnameeng, trim(both substr(phonenumex,1,4)) phonenumex, count(phonenumex) count
from sds.stmdat
where (phonenumex::text <> '') and (clientid IN ('1','2') or coalesce(clientid::text, '') = '')
group by c, cnamenat, cnameeng, phonenumex) alias20
group by c, cnamenat, cnameeng, phonenumex) alias21
group by c, cnamenat, cnameeng) b
where a.c = b.c and a.cnamenat = b.cnamenat and a.cnameeng = b.cnameeng and a.count = b.count
) alias23
);

ALTER VIEW v_country_details OWNER TO scd_testuser;



CREATE OR REPLACE VIEW v_fits_new_dns (c, o, ou, l, costlocationunit) AS (select distinct c,o,ou,l,costLocationUnit--,"department" 
FROM (
(select c,o,ou,l,"costlocationunit"--,"department"
from vrt.scd
where (c='DE' and ou<>'EM' and "costlocationunit" in ('5026','5032','5089','490C','523K','524K','5053','7092','7264','7411','7996','7997','7998',
 '423B','426K','7038','7039','7316','7412','572K','7939','7471','4079'))
 or (c='DE' and ou='EM' and "costlocationunit" in ('7411','7719','562K') and "department" like 'EM TS CS%') 
 or (c='DE' and ou='EM' and "costlocationunit" in ('7411','7719','562K') 
  and "department" not like 'EM TS%' and "department" not like 'EM TR%' and "department" not like 'EM HP%')
and l not in ('BCH AF','BCH S 100','VDE I','RHF HL','TUB B','PNI T')
and "usertype"<>'T' and "recordtypev3"='H')
EXCEPT(select c,o,ou,l,"costlocationunit"--,"department"
from vrt.scd
where (c='DE' and ou = 'MO' and "costlocationunit" ='7471') 
or (c='DE' and ou = 'PD' and "costlocationunit" ='7411') 
or (c='DE' and ou = 'DF' and "costlocationunit" in ('7411','7939'))
 or (c='DE' and ou='EM' and "costlocationunit" in ('7411','7719','562K') and "department" like 'EM TS CS%') 
 or (c='DE' and ou='EM' and "costlocationunit" in ('7411','7719','562K') 
  and "department" not like 'EM TS%' and "department" not like 'EM TR%' and "department" not like 'EM HP%'))
) alias17);

ALTER VIEW v_fits_new_dns OWNER TO scd_testuser;



CREATE OR REPLACE VIEW attrsetv (bez, txt, attr, feldnr, pflicht) AS SELECT	BEZ,TXT,ATTR,FELDNR,PFLICHT FROM	AttrSet	
UNION

SELECT	Bez, Txt, Bez, 1, NULL
FROM	Attr	;

ALTER VIEW attrsetv OWNER TO scd_testuser;




CREATE OR REPLACE VIEW attr_new (bez, txt, min, max, zchn, normfunction, checkfunction, dbnormfunction, errormessageid, utf8) AS SELECT A.BEZ,A.TXT,A.MIN,A.MAX,A.ZCHN,
coalesce(C.normfunction,'noNormalization') AS normfunction,
coalesce(C.checkfunction,'checkAlwaysOK') AS checkfunction,
coalesce(C.dbnormfunction,'noNormalization') AS dbnormfunction,
coalesce(M.messageid,'')  AS errormessageid,
CASE WHEN (U.bez::text <> '') THEN '1' ELSE '0' END AS UTF8
FROM ATTR A
LEFT JOIN attr_check_norm C
ON A.bez=C.bez
LEFT JOIN check_err_mesg M
ON C.checkfunction = M.checkfunction
LEFT JOIN attr_utf8 U
ON A.bez=U.bez
ORDER BY A.bez;

ALTER VIEW attr_new OWNER TO scd_testuser;



CREATE OR REPLACE VIEW adrmak (lfd, c, o, ou, l, cn, sn, gn, cnamnat, snamnat, snampre, snamadd, gnamnat, lastnam, i, gender, personaltitle, graduatetitle, mail, department, departmenttext, mainfunc, building, roomnumber, postofficebox, telnumber, alternphone, securephone, faxnumber, personalfax, faxnumsec, mobile, vidconfnum1, vidconfnum2, pager, netmeeting, urlpers, persremark, robinson, secretary, representation, sponsor, costlocation, costlocunit, orgid, persidnum, maident, appkey, scdid, gid, usertype, recordtype, contractstat, joindate, validdate, leavedate, expiredate, releaseext, liefntnr, liefnr, isinscd, lieferkey, nicknam, orgcodeid, unitid, unit, manager1, manager2, managerf1, managerf2, managerf3, departmentnat, mastat, azubiend, reststart, restend, vip, itacc, delegation, gpcompany, reqpki, reqbadge, reqacc, reqmbox, reqmail, companycode, mgmtresp, notwebvisible, mailpriv, mobilepriv, gcc, division, orgidperiod, orgidclass, wcunit, actiontype, actionreason, actionstart, makreis, magruppe, juper, prefsn, orgleva, orglevb, orglevc, orglevd, orglevx, altou, fksource, prefpronoun, cofres) AS SELECT	row_number() OVER () AS Lfd
,	AdrDat.C,AdrDat.O,AdrDat.OU,AdrDat.L,AdrDat.CN,AdrDat.SN,AdrDat.GN,AdrDat.CNAMNAT,AdrDat.SNAMNAT,AdrDat.SNAMPRE,AdrDat.SNAMADD,AdrDat.GNAMNAT,AdrDat.LASTNAM,AdrDat.I,AdrDat.GENDER,AdrDat.PERSONALTITLE,AdrDat.GRADUATETITLE,AdrDat.MAIL,AdrDat.DEPARTMENT,AdrDat.DEPARTMENTTEXT,AdrDat.MAINFUNC,AdrDat.BUILDING,AdrDat.ROOMNUMBER,AdrDat.POSTOFFICEBOX,AdrDat.TELNUMBER,AdrDat.ALTERNPHONE,AdrDat.SECUREPHONE,AdrDat.FAXNUMBER,AdrDat.PERSONALFAX,AdrDat.FAXNUMSEC,AdrDat.MOBILE,AdrDat.VIDCONFNUM1,AdrDat.VIDCONFNUM2,AdrDat.PAGER,AdrDat.NETMEETING,AdrDat.URLPERS,AdrDat.PERSREMARK,AdrDat.ROBINSON,AdrDat.SECRETARY,AdrDat.REPRESENTATION,AdrDat.SPONSOR,AdrDat.COSTLOCATION,AdrDat.COSTLOCUNIT,AdrDat.ORGID,AdrDat.PERSIDNUM,AdrDat.MAIDENT,AdrDat.APPKEY,AdrDat.SCDID,AdrDat.GID,AdrDat.USERTYPE,AdrDat.RECORDTYPE,AdrDat.CONTRACTSTAT,AdrDat.JOINDATE,AdrDat.VALIDDATE,AdrDat.LEAVEDATE,AdrDat.EXPIREDATE,AdrDat.RELEASEEXT,AdrDat.LIEFNTNR,AdrDat.LIEFNR,AdrDat.ISINSCD,AdrDat.LIEFERKEY,AdrDat.NICKNAM,AdrDat.ORGCODEID,AdrDat.UNITID,AdrDat.UNIT,AdrDat.MANAGER1,AdrDat.MANAGER2,AdrDat.MANAGERF1,AdrDat.MANAGERF2,AdrDat.MANAGERF3,AdrDat.DEPARTMENTNAT,AdrDat.MASTAT,AdrDat.AZUBIEND,AdrDat.RESTSTART,AdrDat.RESTEND,AdrDat.VIP,AdrDat.ITACC,AdrDat.DELEGATION,AdrDat.GPCOMPANY,AdrDat.REQPKI,AdrDat.REQBADGE,AdrDat.REQACC,AdrDat.REQMBOX,AdrDat.REQMAIL,AdrDat.COMPANYCODE,AdrDat.MGMTRESP,AdrDat.NOTWEBVISIBLE,AdrDat.MAILPRIV,AdrDat.MOBILEPRIV,AdrDat.GCC,AdrDat.DIVISION,AdrDat.ORGIDPERIOD,AdrDat.ORGIDCLASS,AdrDat.WCUNIT,AdrDat.ACTIONTYPE,AdrDat.ACTIONREASON,AdrDat.ACTIONSTART,AdrDat.MAKREIS,AdrDat.MAGRUPPE,AdrDat.JUPER,AdrDat.PREFSN,AdrDat.ORGLEVA,AdrDat.ORGLEVB,AdrDat.ORGLEVC,AdrDat.ORGLEVD,AdrDat.ORGLEVX,AdrDat.ALTOU,AdrDat.FKSOURCE,AdrDat.PREFPRONOUN,AdrDat.COFRES
FROM	AdrDat
WHERE	isInScd = 4;

ALTER VIEW adrmak OWNER TO scd_testuser;
CREATE OR REPLACE VIEW app_config (config_id, app_id, key, description, value) AS select config_id, app_id
, key, description, value
FROM vrt.app_config

union

select (select max(config_id) from vrt.app_config) + row_number() OVER () AS rownum,
(select app_id from vrt.app where name = 'COL_SERV')
, nr, txt, wert from (
select konfignr||'.'||sprache nr, txt, wert
from konfig
order by konfignr desc
) alias3
order by config_id desc;

ALTER VIEW app_config OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW v_bpr_export (c, o, ou, l, department, ut, account, bv, new_emp_pki, new_emp_idcard, term_pki, term_idcard, renew_idcard) AS SELECT DISTINCT k.c,  k.o,  k.ou,  k.l, CAST( k.department AS varchar(255)) department, UT, BV,  account, NEW_EMP_PKI,    NEW_EMP_IDCARD,    TERM_PKI,    TERM_IDCARD,   RENEW_IDCARD
  FROM mv_bpr_konfig k;

ALTER VIEW v_bpr_export OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW v_sgid_sync_data (rowid, gid, valid_date, leave_date, user_type, owner, join_date, sponsor, c, o, ou, l, appl_internal_id, appl_name, confirmed, scd, isinscd, delete_date, delete_uid, modify_data_date, modify_data_uid, confirm_date, sync_date, creator, creation_date, surname, given_name, name_prefix, name_suffix, birth_date, birth_place, birth_name, gender, modify_user_date, modify_user_uid, orig_gid) AS SELECT	d.rowid AS rowid, d.GID,d.VALID_DATE,d.LEAVE_DATE,d.USER_TYPE,d.OWNER,d.JOIN_DATE,d.SPONSOR,d.C,d.O,d.OU,d.L,d.APPL_INTERNAL_ID,d.APPL_NAME,d.CONFIRMED,d.SCD,d.ISINSCD,d.DELETE_DATE,d.DELETE_UID,d.MODIFY_DATA_DATE,d.MODIFY_DATA_UID,d.CONFIRM_DATE,d.SYNC_DATE
	,	u.creator
	,	u.creation_date
	,	u.surname
	,	u.given_name
	,	u.name_prefix
	,	u.name_suffix
	,	u.birth_date
	,	u.birth_place
	,	u.birth_name
	,	u.gender
	,	u.modify_user_date
	,	u.modify_user_uid
	,	u.orig_gid
	FROM	gid_data d, gid_user u
	WHERE	u.gid = d.gid
	AND	isinscd >= 0
	AND	scd = '1'
	AND	confirmed = '1'
	ORDER  BY	d.gid,	delete_uid
--			zuerst die Löschungen	...
			,
		(sign(leave_date - statement_timestamp())	- 1)
		  *	(leave_date - statement_timestamp())	DESC
--			dann alle historischen
--			die ältesten zuerst	...
			,
		(sign(valid_date - statement_timestamp())	+ 1)
		  *	(valid_date - statement_timestamp())
--			dann alle zukünftigen
--			die nähesten zuletzt	...
--
--		zuletzt die aktuellen, mit (0,0)	...
;

ALTER VIEW v_sgid_sync_data OWNER TO scd_testuser;
*/






/*
CREATE OR REPLACE VIEW gid_exp_log (start, dauer, cpu, status, errors, output, info) AS SELECT	to_char(actual_start_date, 'YYYY-MM-DD HH24:MI:SS')
					Start
,	substr(to_char(run_duration),9)	Dauer
,	substr(to_char(cpu_used),9)	CPU
,	status,  errors
,	binary_output			Output
,	additional_info			Info
--
FROM	USER_SCHEDULER_JOB_RUN_DETAILS
WHERE	job_name =	'GID_EXP_J'
ORDER	BY	1 DESC	;

ALTER VIEW gid_exp_log OWNER TO scd_testuser;
*/



CREATE OR REPLACE VIEW v_fits_mastatx (gid, givenname, sn, nickname, department, l, o, c, salid, building, roomnumber, usertype, recordtypev3, contractstatus, sponsor, gidman1, costlocationunit, costlocation, ou, unit, mail, telephonenumber, mobile, status, leavedate, validdate, orgid, gpcompany, personalidnumber, ofk, lifecycleevent, lifecycledate, privatemail, privatemobile, pkiversion, certindicator, mastat, azubiend, companycode, firmstat, deliveryid, clientid, preferredsn, altou, clientname, countryofresidence, gidman2) AS (
SELECT s.GID
, s.GivenName
, s.sn
, coalesce(s.nickName,s.GivenName) nickName
, s.Department
, s.L
, s.O
, s.C
, s.salid
, s.building
, s.roomNumber
, s.usertype
, s.recordTypeV3
, s.contractstatus
, s.sponsor
, s.gidMan1
, s.costLocationUnit
, s.costLocation
, s.OU
, s.unit
, s.mail
, s.telephoneNumber
, s.mobile
, s.status
, s.leaveDate
, s.validDate
, s.orgid
, s.gpCompany
, s.personalIdnumber
,  CASE WHEN s.mgmtLevel='A' THEN '1' WHEN s.mgmtLevel='B' THEN '1'  ELSE '0' END  OFK
, coalesce(s.lifeCycleEvent)	lifeCycleEvent
, s.lifeCycleDate
, '' privateMail
, '' privateMobile
, s.pkiversion
, s.certIndicator
, coalesce(a.Mastat,'0') Mastat, a.Azubiend
, s.companyCode
, s.firmstat
, s.deliveryId
, s.clientID
, s.preferredSN
, s.altOU
, s.clientName
, s.countryOfResidence
, s.gidMan2
FROM vrt.scdx s
Left Join adrdat a 
On a.Liefntnr=2 and s.gid=a.gid 
   and s.c=a.c and s.o=a.o and s.ou=a.ou and s.l=a.l 
   and s.recordTypeV3=a.recordtype
  );

ALTER VIEW v_fits_mastatx OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW v_user_clientid (gid, c, o, ou, l, client_id) AS select a.gid, a.c, a.o, a.ou, a.l, client_id FROM user_clientid a
    RIGHT JOIN(select gid, min(rank) as r from user_clientid group by gid) b ON a.gid = b.gid and(a.rank = b.r OR (coalesce(a.rank::text, '') = '' and coalesce(b.r::text, '') = ''));

ALTER VIEW v_user_clientid OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW stmdatok (c, cnameeng, cnamenat, o, onameint, onamenat, ou, ounameshort, ounameint, ounamenat, l, lnameshort, lnameint, lnamenat, street, streetadrnat, postalcode, postadrint1, postadrint2, postadrnat1, postadrnat2, phonenumex, faxnumex, regofficeplant, urlo, urlou, urll, salid, utc, company, cgroup, liefnr, konzbet, konzstat, lnameeng, gps, isvirtual, stprovince, clientname, clientid) AS SELECT DISTINCT C
,CNameEng
,CNameNat
--
,	O
,ONameInt
,ONameNat
--
,	'-'	OU
,	NULL	OUNameShort
,	NULL	OUNameInt
,	NULL	OUNameNat
--
,	L
,LNameShort
,LNameInt
,LNameNat
,Street
,StreetAdrNat
,PostalCode
,PostAdrInt1
,PostAdrInt2
,PostAdrNat1
,PostAdrNat2
,PhoneNumEx
,FaxNumEx
,RegOfficePlant
--
,	UrlO
,	NULL	UrlOU
,	UrlL
,	SalID
,UTC
,Company
,CGroup
,LiefNr
,KonzBet
,KonzStat
,LnameEng
,GPS
--
,	NULL	isVirtual
,	StProvince
,ClientName
,ClientID
--
--
FROM	StmDat;

ALTER VIEW stmdatok OWNER TO scd_testuser;


CREATE OR REPLACE VIEW gid_datauser2 (gid, valid_date, leave_date, user_type, owner, join_date, sponsor, c, o, ou, l, appl_internal_id, appl_name, confirmed, scd, isinscd, delete_date, delete_uid, modify_data_date, modify_data_uid, confirm_date, sync_date, creator, creation_date, surname, given_name, name_prefix, name_suffix, birth_date, birth_place, birth_name, gender, modify_user_date, modify_user_uid) AS SELECT	d.GID,d.VALID_DATE,d.LEAVE_DATE,d.USER_TYPE,d.OWNER,d.JOIN_DATE,d.SPONSOR,d.C,d.O,d.OU,d.L,d.APPL_INTERNAL_ID,d.APPL_NAME,d.CONFIRMED,d.SCD,d.ISINSCD,d.DELETE_DATE,d.DELETE_UID,d.MODIFY_DATA_DATE,d.MODIFY_DATA_UID,d.CONFIRM_DATE,d.SYNC_DATE,
	u.creator,
	u.creation_date,
	u.surname,
	u.given_name,
	u.name_prefix,
	u.name_suffix,
	u.birth_date,
	u.birth_place,
	u.birth_name,
	u.gender,
	u.modify_user_date,
	u.modify_user_uid
FROM gid_user u
LEFT OUTER JOIN gid_data d ON (u.gid = d.gid);

ALTER VIEW gid_datauser2 OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW v_bpr_konfig (c, o, ou, l, department, ut, bv, new_emp_pki, new_emp_idcard, term_pki, term_idcard, change_ut_pki, change_ut_idcard, change_organisation_pki, change_organisation_idcard, change_name_pki, change_name_idcard, rule_number, renew_pki, renew_idcard, change_location_pki, change_location_idcard, access_mo_sa, access_mo_so, remove_it,remove_tools, mail_requestor, mail_cardholder, mail_sponsor, account, orgid, ordernr) AS SELECT DISTINCT k.c,  k.o,  k.ou,  k.l, CAST( k.department AS varchar(255)) department, UT,  BV, NEW_EMP_PKI,    NEW_EMP_IDCARD,    TERM_PKI,    TERM_IDCARD,    CHANGE_UT_PKI,    CHANGE_UT_IDCARD,CHANGE_ORGANISATION_PKI,CHANGE_ORGANISATION_IDCARD,CHANGE_NAME_PKI,CHANGE_NAME_IDCARD,RULE_NUMBER,RENEW_PKI,RENEW_IDCARD,CHANGE_LOCATION_PKI,CHANGE_LOCATION_IDCARD,ACCESS_MO_SA,ACCESS_MO_SO,REMOVE_IT,REMOVE_TOOLS,MAIL_REQUESTOR,MAIL_CARDHOLDER,MAIL_SPONSOR,ACCOUNT,orgid,ORDERNR
  FROM sds.bpr_konfig k
  WHERE SUBSTR(k.department,-1)<>'%'

UNION
 
  SELECT DISTINCT k.c,k.o,k.ou,k.l,s.department,ut,bv,new_emp_pki,NEW_EMP_IDCARD,TERM_PKI,TERM_IDCARD,CHANGE_UT_PKI,CHANGE_UT_IDCARD,CHANGE_ORGANISATION_PKI,CHANGE_ORGANISATION_IDCARD,CHANGE_NAME_PKI,CHANGE_NAME_IDCARD,RULE_NUMBER,RENEW_PKI,RENEW_IDCARD,CHANGE_LOCATION_PKI,CHANGE_LOCATION_IDCARD,ACCESS_MO_SA,ACCESS_MO_SO,REMOVE_IT,REMOVE_TOOLS,MAIL_REQUESTOR,MAIL_CARDHOLDER,MAIL_SPONSOR,ACCOUNT,orgid,ORDERNR
  FROM sds.bpr_konfig k, vrt.scd s
  WHERE k.c||'!'||k.o=s.c||'!'||s.o
  AND SUBSTR(k.department,-1)='%'
  AND k.ou                   ='*'
  AND k.l                    ='*'
 
UNION

  SELECT DISTINCT k.c,k.o,k.ou,k.l,s.department,UT,BV,NEW_EMP_PKI,NEW_EMP_IDCARD,TERM_PKI,TERM_IDCARD,CHANGE_UT_PKI,CHANGE_UT_IDCARD,CHANGE_ORGANISATION_PKI,CHANGE_ORGANISATION_IDCARD,CHANGE_NAME_PKI,CHANGE_NAME_IDCARD,RULE_NUMBER,RENEW_PKI,RENEW_IDCARD,CHANGE_LOCATION_PKI,CHANGE_LOCATION_IDCARD,ACCESS_MO_SA,ACCESS_MO_SO,REMOVE_IT,REMOVE_TOOLS,MAIL_REQUESTOR,MAIL_CARDHOLDER,MAIL_SPONSOR,ACCOUNT,orgid,ORDERNR
  FROM sds.bpr_konfig k,    vrt.scd s
  WHERE k.c||'!'||k.o||'!'||k.ou=s.c||'!'||s.o||'!'||s.ou AND k.l ='*'
  AND s."department" LIKE k.department AND SUBSTR(k.department,-1)='%' 

UNION

 SELECT DISTINCT k.c,    k.o,    k.ou,    k.l,    s.department,    UT,    BV,    NEW_EMP_PKI,    NEW_EMP_IDCARD,    TERM_PKI,    TERM_IDCARD,    CHANGE_UT_PKI,    CHANGE_UT_IDCARD,    CHANGE_ORGANISATION_PKI,
 CHANGE_ORGANISATION_IDCARD,    CHANGE_NAME_PKI,    CHANGE_NAME_IDCARD,    RULE_NUMBER,    RENEW_PKI,    RENEW_IDCARD,    CHANGE_LOCATION_PKI,    CHANGE_LOCATION_IDCARD,    ACCESS_MO_SA,
 ACCESS_MO_SO,    REMOVE_IT,    REMOVE_TOOLS,    MAIL_REQUESTOR,    MAIL_CARDHOLDER,    MAIL_SPONSOR,ACCOUNT,orgid,    ORDERNR
  FROM sds.bpr_konfig k,   vrt.scd s
  WHERE k.c||'!'||k.o||'!'||k.ou||'!'||k.l=s.c||'!'||s.o||'!'||s.ou||'!'||s.l
  AND k.ou                  <>'*'
  AND k.l                   <>'*'
  AND SUBSTR(k.department,-1)='%';

ALTER VIEW v_bpr_konfig OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW liefntsuz (liefntnr, liefntmin, liefntmax, senderid, stellvid, nick, mailsds, mailsuz, notify, sprache, zchnsatz, lieferart, lieferset, lieferkey, mainid, delta, bdsg, aptool, dgetid, isv3, txv3, ftread, pagids, updcurr, nosuz) AS SELECT	Liefnt.LIEFNTNR,Liefnt.LIEFNTMIN,Liefnt.LIEFNTMAX,Liefnt.SENDERID,Liefnt.STELLVID,Liefnt.NICK,Liefnt.MAILSDS,Liefnt.MAILSUZ,Liefnt.NOTIFY,Liefnt.SPRACHE,Liefnt.ZCHNSATZ,Liefnt.LIEFERART,Liefnt.LIEFERSET,Liefnt.LIEFERKEY,Liefnt.MAINID,Liefnt.DELTA,Liefnt.BDSG,Liefnt.APTOOL,Liefnt.DGETID,Liefnt.ISV3,Liefnt.TXV3,Liefnt.FTREAD,Liefnt.PAGIDS,Liefnt.UPDCURR, 0	noSuz
FROM	Liefnt	;

ALTER VIEW liefntsuz OWNER TO scd_testuser;




CREATE OR REPLACE VIEW stmgen (c, cnameeng, cnamenat, o, onameint, onamenat, ou, ounameshort, ounameint, ounamenat, l, lnameshort, lnameint, lnamenat, street, streetadrnat, postalcode, postadrint1, postadrint2, postadrnat1, postadrnat2, phonenumex, faxnumex, regofficeplant, urlo, urlou, urll, salid, utc, company, cgroup, liefnr, konzbet, konzstat, lnameeng, gps, isvirtual, stprovince, clientname, clientid) AS SELECT DISTINCT C
,CNameEng
,CNameNat
--
,	O
,ONameInt
,ONameNat
--
,	'-'	OU
,	NULL	OUNameShort
,	NULL	OUNameInt
,	NULL	OUNameNat
--
,	L
,LNameShort
,LNameInt
,LNameNat
,Street
,StreetAdrNat
,PostalCode
,PostAdrInt1
,PostAdrInt2
,PostAdrNat1
,PostAdrNat2
,PhoneNumEx
,FaxNumEx
,RegOfficePlant
--
,	UrlO
,	NULL	UrlOU
,	UrlL
,	SalID
,UTC
,Company
,CGroup
,LiefNr
,KonzBet
,KonzStat
,LnameEng
,GPS
--
,	NULL	isVirtual
,	StProvince
,ClientName
,ClientID
--
--
FROM	StmGenOU;

ALTER VIEW stmgen OWNER TO scd_testuser;


/*
CREATE OR REPLACE VIEW v_user_clientid_future (gid, c, o, ou, l, client_id) AS select a.gid, a.c, a.o, a.ou, a.l, client_id FROM user_clientid_future a
    RIGHT JOIN(select gid, min(rank) as r from user_clientid_future group by gid) b ON a.gid = b.gid and(a.rank = b.r OR (coalesce(a.rank::text, '') = '' and coalesce(b.r::text, '') = ''));

ALTER VIEW v_user_clientid_future OWNER TO scd_testuser;
*/


CREATE OR REPLACE VIEW v_fits_akt (gid, sponsor, valid_date, leave_date, c, o, ou, l, user_type, owner) AS SELECT	GID,SPONSOR,VALID_DATE,LEAVE_DATE,C,O,OU,L,USER_TYPE,OWNER
FROM	v_fits_base	x1
WHERE	valid_date	=
(
SELECT	Max(valid_date)
FROM	v_fits_base	x2
WHERE	x1.GID = x2.GID
);

ALTER VIEW v_fits_akt OWNER TO scd_testuser;










CREATE OR REPLACE VIEW attrchk (bez, txt, attr, feldnr, pflicht, nam, min, max, zchn, dat, col) AS SELECT	ASet.BEZ,ASet.TXT,ASet.ATTR,ASet.FELDNR,ASet.PFLICHT
,	(
CASE	WHEN (Attr.Txt::text <> '')
THEN	Replace(Attr.Txt,' ','_')
ELSE	Attr.Bez
END	)    Nam
--
,	Attr.Min
,	Attr.Max
,	Attr.Zchn
,	ADat.Bez	Dat
,	ADat.FeldNr	Col
--	
FROM attrsetv adat, attrsetv aset
LEFT OUTER JOIN attr ON (ASet.Attr = Attr.Bez)
WHERE ASet.Attr  =	ADat.Attr --		
;

ALTER VIEW attrchk OWNER TO scd_testuser;

CREATE OR REPLACE VIEW "sds"."stmgendn" ("c", "o", "ou", "l", "dn", "typ", "berchnr", "liefntnr", "mainid", "joins", "userset", "denyset", "login", "parmset", "urlsuz", "konzstat", "konzbet", "clientid")  AS 
  SELECT	S.c, S.o, S.ou, S.l
,	(
CASE	WHEN	DN.c	IS NULL
THEN	NULL	ELSE
	DN.c	||'!'	||
	DN.o	||'!'	||
	DN.ou	||'!'	||
	DN.l
END	)	dn,	typ
,	berchnr, liefntnr, mainid, joins
,	userset, denyset, login, parmset
,	urlsuz, konzstat, konzbet, clientid
FROM	stmgen S LEFT OUTER JOIN dn
--
ON	  S.c	=	DN.c	
AND	  S.o	=	DN.o	
AND  ' '||S.ou	=  ' '||DN.ou	
AND	  S.l	=	DN.l	
;
ALTER VIEW stmgendn OWNER TO scd_testuser;


/*
CREATE OR REPLACE VIEW "z$stmgen" (c, cnameeng, cnamenat, o, onameint, onamenat, konzbet, konzstat, clientname, clientid, ou, l, lnameshort, lnameint, lnamenat, street, streetadrnat, postalcode, postadrint1, postadrint2, postadrnat1, postadrnat2, phonenumex, faxnumex, regofficeplant, urlo, urll, salid, utc, company, cgroup, lnameeng, gps, stprovince) AS SELECT DISTINCT C, CNAMEENG, CNAMENAT
, O, ONAMEINT, ONAMENAT, KONZBET, KONZSTAT
, CLIENTNAME, CLIENTID, '-' OU
, L, LNAMESHORT, LNAMEINT, LNAMENAT, STREET, STREETADRNAT
, POSTALCODE, POSTADRINT1, POSTADRINT2, POSTADRNAT1, POSTADRNAT2
, coalesce(PHONENUMEX, (select min(PHONENUMEX) FROM stmgen where c=s.c and o=s.o and l=s.l)) "PHONENUMEX"
, coalesce("FAXNUMEX" ,  (select min("FAXNUMEX")   from stmgen where c=s.c and o=s.o and l=s.l)) "FAXNUMEX"
, "REGOFFICEPLANT"
, coalesce("URLO", (select min("URLO") from stmgen where c=s.c and o=s.o and l=s.l)) "URLO"
, coalesce("URLL", (select min("URLL") from stmgen where c=s.c and o=s.o and l=s.l)) "URLL"
, trim(both "SALID") "SALID", "UTC", "COMPANY", "CGROUP"
, "LNAMEENG", "GPS", "STPROVINCE"
from stmgen S;

ALTER VIEW "z$stmgen" OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW v_fits_mastat_export (gid, givenname, sn, nickname, department, l, o, c, salid, building, roomnumber, usertype, recordtypev3, contractstatus, sponsor, gidman1, costlocationunit, costlocation, ou, unit, mail, telephonenumber, mobile, status, leavedate, validdate, orgid, gpcompany, personalidnumber, ofk, lifecycleevent, lifecycledate, privatemail, privatemobile, pkiversion, certindicator, mastat, azubiend) AS (
select gid,	givenname,	sn,	nickname,	department
,	l,	o,	c,	salid,	building,	roomnumber,	usertype,	recordtypev3
,	contractstatus,	sponsor,	gidman1,	costlocationunit,	costlocation
,	ou,	unit,	mail,	telephonenumber,	mobile,	status,	leavedate,	validdate
,	orgid,	gpcompany,	personalidnumber
,	ofk ,	lifecycleevent,	lifecycledate
,	privatemail, privatemobile,	pkiversion,	certindicator
, mastat, azubiend
FROM sds.v_fits_mastat
where  ((("usertype"='I' or coalesce("usertype"::text, '') = '') 
  and ("contractstatus"<>'F' or coalesce("contractstatus"::text, '') = '')) or ("usertype" in ('X','T')))
  and (mastat<>'3' or coalesce(mastat::text, '') = '')

union

select GID,	"givenname",	"sn",	"nickname",	"department"
,	L,	O,	C,	"salid",	"building",	"roomnumber",	"usertype",	"recordtypev3"
,	"contractstatus",	"sponsor",	"gidman1",	"costlocationunit",	"costlocation"
,	OU,	"unit",	"mail",	"telephonenumber",	"mobile",	"status",	azubiend,	"validdate"
,	"orgid",	"gpcompany",	"personalidnumber"
,	'2' ,	"lifecycleevent",	"lifecycledate"
,	"privatemail", "privatemobile",	"pkiversion",	"certindicator"
, mastat, azubiend 
from sds.v_fits_mastat
where  ((("usertype"='I' or coalesce("usertype"::text, '') = '') 
  and ("contractstatus"<>'F' or coalesce("contractstatus"::text, '') = '')) or ("usertype" in ('X','T')))
  and mastat='3'

union

select GID,	"givenname",	"sn",	"nickname",	"department"
,	L,	O,	C,	"salid",	"building",	"roomnumber",	"usertype",	"recordtypev3"
,	"contractstatus",	"sponsor",	"gidman1",	"costlocationunit",	"costlocation"
,	OU,	"unit",	"mail",	"telephonenumber",	"mobile",	"status",	"leavedate",	"validdate"
,	"orgid",	CASE WHEN mastat='3' THEN 'Diplomand' WHEN mastat='4' THEN 'doktorand'  ELSE 'Extern' END ,	"personalidnumber"
,	'0',	"lifecycleevent",	"lifecycledate"
,	"privatemail", "privatemobile",	"pkiversion",	"certindicator"
, mastat, azubiend 
from sds.v_fits_mastat
where "usertype"='I' and  "contractstatus"='F'
);

ALTER VIEW v_fits_mastat_export OWNER TO scd_testuser;



CREATE OR REPLACE VIEW v_company_details (c, o, onameint, onamenat, urlo) AS select a.C,a.O,a.ONAMEINT,a.ONAMENAT,a.urlo
FROM (
select distinct C, O, ONAMEINT, ONAMENAT, URLO, count(URLO) anz
from sds.stmgen
where (clientid IN ('1','2') or coalesce(clientid::text, '') = '')
group by  C, O, ONAMEINT, ONAMENAT, URLO) a,
(select C, O, ONAMEINT, ONAMENAT, max(anz) anz from (
select distinct C, O, ONAMEINT, ONAMENAT, URLO, count(URLO) anz
from sds.stmgen
where (clientid IN ('1','2') or coalesce(clientid::text, '') = '')
group by  C, O, ONAMEINT, ONAMENAT, URLO) alias10
group by  C, O, ONAMEINT, ONAMENAT) b
where a.c = b.c and a.o = b.o and a.anz=b.anz;

ALTER VIEW v_company_details OWNER TO scd_testuser;



  CREATE OR REPLACE VIEW "sds"."dnstmgen" ("c", "o", "ou", "l", "dn", "typ", "berchnr", "liefntnr", "mainid", "joins", "userset", "denyset", "login", "parmset", "urlsuz", "konzstat", "konzbet", "clientid")   AS 
  SELECT	DN.c, DN.o, DN.ou, DN.l
,	(
CASE	WHEN	S.c	IS NULL
THEN	NULL	ELSE
	S.c	||'!'	||
	S.o	||'!'	||
	S.ou	||'!'	||
	S.l
END	)	dn,	typ
,	berchnr, liefntnr, mainid, joins
,	userset, denyset, login, parmset
,	urlsuz, konzstat, konzbet, clientid
FROM	stmgen S LEFT OUTER JOIN dn
--
ON	  DN.c	=	S.c	
AND	  DN.o	=	S.o	
AND  ' '||DN.ou	=  ' '||S.ou	
AND	  DN.l	=	S.l	
;


ALTER VIEW dnstmgen OWNER TO scd_testuser;








/*
CREATE OR REPLACE VIEW v_sgid_sync_data_exp (data) AS SELECT	rowid
||';'||gid
||';'||valid_date
||';'||leave_date
||';'||user_type
||';'||owner
||';'||join_date
||';'||sponsor
||';'||C
||';'||O
||';'||OU
||';'||L
||';'||appl_internal_id
||';'||appl_name
||';'||confirmed
||';'||SCD
||';'||ISINSCD
||';'||delete_date
||';'||delete_uid
||';'||modify_data_date
||';'||modify_data_uid
||';'||confirm_date
||';'||sync_date
||';'	||	creator
||';'	||	creation_date
||';'	||	surname
||';'	||	given_name
||';'	||	name_prefix
||';'	||	name_suffix
||';'	||	birth_date
||';'	||	birth_place
||';'	||	birth_name
||';'	||	gender
||';'	||	modify_user_date
||';'	||	modify_user_uid
||';'	||	orig_gid AS data
FROM v_sgid_sync_data;

ALTER VIEW v_sgid_sync_data_exp OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW dn_srq (c, o, ou, l, typ, mainid, sync, liefntnr, berchnr, joins, userset, urlsuz, denyset, login, parmset, clientid, srq_id, takeover, leave_max) AS SELECT	DN.C,DN.O,DN.OU,DN.L,DN.TYP,DN.MAINID,DN.SYNC,DN.LIEFNTNR,DN.BERCHNR,DN.JOINS,DN.USERSET,DN.URLSUZ,DN.DENYSET,DN.LOGIN,DN.PARMSET,DN.CLIENTID,	SRQ_ID,	TakeOver, leave_max
FROM (
--
SELECT DISTINCT DN.*,	ClientID
FROM	DN	LEFT	JOIN	StmGen	S
ON	DN.C =	S.C
AND	DN.O =	S.O
AND	DN.L =	S.L
--
)	DN	LEFT	JOIN	LIEFNT_SRQ	SR
ON	DN.MainID =	SR.MainID
AND	DN.C	Like	Replace(SR.C, '*', '%')
AND	DN.O	Like	Replace(SR.O, '*', '%')
AND	DN.L	Like	Replace(SR.L, '*', '%')
--
AND	position(SubStr(Typ, 1, 1) in UT) > 0;

ALTER VIEW dn_srq OWNER TO scd_testuser;



CREATE OR REPLACE VIEW sds.pgid (gid, c, user_type, owner, sponsor, valid_date, leave_date, deadline, reason) as SELECT
        gid,
        c,
        user_type,
        owner,
        sponsor,
        valid_date,
        leave_date,
        deadline,
        MIN(reason) AS reason
    FROM
        (
SELECT
                gu.gid   AS gid,
                gd.c,
                gd.user_type,
                gd.owner,
                gd.sponsor,
                gd.valid_date,
                gd.leave_date,
            1 as reason,
                statement_timestamp() + interval '1 day' * (select COALESCE (TO_NUMBER((SELECT value FROM sds.app_config WHERE key = 'pgid.sponsor.lvl1Threshold'), '999'),30)) AS deadline
            FROM
                sds.gid_data gd
                LEFT JOIN sds.gid_user gu ON gu.gid = gd.gid
            WHERE
                gd.user_type <> 'I'
                AND gd.isinscd =-1
                AND gd.delete_date is null 
                AND gd.leave_date > (
                    statement_timestamp() + interval '1 day' * (select COALESCE (TO_NUMBER((SELECT value FROM sds.app_config WHERE key = 'pgid.sponsor.lvl1Threshold'), '999'),30)))
                AND NOT EXISTS (
                    SELECT
                        gds.gid
                    FROM
                        sds.gid_data gds
                    WHERE
                        gds.gid = gd.sponsor
                        AND gds.delete_date is null
                        AND gds.valid_date <= DATE_TRUNC('day',statement_timestamp())
                        AND gds.leave_date >= DATE_TRUNC('day',statement_timestamp())
                        AND gds.user_type = 'I'
                )
UNION
SELECT
                gu.gid   AS y,
                gd.c,
                gd.user_type,
                gd.owner,
                gd.sponsor,
                gd.valid_date,
                gd.leave_date,
            1 as reason,
                statement_timestamp() +
                interval '1 day' * (select COALESCE (TO_NUMBER((SELECT value FROM sds.app_config WHERE key = 'pgid.sponsor.lvl1Threshold'), '999'),30))
            FROM
                sds.gid_data gd
                LEFT JOIN sds.gid_user gu ON gu.gid = gd.gid
            WHERE
                -- internal employees
                gd.user_type <> 'I'
                AND gd.isinscd =-1
                AND gd.delete_date is null
                -- gid will not leave before the level 1 treshold
                AND gd.leave_date >
                ( statement_timestamp() +
                 interval '1 day' * (select COALESCE (TO_NUMBER((SELECT value FROM sds.app_config WHERE key = 'pgid.sponsor.lvl1Threshold'), '999'),30)))
                AND ( EXISTS (
                    SELECT
                        gds.gid
                    FROM
                        sds.gid_data gds
                    JOIN sds.gid_user gus on gus.gid = gds.gid
                    WHERE
                        gds.gid = gd.sponsor
                        AND gds.delete_date is null
                        AND gds.valid_date <= DATE_TRUNC('day',statement_timestamp())
                        AND gds.leave_date >= DATE_TRUNC('day',statement_timestamp())
                        AND user_type = 'I'
                        AND gu.clientid <> gus.clientid
                ) )
            ) Alias30
    GROUP BY
        gid,
        c,
        user_type,
        owner,
        sponsor,
        valid_date,
        leave_date,
        deadline


ALTER VIEW pgid OWNER TO scd_testuser;



CREATE OR REPLACE VIEW v_fits_vor (gid, sponsor, valid_date, leave_date, c, o, ou, l, user_type, owner) AS SELECT	GID,SPONSOR,VALID_DATE,LEAVE_DATE,C,O,OU,L,USER_TYPE,OWNER
FROM	v_fits_base	x1
WHERE	valid_date	=
(
SELECT	Max(x2.valid_date)
FROM	v_fits_base	x2
JOIN	v_fits_base	x3
ON	x2.GID = x3.GID
WHERE	x1.GID = x2.GID
and	x2.valid_date < x3.valid_date
);

ALTER VIEW v_fits_vor OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW dnliefntattr (o, l, typ, attr, txt, joinbez, joinlfd, liefnt, lief_id, lieferset) AS select o,l,typ, attr,txt,
joinbez, joinlfd, jv_num liefnt, lief_id, lieferset
FROM (
select o,l,typ, joinbez, joinlfd, jv_num, jv_gid lief_id, joinset lieferset from dnliefnt

union

select o,l,typ, 'main', 0, lv_num, lv_gid, lv_set from dnliefnt
) L join(
select S.bez, S.attr, A.txt
from attrsetv S join attr A
on S.attr = A.bez
) A on A.bez = L.lieferset;

ALTER VIEW dnliefntattr OWNER TO scd_testuser;
*/


CREATE OR REPLACE VIEW liefnt_clientid (liefntnr, mainid, clientid) AS select liefntnr, mainid, 1 as clientid FROM liefnt where lieferart='RG00'

union
 select liefntnr, mainid, 2 from liefnt where lieferart='RG00'

union
 select liefntnr, mainid, 3 from liefnt where lieferart='RG00'

union
 select liefntnr, mainid, 1 from liefnt where lieferart='RG01'

union
 select liefntnr, mainid, 2 from liefnt where lieferart='RG02'

union
 select liefntnr, mainid, 3 from liefnt where lieferart='RG03'

union
 select distinct l.liefntnr,l.mainid,d.clientid
from liefnt l LEFT OUTER JOIN sds.dnstmgen d
   ON l.MAINID=d.mainid or l.liefntnr=d.liefntnr
where (clientid::text <> '') or lieferart='join';

ALTER VIEW liefnt_clientid OWNER TO scd_testuser;




CREATE OR REPLACE VIEW dn_info (c, o, ou, l, typ, bv, bv_nam, gv, gv_nam, lv, lv_nam, jv, jv_nam, lte, chcm, ciss, som, gids) AS select	DN.C, DN.O, DN.OU, DN.L
--
,	Substr(DN.Typ, 1, 1)	Typ
,	LV.BV_Gid		BV
,	LV.BV			BV_Nam
,	LV.GV_Num		GV
,	LV.GV			GV_Nam
,	LV.LV_Num		LV
,	LV.LV			LV_Nam
--
,	coalesce(JV_Num, 0)		JV
,	coalesce(JV, '-')		JV_nam
,	coalesce(LTE.JoinSet, '-')	LTE
,	coalesce(CHCM.JoinSet, '-')	CHCM
,	coalesce(CISS.JoinSet, '-')	CISS
,	coalesce(SOM.JoinSet, '-')	SOM
,	coalesce(GID.Anz, 0)		GIDs
FROM (
select	*	from (
select	distinct  C, O, OU, L
from	DN
where	C  is	Not Null
) alias8	,(
select	'IH'	Typ	

union

select	'TH'	Typ	

union

select	'XH'	Typ	
) alias9		)	DN
join(
select	distinct  C, O, OU, L, Typ
,	BV_Gid	,	BV
,	GV_Num	,	GV
,	LV_Num	,	LV
from	DnLiefnt
)			LV
on	DN.C	=	LV.C
and	DN.O	=	LV.O
and	DN.OU	=	LV.OU
and	DN.L	=	LV.L
and	DN.Typ	Like	Replace(trim(both LV.Typ), '*', '%')
--
left	join(
select	C, O, OU, L, Typ, JV_Num, JV
from	DnLiefnt
where	JV_Num	Not IN (3, 6, 7, 9)
)			JV
on	DN.C	=	JV.C
and	DN.O	=	JV.O
and	DN.OU	=	JV.OU
and	DN.L	=	JV.L
and	DN.Typ	Like	Replace(trim(both JV.Typ), '*', '%')
--
left	join(
select	C, O, OU, L, Typ, JoinSet
from	DnLiefnt
where	JV_Num	=	3
)			LTE
on	DN.C	=	LTE.C
and	DN.O	=	LTE.O
and	DN.OU	=	LTE.OU
and	DN.L	=	LTE.L
and	DN.Typ	Like	Replace(trim(both LTE.Typ), '*', '%')
--
left	join(
select	C, O, OU, L, Typ, JoinSet
from	DnLiefnt
where	JV_Num	=	6
)			CHCM
on	DN.C	=	CHCM.C
and	DN.O	=	CHCM.O
and	DN.OU	=	CHCM.OU
and	DN.L	=	CHCM.L
and	DN.Typ	Like	Replace(trim(both CHCM.Typ), '*', '%')
--
left	join(
select	C, O, OU, L, Typ, JoinSet
from	DnLiefnt
where	JV_Num	=	7
)			CISS
on	DN.C	=	CISS.C
and	DN.O	=	CISS.O
and	DN.OU	=	CISS.OU
and	DN.L	=	CISS.L
and	DN.Typ	Like	Replace(trim(both CISS.Typ), '*', '%')
--
left	join(
select	C, O, OU, L, Typ, JoinSet
from	DnLiefnt
where	JV_Num	=	9
)			SOM
on	DN.C	=	SOM.C
and	DN.O	=	SOM.O
and	DN.OU	=	SOM.OU
and	DN.L	=	SOM.L
and	DN.Typ	Like	Replace(trim(both SOM.Typ), '*', '%')
--
left	join(
select	C, O, OU, L
,	User_Type	Typ
,	Count(*)	Anz
from	GID_DataUser
where	coalesce(Delete_UID::text, '') = ''
and	Leave_Date >=	Trunc(statement_timestamp())
group	by	C, O, OU, L, User_Type
)			GID
on	DN.C	=	GID.C
and	DN.O	=	GID.O
and	DN.OU	=	GID.OU
and	DN.L	=	GID.L
and	DN.Typ	Like	trim(both GID.Typ) ||'%';

ALTER VIEW dn_info OWNER TO scd_testuser;



CREATE OR REPLACE VIEW v_fits_last (gid, sponsor, valid_date, leave_date, c, o, ou, l, user_type, owner, sponsor_old, valid_old, leave_old, c_old, o_old, ou_old, l_old, ut_old, owner_old) AS SELECT	A.GID,A.SPONSOR,A.VALID_DATE,A.LEAVE_DATE,A.C,A.O,A.OU,A.L,A.USER_TYPE,A.OWNER
,	V.sponsor	sponsor_old
,	V.valid_date	valid_old
,	V.leave_date	leave_old
,	V.C		C_old
,	V.O		O_old
,	V.OU		OU_old
,	V.L		L_old
,	V.user_type	UT_old
, V.owner owner_old
FROM		v_fits_akt	A
LEFT	JOIN	v_fits_vor	V
ON	A.GID = V.GID;

ALTER VIEW v_fits_last OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW dnattrresp (o, l, typ, attr, txt, joinbez, joinlfd, liefnt, lief_id, lieferset) AS select l.O,l.L,l.TYP,l.ATTR,l.TXT,l.JOINBEZ,l.JOINLFD,l.LIEFNT,l.LIEF_ID,l.LIEFERSET FROM DnLiefntAttr L
join(
select o,l,typ, txt, max(joinlfd) joinlfd
from DnLiefntAttr group by o,l,typ, txt
) M
on  l.o = M.o and l.l = M.l and l.typ = M.typ
and l.joinlfd = M.joinlfd and l.txt = M.txt
and l.o like '%';

ALTER VIEW dnattrresp OWNER TO scd_testuser;
*/




/* Section 1.5 Retry */

SET client_encoding TO 'UTF8';

SET search_path = sds,oracle,public;

SET check_function_bodies = false;


CREATE OR REPLACE FUNCTION sds.attchk ( atts text 		--  Name einer Attributmenge
 , vals text 		--  Attributwerte, durch '!' getrennt
 , msg text 		--  Basisschlüssel für Fehlermeldungen
 ) RETURNS varchar AS $body$
DECLARE

  att	AttrChk%ROWTYPE;
  val	varchar(1024);
  ret	varchar(4096);


BEGIN	FOR att  IN (
  SELECT * FROM AttrChk
    WHERE  Bez	=  atts
    AND	   Dat	=  atts
    ORDER  BY	FeldNr	)

  LOOP	val := StrWord(vals, att.FeldNr);
    ret := ret|| FldPrf(att, trim(both val), msg) ||'!';
    IF	Length(ret)  >	4000	THEN EXIT;
    END IF;
  END	LOOP;

  IF	coalesce(ret::text, '') = ''	THEN
    ret :=' '||atts||' '||msg|| '10!';
  END	IF;
  RETURN  ret;
END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER FUNCTION sds.attchk ( atts text 
 , vals text 
 , msg text 
 ) OWNER TO scd_testuser;
-- REVOKE ALL ON FUNCTION sds.attchk ( atts text  , vals text  , msg text  ) FROM PUBLIC;


CREATE OR REPLACE FUNCTION sds.fldprf ( att AttrChk , val text , msg text ) RETURNS varchar AS $body$
DECLARE

  len	bigint := Length(val);
  neg	boolean := SubStr(att.Zchn, 1,1) = '!';
  pos	boolean;
  fld	varchar(1024) := ' '||att.FeldNr||':'||att.Attr;
  err	varchar(1024);
  ret	varchar(1024) := val;


BEGIN
  IF	coalesce(att.Nam::text, '') = ''	THEN
    RETURN  fld||' '||msg||'10';
  END	IF;
  IF	position(att.Pflicht in '1YyTtJjWw') > 0
  AND	coalesce(len::text, '') = ''	THEN
    RETURN  fld||' '||msg||'15';
  END	IF;

  IF	position(att.Pflicht in '0NnFf') > 0
  AND	coalesce(len::text, '') = ''
  OR	len >= att.Min	THEN	NULL;	ELSE
  IF	att.Min > 0	THEN
    err :=' '||msg||'20:'|| att.Min;
  END	IF;
  END	IF;
  IF	len >  att.Max	THEN
    err :=' '||msg||'30:'|| att.Max;
  END	IF;

  IF	att.Attr  IN (
	'C', 'O', 'OU', 'L',
	'CN', 'Gender', 'GID'	)	THEN
    ret := Upper(ret);
  END	IF;
  IF	att.Attr  IN (
	'UrlO', 'UrlOU', 'UrlL',
	'UrlPers', 'Mail'	)	THEN
    ret := Lower(ret);
  END	IF;

  IF	Length(att.Zchn) > 0	THEN
  WHILE	    len > 0	LOOP
    pos := position(SubStr(ret,len,1) in att.Zchn) = 0;
    IF	pos <> neg	THEN
      err :=' '||msg||'60:'|| len||':'||
	SubStr(ret,len,1)  || err;
    END	IF;
    len := len - 1;
    IF	Length(err)  >	1000	THEN EXIT;
    END IF;
  END	LOOP;
  END	IF;

  IF	coalesce(err::text, '') = ''	THEN
    RETURN  ret;
  ELSE
    RETURN  fld || err;
  END	IF;
END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
ALTER FUNCTION sds.fldprf ( att AttrChk , val text , msg text ) OWNER TO scd_testuser;
-- REVOKE ALL ON FUNCTION sds.fldprf ( att AttrChk , val text , msg text ) FROM PUBLIC;

/* Section 6.7 - STAT View Creation */


-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = stat,oracle,public;

SET check_function_bodies = false;

CREATE OR REPLACE VIEW statistik_ldap_zugriffe (gj, zeitraum, zugriffe_standard, byte_standard, zugriffe_eldap, byte_eldap, pgp, scdlogin, pkilogin, anzahl_anwendungen_scdlogin, anzahl_anwendungen_pkilogin) AS SELECT	gj, Zeitraum
,	Zugriffe_Standard / 1000000	Zugriffe_Standard
,	Byte_Standard     / 1000000000	Byte_Standard
,	Zugriffe_eldap    / 1000000	Zugriffe_eldap
,	Byte_eldap        / 1000000000	Byte_eldap
--
,	( PGP1+PGP2+PGP3+PGP4+PGP5+PGP6+PGP7+PGP8
	) / 1000000	PGP
,	SCDLogin,	PKILogin
,	Anzahl_Anwendungen_SCDLogin
,	Anzahl_Anwendungen_PKILogin
FROM	Statistik_SCD	;

ALTER VIEW statistik_ldap_zugriffe OWNER TO scd_testuser;


CREATE OR REPLACE VIEW gid_user (gid, creator, creation_date, surname, given_name, name_prefix, name_suffix, birth_date, birth_place, birth_name, gender, modify_user_date, modify_user_uid, orig_gid, clientid) AS SELECT	GID,CREATOR,CREATION_DATE,SURNAME,GIVEN_NAME,NAME_PREFIX,NAME_SUFFIX,BIRTH_DATE,BIRTH_PLACE,BIRTH_NAME,GENDER,MODIFY_USER_DATE,MODIFY_USER_UID,ORIG_GID,CLIENTID
FROM	sds.GID_USER	;



ALTER VIEW gid_user OWNER TO scd_testuser;
CREATE OR REPLACE VIEW scd (c, o, ou, l, cn, sn, givenname, commonnamenational, initials, gender, personaltitle, graduatetitle, mainfunction, department, building, roomnumber, "x400-address", mail, telephonenumber, faxnumber, secretary, gidsec, representation, gidrep, mobile, videoconferencenumber1, videoconferencenumber2, publickey, pager, costlocation, personalidnumber, securephone, alternatephone, personalfax, faxnumbersec, netmeeting, scdid, maident, gid, postofficebox, costlocationunit, surnamenational, givennamenational, departmenttext, releaseextern, personalremark, labeleduri, expiredate, validdate, leavedate, joindate, modifytimestamp, salid, recordtype, recordtypev3, konzbet, utc, firmstat, usertype, contractstatus, status, sponsor, snampre, snamadd, lastname, appkey, scdversion, pkiversion, robinson, createtimestamp, ende, localityinternational, localitynational, deliveryid, tcgid, certindicator, x509, pgp, kaw, kraw, kueraw, kvs, krvs, kruevs, kpost, orgid, orgidflag, nickname, displayname, departmentnumber, unitid, unit, gidman1, gidman2, gidmanf1, gidmanf2, gidmanf3, departmenttextnational, delegation, itacc, reqacc, reqmail, reqmbox, reststart, restend, vip, companycode, mgmtresp, notwebvisible, gpcompany, mgmtlevel, lifecycleevent, lifecycledate, mailpriv, mobilepriv, wcunit, actiontype, actionreason, actionstartdate, preferredsn, orglevela, orglevelb, orglevelc, orgleveld, orglevelx, altou, clientid) AS SELECT	C,O,OU,L,CN,sn,GivenName,commonNameNational,Initials,gender,personalTitle,graduateTitle,mainFunction,Department,building,roomNumber,'X400-address',mail,telephoneNumber,faxNumber,Secretary,gidSec,Representation,gidRep,mobile,videoConferenceNumber1,videoConferenceNumber2,publicKey,Pager,costLocation,personalIdnumber,securePhone,alternatePhone,personalFax,faxNumberSec,Netmeeting,scdId,maIdent,GID,postOfficeBox,costLocationUnit,surnameNational,givenNameNational,departmentText,releaseExtern,personalRemark,labeledURI,expireDate,validDate,leaveDate,joinDate,modifyTimeStamp,salid,recordType,recordTypeV3,konzBet,utc,firmstat,usertype,contractstatus,status,sponsor,snampre,snamadd,lastName,appkey,scdVersion,pkiversion,robinson,createTimeStamp,ENDE,localityInternational,localityNational,deliveryId,tcgid,certIndicator,X509,PGP,kAW,krAW,kuerAW,kVS,krVS,krueVS,kPost,orgid,orgidFlag,nickName,displayName,departmentNumber,unitId,unit,gidMan1,gidMan2,gidManF1,gidManF2,gidManF3,departmentTextNational,delegation,itAcc,reqAcc,reqMail,reqMBox,restStart,restEnd,vip,companyCode,mgmtResp,notWebVisible,gpCompany,mgmtLevel,lifeCycleEvent,lifeCycleDate,mailPriv,mobilePriv,wcUnit,actionType,actionReason,actionStartDate,preferredSN,orgLevelA,orgLevelB,orgLevelC,orgLevelD,orgLevelX,altOU,clientID
FROM	vrt.SCD;

ALTER VIEW scd OWNER TO scd_testuser;
CREATE OR REPLACE VIEW dn (c, o, ou, l, typ, mainid, sync, liefntnr, berchnr, joins, userset, urlsuz, denyset, login, parmset) AS SELECT	C,O,OU,L,TYP,MAINID,SYNC,LIEFNTNR,BERCHNR,JOINS,USERSET,URLSUZ,DENYSET,LOGIN,PARMSET
FROM	sds.DN;

ALTER VIEW dn OWNER TO scd_testuser;
CREATE OR REPLACE VIEW stmgen (c, cnameeng, cnamenat, o, onameint, onamenat, ou, ounameshort, ounameint, ounamenat, l, lnameshort, lnameint, lnamenat, street, streetadrnat, postalcode, postadrint1, postadrint2, postadrnat1, postadrnat2, phonenumex, faxnumex, regofficeplant, urlo, urlou, urll, salid, utc, company, cgroup, liefnr, konzbet, konzstat, lnameeng, gps, isvirtual, stprovince, clientname, clientid) AS SELECT	C,CNAMEENG,CNAMENAT,O,ONAMEINT,ONAMENAT,OU,OUNAMESHORT,OUNAMEINT,OUNAMENAT,L,LNAMESHORT,LNAMEINT,LNAMENAT,STREET,STREETADRNAT,POSTALCODE,POSTADRINT1,POSTADRINT2,POSTADRNAT1,POSTADRNAT2,PHONENUMEX,FAXNUMEX,REGOFFICEPLANT,URLO,URLOU,URLL,SALID,UTC,COMPANY,CGROUP,LIEFNR,KONZBET,KONZSTAT,LNAMEENG,GPS,ISVIRTUAL,STPROVINCE,CLIENTNAME,CLIENTID
FROM	sds.STMGEN	;

ALTER VIEW stmgen OWNER TO scd_testuser;
CREATE OR REPLACE VIEW gid_data (gid, valid_date, leave_date, user_type, owner, join_date, sponsor, c, o, ou, l, appl_internal_id, appl_name, confirmed, scd, isinscd, delete_date, delete_uid, modify_data_date, modify_data_uid, confirm_date, sync_date) AS SELECT	GID,VALID_DATE,LEAVE_DATE,USER_TYPE,OWNER,JOIN_DATE,SPONSOR,C,O,OU,L,APPL_INTERNAL_ID,APPL_NAME,CONFIRMED,SCD,ISINSCD,DELETE_DATE,DELETE_UID,MODIFY_DATA_DATE,MODIFY_DATA_UID,CONFIRM_DATE,SYNC_DATE
FROM	sds.GID_DATA	;

ALTER VIEW gid_data OWNER TO scd_testuser;
CREATE OR REPLACE VIEW adrdat (c, o, ou, l, cn, sn, gn, cnamnat, snamnat, snampre, snamadd, gnamnat, lastnam, i, gender, personaltitle, graduatetitle, mail, department, departmenttext, mainfunc, building, roomnumber, postofficebox, telnumber, alternphone, securephone, faxnumber, personalfax, faxnumsec, mobile, vidconfnum1, vidconfnum2, pager, netmeeting, urlpers, persremark, robinson, secretary, representation, sponsor, costlocation, costlocunit, orgid, persidnum, maident, appkey, scdid, gid, usertype, recordtype, contractstat, joindate, validdate, leavedate, expiredate, releaseext, liefntnr, liefnr, isinscd, lieferkey, nicknam, orgcodeid, unitid, unit, manager1, manager2, managerf1, managerf2, managerf3, departmentnat, mastat, azubiend, reststart, restend, vip, itacc, delegation, gpcompany, reqpki, reqbadge, reqacc, reqmbox, reqmail, companycode, mgmtresp, notwebvisible, mailpriv, mobilepriv, gcc, division, orgidperiod, orgidclass, wcunit, actiontype, actionreason, actionstart, makreis, magruppe, juper, prefsn, orgleva, orglevb, orglevc, orglevd, orglevx, altou) AS SELECT	C,O,OU,L,CN,SN,GN,CNAMNAT,SNAMNAT,SNAMPRE,SNAMADD,GNAMNAT,LASTNAM,I,GENDER,PERSONALTITLE,GRADUATETITLE,MAIL,DEPARTMENT,DEPARTMENTTEXT,MAINFUNC,BUILDING,ROOMNUMBER,POSTOFFICEBOX,TELNUMBER,ALTERNPHONE,SECUREPHONE,FAXNUMBER,PERSONALFAX,FAXNUMSEC,MOBILE,VIDCONFNUM1,VIDCONFNUM2,PAGER,NETMEETING,URLPERS,PERSREMARK,ROBINSON,SECRETARY,REPRESENTATION,SPONSOR,COSTLOCATION,COSTLOCUNIT,ORGID,PERSIDNUM,MAIDENT,APPKEY,SCDID,GID,USERTYPE,RECORDTYPE,CONTRACTSTAT,JOINDATE,VALIDDATE,LEAVEDATE,EXPIREDATE,RELEASEEXT,LIEFNTNR,LIEFNR,ISINSCD,LIEFERKEY,NICKNAM,ORGCODEID,UNITID,UNIT,MANAGER1,MANAGER2,MANAGERF1,MANAGERF2,MANAGERF3,DEPARTMENTNAT,MASTAT,AZUBIEND,RESTSTART,RESTEND,VIP,ITACC,DELEGATION,GPCOMPANY,REQPKI,REQBADGE,REQACC,REQMBOX,REQMAIL,COMPANYCODE,MGMTRESP,NOTWEBVISIBLE,MAILPRIV,MOBILEPRIV,GCC,DIVISION,ORGIDPERIOD,ORGIDCLASS,WCUNIT,ACTIONTYPE,ACTIONREASON,ACTIONSTART,MAKREIS,MAGRUPPE,JUPER,PREFSN,ORGLEVA,ORGLEVB,ORGLEVC,ORGLEVD,ORGLEVX,ALTOU
FROM	sds.ADRDAT;

ALTER VIEW adrdat OWNER TO scd_testuser;
/*CREATE OR REPLACE VIEW sla_prozent_ldap (gj, datum, anzahl_2, kl_1_sec_2, kl_2_sec_2, kl_10_sec_2) AS SELECT	fiscal_year		gj
,	day_id			datum
--
,	SUM(Anzahl)			Anzahl_2
,	SUM(ldap1 *100) / SUM(Anzahl)	kl_1_sec_2
,	SUM(ldap2 *100) / SUM(Anzahl)	kl_2_sec_2
,	SUM(ldap10*100)	/ SUM(Anzahl)	kl_10_sec_2
--
FROM	sla_auswertung	aus
,	calendar	cal
WHERE	aus.jahr  =	cal.year_id
AND	aus.monat =	MONTH_NUM_OF_YEAR
AND	cal.day_num_of_month =	1
--
GROUP	BY  fiscal_year, day_id	;

ALTER VIEW sla_prozent_ldap OWNER TO scd_testuser;
*/
CREATE OR REPLACE VIEW prot (liefnr, senderid, liefntnr, lieferart, status, grund, liefanz, liefende, prfanz, prfende, makanz, makende, pid, makstart) AS SELECT	LIEFNR,SENDERID,LIEFNTNR,LIEFERART,STATUS,GRUND,LIEFANZ,LIEFENDE,PRFANZ,PRFENDE,MAKANZ,MAKENDE,PID,MAKSTART
FROM	sds.PROT	;

ALTER VIEW prot OWNER TO scd_testuser;
CREATE OR REPLACE VIEW konfig (konfignr, sprache, txt, wert) AS SELECT	KONFIGNR,SPRACHE,TXT,WERT
FROM	sds.KONFIG	;

ALTER VIEW konfig OWNER TO scd_testuser;
CREATE OR REPLACE VIEW liefnt (liefntnr, liefntmin, liefntmax, senderid, stellvid, nick, mailsds, mailsuz, notify, sprache, zchnsatz, lieferart, lieferset, lieferkey, mainid, delta, bdsg, aptool, dgetid, isv3, txv3, ftread, pagids, updcurr) AS SELECT	LIEFNTNR,LIEFNTMIN,LIEFNTMAX,SENDERID,STELLVID,NICK,MAILSDS,MAILSUZ,NOTIFY,SPRACHE,ZCHNSATZ,LIEFERART,LIEFERSET,LIEFERKEY,MAINID,DELTA,BDSG,APTOOL,DGETID,ISV3,TXV3,FTREAD,PAGIDS,UPDCURR
FROM	sds.LIEFNT	;

/*ALTER VIEW liefnt OWNER TO scd_testuser;
CREATE OR REPLACE VIEW sla_prozent_http (gj, datum, anzahl_2, kl_1_sec_2, kl_2_sec_2, kl_10_sec_2) AS SELECT	fiscal_year		gj
,	day_id			datum
--
,	SUM(Anzahl)			Anzahl_2
,	SUM(http1 *100) / SUM(Anzahl)	kl_1_sec_2
,	SUM(http2 *100) / SUM(Anzahl)	kl_2_sec_2
,	SUM(http10*100)	/ SUM(Anzahl)	kl_10_sec_2
--
FROM	sla_auswertung	aus
,	calendar	cal
WHERE	aus.jahr  =	cal.year_id
AND	aus.monat =	MONTH_NUM_OF_YEAR
AND	cal.day_num_of_month =	1
--
GROUP	BY  fiscal_year, day_id	;
ALTER VIEW sla_prozent_http OWNER TO scd_testuser;

*/
CREATE OR REPLACE VIEW sla_auswertung_akt (typ, jahr, monat, von, bis, anzahl, noping, ldap0, ldap1, ldap2, ldap10, ldaperr, http0, http1, http2, http10, httperr) AS SELECT		trim(both Typ)			Typ
,	To_Char(DateVon, 'YYYY')	Jahr
,	To_Char(DateVon, 'MM'  )	Monat
--
,	Min(DateVon)		von
,	Max(DateBis)		bis
,	Greatest(		Sum(IsLdap)	,		Sum(IsHttp)	)	Anzahl
,	Sum(Anz - AnzOk)	noPing
--
,	Round(Avg(IsLdap * QueryTime) * 2)	ldap0
,	Sum(IsLdap * (CASE WHEN QueryTime < 1000 THEN 1 ELSE 0 END))	ldap1
,	Sum(IsLdap * (CASE WHEN QueryTime < 2000 THEN 1 ELSE 0 END))	ldap2
,	Sum(IsLdap * (CASE WHEN QueryTime <10000 THEN 1 ELSE 0 END))	ldap10
,	Sum(IsLdap * (Anz - AnzOk))		ldapErr
--
,	Round(Avg(IsHttp * QueryTime) * 2)	http0
,	Sum(IsHttp * (CASE WHEN QueryTime < 1000 THEN 1 ELSE 0 END))	http1
,	Sum(IsHttp * (CASE WHEN QueryTime < 2000 THEN 1 ELSE 0 END))	http2
,	Sum(IsHttp * (CASE WHEN QueryTime <10000 THEN 1 ELSE 0 END))	http10
,	Sum(IsHttp * (Anz - AnzOk))		httpErr	FROM		(
SELECT	Typ,	DateVon, DateBis
,	Anz,	AnzOK
--
,	Ping + DNS + LdapReply		QueryTime
,	(CASE WHEN coalesce(Url::text, '') = '' Then 1 ELSE 0 END)	IsLdap
,	(CASE WHEN coalesce(Url::text, '') = '' Then 0 ELSE 1 END)	IsHttp
--
FROM	QueryDat Q, Shadow S
WHERE	Shadow = Name	 AND	Q.Port = S.Port
AND	Use	 Like	'%A%'	) alias33
GROUP	BY	Typ
,	To_Char(DateVon, 'YYYY')
,	To_Char(DateVon, 'MM')	;

ALTER VIEW sla_auswertung_akt OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mesg (mesgnr, sprache, typ, txt) AS SELECT	MESGNR,SPRACHE,TYP,TXT
FROM	sds.MESG;

ALTER VIEW mesg OWNER TO scd_testuser;
CREATE OR REPLACE VIEW ggw_method_count (id, counter, event_date, method, requestor, u_id) AS SELECT	ID,COUNTER,EVENT_DATE,METHOD,REQUESTOR,U_ID
FROM	sds.GGW_METHOD_COUNT	;

ALTER VIEW ggw_method_count OWNER TO scd_testuser;
CREATE OR REPLACE VIEW gid_datauser (gid, valid_date, leave_date, user_type, owner, join_date, sponsor, c, o, ou, l, appl_internal_id, appl_name, confirmed, scd, isinscd, delete_date, delete_uid, modify_data_date, modify_data_uid, confirm_date, sync_date, creator, creation_date, surname, given_name, name_prefix, name_suffix, birth_date, birth_place, birth_name, gender, modify_user_date, modify_user_uid, orig_gid, clientid) AS SELECT	GID,VALID_DATE,LEAVE_DATE,USER_TYPE,OWNER,JOIN_DATE,SPONSOR,C,O,OU,L,APPL_INTERNAL_ID,APPL_NAME,CONFIRMED,SCD,ISINSCD,DELETE_DATE,DELETE_UID,MODIFY_DATA_DATE,MODIFY_DATA_UID,CONFIRM_DATE,SYNC_DATE,CREATOR,CREATION_DATE,SURNAME,GIVEN_NAME,NAME_PREFIX,NAME_SUFFIX,BIRTH_DATE,BIRTH_PLACE,BIRTH_NAME,GENDER,MODIFY_USER_DATE,MODIFY_USER_UID,ORIG_GID,CLIENTID
FROM	sds.GID_DATAUSER	;

ALTER VIEW gid_datauser OWNER TO scd_testuser;
/*CREATE OR REPLACE VIEW scdauswertung_mit_are (c, o, ou, o_ou, are, eintraege, scdids, telefon, telefon2, telefax, handy, mailadressen, zertifikate, pgp, x509, rs, pki1, pki2, usertype, recordtype, recordtypev3, status, expiredate, validdate, leavedate, clientid) AS SELECT	C,	O,	OU
,	O	||	OU		O_OU
,	costLocationUnit		ARE
--
,	COUNT(*)			Eintraege
,	COUNT(scdId)		scdIds
,	COUNT(telephoneNumber)	Telefon
,	COUNT(alternatePhone)	Telefon2
,	COUNT(faxNumber)		Telefax
,	COUNT(mobile)		Handy
,	COUNT(mail)			MailAdressen
--
,	COUNT(CASE WHEN 	certIndicator='TRUE' THEN  1  ELSE NULL END 	)	Zertifikate
,	COUNT(CASE WHEN PGP=1 THEN  1  ELSE NULL END )		PGP
,	COUNT(CASE WHEN coalesce(pkiversion::text, '') = '' THEN  NULL  ELSE 1 END )	X509
,	COUNT(CASE WHEN coalesce(Department::text, '') = '' THEN  1  ELSE NULL END )	RS
,	COUNT(CASE WHEN pkiversion='PKI1' THEN  1  ELSE NULL END )	pki1
,	COUNT(CASE WHEN pkiversion='PKI2' THEN  1  ELSE NULL END )	pki2
--
,	CASE WHEN 	usertype='T' THEN 'Team' WHEN 	usertype='I' THEN 'Intern' WHEN 	usertype='X' THEN 'Extern'	 END 	usertype
,	recordType,	recordTypeV3, status
,	expireDate,	validDate,	leaveDate
,	clientID clientid
FROM	SCD

WHERE	"recordTypeV3"	!=	'Z'
AND	"firmstat"	NOT IN ('B','C')
GROUP	BY	"C",	"O",	"OU",	"O" || "OU"
,	"costLocationUnit", "status"
,	"usertype",	"recordType",	"recordTypeV3"
,	"expireDate",	"validDate",	"leaveDate"
,	"clientID"	;

ALTER VIEW scdauswertung_mit_are OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW sncount (sn, anzahl) AS SELECT	sn		SN
,	count(sn) 	Anzahl
FROM	SCD
GROUP	BY  "sn"	;

ALTER VIEW sncount OWNER TO scd_testuser;
CREATE OR REPLACE VIEW protmax (liefnr, liefntnr, anzdaten, lieferdatumzeit, anzdatenok, pruefendedatumzeit, weiterldatumzeit) AS SELECT	pmax.liefnr,	pmax.liefntnr
,	ABS(p1.LIEFANZ)	anzdaten
,	LIEFENDE	lieferdatumzeit
,	PRFANZ		anzdatenok
,	PRFENDE		pruefendedatumzeit
,	p1.MAKENDE	weiterldatumzeit
FROM	sds.PROT	p1
,	(
SELECT			liefntnr
,	MAX(liefnr)	liefnr
FROM	PROT
GROUP	BY		liefntnr
	)		pmax
WHERE	p1.liefnr =	pmax.liefnr	;

ALTER VIEW protmax OWNER TO scd_testuser;
CREATE OR REPLACE VIEW laender (c, c_name_intern, c_name_national) AS SELECT	DISTINCT	C
,	trim(both cnameeng)	c_name_intern
,	trim(both cnamenat)	c_name_national
FROM	STMGEN	;

ALTER VIEW laender OWNER TO scd_testuser;
/*
CREATE OR REPLACE VIEW v_prot (jahr, monat, tag, geliefert, eingetragen, prf_sec, mak_sec) AS SELECT	TO_CHAR(LIEFENDE,'yyyy')	Jahr
,	TO_CHAR(LIEFENDE, 'mm' )	Monat
,	TO_CHAR(LIEFENDE, 'dd' )	Tag
,	ABS(LIEFANZ)			geliefert
,	MAKANZ				eingetragen
--
,	ABS(LIEFANZ) / (PRFENDE - LIEFENDE)
	/ 24/60/60			prf_sec
,	MAKANZ / ((MAKENDE - MAKSTART)
	* 24*60*60 + 1)			mak_sec
FROM	PROT
WHERE	PRFENDE > LIEFENDE
AND	MAKENDE > MAKSTART	;

ALTER VIEW v_prot OWNER TO scd_testuser;
*/
/*
CACHECREATE OR REPLACE VIEW v_scdauswertung (c, o, ou, are, eintraege, scdids, telefon, telefon2, telefax, handy, mailadressen, zertifikate, pgp, x509, rs, pki1, pki2, usertype, recordtype, status, recordtypev3, clientid) AS SELECT	C, O, OU, ARE
,	EINTRAEGE
,	SCDIDS
,	TELEFON
,	TELEFON2
,	TELEFAX
,	HANDY
,	MAILADRESSEN
--
,	ZERTIFIKATE
,	PGP
,	X509
,	RS
,	PKI1
,	PKI2
--
,	USERTYPE
,	recordType
,	status
,	recordTypeV3
,	CLIENTID
--
FROM	scdauswertung_mit_are
WHERE	"status" = 'A'
OR	coalesce("status"::text, '') = ''	;

ALTER VIEW v_scdauswertung OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW v_statistik_are (are, anz_i, anz_x, anz_t, clientid) AS SELECT	are
,	SUM(Anzahl_I)	Anz_I
,	SUM(Anzahl_X)	Anz_X
,	SUM(Anzahl_T)	Anz_T
,	CLIENTID
FROM (
SELECT	are
,	CASE WHEN usertype='Intern' THEN  anzahl  ELSE 0 END 	Anzahl_I
,	CASE WHEN usertype='Extern' THEN  anzahl  ELSE 0 END 	Anzahl_X
,	CASE WHEN usertype='Team' THEN    anzahl  ELSE 0 END 	Anzahl_T
,	CLIENTID
FROM (
SELECT	are,		usertype
,	SUM(Eintraege)	Anzahl
,	CLIENTID
FROM	scdauswertung_mit_are
WHERE	"recordTypeV3" <>	'S'
AND ("status" = 'A' OR coalesce("status"::text, '') = '')
GROUP	BY  are, usertype, clientid
) alias6	) alias7
GROUP	BY  are, clientid	;

ALTER VIEW v_statistik_are OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW geliefertedaten (liefntnr, liefnr, lieferdatum, geliefertedaten, datenok, qualitaet) AS SELECT	liefntnr,		liefnr
,	lieferdatumzeit		lieferdatum
,	anzdaten		GelieferteDaten
,	coalesce(anzdatenok, 0)	DatenOK
,	CASE WHEN 	anzDaten=0 THEN  0  ELSE ROUND	(	(ABS(10000 * anzDatenOK / anzDaten) / 100), 2	) END 		Qualitaet
FROM	PROTMAX		;

ALTER VIEW geliefertedaten OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW v_statistik_laender (c, c_name_intern, c_name_national, anzahl_i, anzahl_x, anzahl_t, clientid) AS SELECT	c
,	c_name_intern
,	c_name_national
,	SUM(anz_i)	anzahl_i
,	SUM(anz_x)	anzahl_x
,	SUM(anz_t)	anzahl_t
,	CLIENTID
FROM (
SELECT	c
,	c_name_intern
,	c_name_national
,	CASE WHEN usertype='Intern' THEN  Anzahl  ELSE 0 END 	anz_i
,	CASE WHEN usertype='Extern' THEN  Anzahl  ELSE 0 END 	anz_x
,	CASE WHEN usertype='Team' THEN    Anzahl  ELSE 0 END 	anz_t
,	cid	CLIENTID
FROM (
SELECT	scd.C
,	c_name_intern
,	c_name_national
,	SUM(Eintraege)	Anzahl
,	usertype
,	coalesce(CLIENTID, '1')	cid
--
FROM	SCDAuswertung_mit_are	scd
,	laender			la
WHERE	scd.C = la.C
AND	"recordTypeV3" <>	'S'
AND ("status" = 'A' OR coalesce("status"::text, '') = '')
--
GROUP	BY  scd.C
,	c_name_intern
,	c_name_national
,	usertype
,	coalesce(CLIENTID, '1')
) alias8	) alias9
GROUP	BY  c
,	c_name_intern
,	c_name_national
,	clientid
ORDER	BY  c, clientid	;

ALTER VIEW v_statistik_laender OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW statistik_verarbeitung (jahr, monat, geliefertedatenprostunde, eingetragenedatenprostunde, mw_datenpruefung_sec, max_datenpruefung_sec, min_datenpruefung_sec, mw_durchsatz_mak_sec, max_durchsatz_mak_sec, min_durchsatz_mak_sec) AS SELECT	Jahr,	Monat
,	SUM(geliefert)		gelieferteDatenProStunde
,	SUM(eingetragen)	eingetrageneDatenProStunde
--
,	ROUND(AVG(prf_sec))	MW_Datenpruefung_sec
,	ROUND(MAX(prf_sec))	Max_Datenpruefung_sec
,	ROUND(MIN(prf_sec))	Min_Datenpruefung_sec
--
,	ROUND(AVG(mak_sec))	MW_Durchsatz_Mak_sec
,	ROUND(MAX(mak_sec))	Max_Durchsatz_Mak_sec
,	ROUND(MIN(mak_sec))	Min_Durchsatz_Mak_sec
--
FROM	V_PROT
WHERE	to_date(jahr || monat, 'yyyymm')
  <	to_date(TO_CHAR(statement_timestamp(), 'mm.yyyy'), 'mm.yyyy')
GROUP	BY  Jahr
,	Monat	;

ALTER VIEW statistik_verarbeitung OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW statistik_are_old (are, anz_i, anz_x, anz_t) AS SELECT	are
,	SUM(Anzahl_I)	Anz_I
,	SUM(Anzahl_X)	Anz_X
,	SUM(Anzahl_T)	Anz_T
FROM (
SELECT	are
,	CASE WHEN usertype='Intern' THEN  anzahl  ELSE 0 END 	Anzahl_I
,	CASE WHEN usertype='Extern' THEN  anzahl  ELSE 0 END 	Anzahl_X
,	CASE WHEN usertype='Team' THEN    anzahl  ELSE 0 END 	Anzahl_T
FROM (
SELECT	are,		usertype
,	SUM(Eintraege)	Anzahl
FROM	scdauswertung_mit_are
WHERE	"recordTypeV3" <>	'S'
AND ("status" = 'A' OR coalesce("status"::text, '') = '')
GROUP	BY  are, usertype
) alias6	) alias7
GROUP	BY  are		;

ALTER VIEW statistik_are_old OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW statistik_verarbeitung_tag (jahr, monat, tag, geliefertedatenprostunde, eingetragenedatenprostunde, mw_datenpruefung_sec, max_datenpruefung_sec, min_datenpruefung_sec, mw_durchsatz_mak_sec, max_durchsatz_mak_sec, min_durchsatz_mak_sec) AS SELECT	Jahr,	Monat,	Tag
,	SUM(geliefert)		gelieferteDatenProStunde
,	SUM(eingetragen)	eingetrageneDatenProStunde
--
,	ROUND(AVG(prf_sec))	MW_Datenpruefung_sec
,	ROUND(MAX(prf_sec))	Max_Datenpruefung_sec
,	ROUND(MIN(prf_sec))	Min_Datenpruefung_sec
--
,	ROUND(AVG(Mak_sec))	MW_Durchsatz_Mak_sec
,	ROUND(MAX(Mak_sec))	Max_Durchsatz_Mak_sec
,	ROUND(MIN(Mak_sec))	Min_Durchsatz_Mak_sec
--
FROM	V_PROT
WHERE	to_date(jahr || monat || tag, 'yyyymmdd')
  <	to_date(TO_CHAR(statement_timestamp(), 'dd.mm.yyyy'), 'dd.mm.yyyy')
GROUP	BY  Jahr
,	Monat
,	Tag	;

ALTER VIEW statistik_verarbeitung_tag OWNER TO scd_testuser;

*/


/*
CREATE OR REPLACE VIEW delivery_statistics (liefntnr, name, lieferdatum, geliefertedaten, datenok, qualitaet, lieferset, senderid, clientid) AS select li.liefntnr, nick||CASE WHEN coalesce(c.CLIENTID::text, '') = '' THEN '*'  ELSE c.multiple END  as name, lieferdatum, geliefertedaten,
datenok, qualitaet, li.lieferset, coalesce(senderid,STELLVID) senderid,c.CLIENTID
FROM geliefertedaten gd, LIEFNT li,(select l.LIEFNTNR,l.CLIENTID, CASE WHEN a.anz=1 THEN null  ELSE '*' END  multiple
from sds.LIEFNT_CLIENTID l LEFT OUTER JOIN(select LIEFNTNR, count(*) anz
from sds.LIEFNT_CLIENTID group by LIEFNTNR) a
   ON l.LIEFNTNR = a.LIEFNTNR) c
where gd.liefntnr=li.liefntnr
and gd.liefntnr=c.liefntnr
and lieferdatum>statement_timestamp() - interval '365 days';

ALTER VIEW delivery_statistics OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW v_feldinhalte (c, o, ou, clientid, mailadressen, scdid, telefon, telefon2, telefax, handy, zertifikate, pgp, x509, rs, pki1, pki2, anzahleintraege, anzahlhaupteintraege, anzahlzusatzeintraege) AS SELECT	C, O, OU, CLIENTID
,	SUM(MailAdressen)	MailAdressen
,	SUM(scdIds)		SCDID
,	SUM(Telefon)		Telefon
,	SUM(Telefon2)		Telefon2
,	SUM(Telefax)		Telefax
,	SUM(Handy)		Handy
--
,	SUM(Zertifikate)	Zertifikate
,	SUM(PGP)		PGP
,	SUM(X509)		X509
,	SUM(RS)			RS
,	SUM(pki1)		pki1
,	SUM(pki2)		pki2
--
,	SUM(Eintraege)		AnzahlEintraege
,	SUM(CASE WHEN 	recordTypeV3='S' THEN  0  ELSE Eintraege END 	)		AnzahlHaupteintraege
,	SUM(CASE WHEN 	recordTypeV3='S' THEN  Eintraege  ELSE 0 END 	)		AnzahlZusatzeintraege
FROM	v_scdauswertung
GROUP	BY  c, o, ou, clientid	;

ALTER VIEW v_feldinhalte OWNER TO scd_testuser;

*/


/* VRT VIEW Creation - Section 2.7.2 */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = vrt,oracle,public;


SET check_function_bodies = false;

CREATE OR REPLACE VIEW ws_record_count (jahr, monat, userid, vertragsnummer, scd_comment, record_count, allowed_results_per_month, blocksonviolation) AS (select substr(a.YEAR_MONTH,0,4) jahr,
substr(a.YEAR_MONTH,6) monat,
a.USERID,v.VERTRAGSNUMMER,
u.SCD_COMMENT,
a.RECORD_COUNT,
u.ALLOWED_RESULTS_PER_MONTH,
u.blocksonviolation
FROM WS_CUMULATED_AUDIT a,WS_USER_SETTINGS u,VERTRAEGE v
where a.USERID=u.USERID and u.USERID=v.BENUTZERNAME
and u.USERID not in (select admin.USERID from WS_ADMIN_USERS admin));

ALTER VIEW ws_record_count OWNER TO scd_testuser;
CREATE OR REPLACE VIEW zddb_downloadgids (vertragsnummer, download_gids) AS SELECT vertragsnummer, string_agg(download_for, ' | ' ORDER BY vertragsnummer) AS download_gids
FROM (SELECT
D.delivery_id
,D.name
,D.contract_id AS vertragsnummer
,D.enabled
,S.scheduler_id
,E.exporter_id
,S.enabled AS scheduler_enabled
,E.enabled AS exp_enabled
,E.openft_Addr
,V.SERVER AS zddb_server
,E.OPENFT_TRANSFER_ADM
,V.ZUGANGSBERECHTIGUNG AS ZDDB_Zugangsberechtigung
,E.DOWNLOAD_FOR
,V.EMFPAENGERMAIL AS "ZDDB-Empfängermail"
FROM ap_delivery D
LEFT JOIN ap_scheduler S
ON D.delivery_id=S.delivery_id
LEFT JOIN ap_exporter E
ON E.scheduler_id = S.scheduler_id
LEFT JOIN vertraege V
ON V.vertragsnummer = D.contract_id
WHERE D.enabled=1 AND coalesce(D.to_remove_ts::text, '') = '' AND S.enabled=1 AND E.enabled=1) alias2
GROUP BY vertragsnummer;

ALTER VIEW zddb_downloadgids OWNER TO scd_testuser;


CREATE OR REPLACE VIEW fits_export (gid, givenname, sn, nickname, department, l, o, "c", salid, building, roomnumber, usertype, recordtypev3, contractstatus, sponsor, gidman1, costlocationunit, costlocation, ou, unit, mail, telephonenumber, mobile, status, leavedate, validdate, orgid, gpcompany, personalidnumber, ofk, lifecycleevent, lifecycledate, privatemail, privatemobile, pkiversion, certindicator, companycode, firmstat) AS (
select gid, givenName, sn, nickname, department
,l, o, "c", salid, building, roomnumber, usertype, recordtypev3
,contractstatus, sponsor, gidman1, costlocationunit, costlocation
,ou, unit, mail, telephonenumber, mobile, status, leavedate, validdate
,orgid, gpcompany, personalidnumber
,ofk , lifecycleevent, lifecycledate
,privatemail, privatemobile, pkiversion, certindicator, companycode, firmstat
FROM SDS.V_FITS_MASTAT
where  ((("usertype"='I' or coalesce("usertype"::text, '') = '')
  and ("contractstatus"<>'F' or coalesce("contractstatus"::text, '') = '')) or ("usertype" in ('X','T')))
  and (mastat<>'3' or coalesce(mastat::text, '') = '')

union

select gid, "givenname", "sn", "nickname", "department"
,l, o, "c", "salid", "building", "roomnumber", "usertype", "recordtypev3"
,"contractstatus", "sponsor", "gidman1", "costlocationunit", "costlocation"
,OU, "unit", "mail", "telephonenumber", "mobile", "status", azubiend, "validdate"
,"orgid", "gpcompany", "personalidnumber"
,'2' , "lifecycleevent", "lifecycledate"
,"privatemail", "privatemobile", "pkiversion", "certindicator", "companycode", "firmstat"
from SDS.V_FITS_MASTAT
where  ((("usertype"='I' or coalesce("usertype"::text, '') = '') 
  and ("contractstatus"<>'F' or coalesce("contractstatus"::text, '') = '')) or ("usertype" in ('X','T')))
  and mastat='3'

union

select gid, "givenname", "sn", "nickname", "department"
,l, o, "c", "salid", "building", "roomnumber", "usertype", "recordtypev3"
,"contractstatus", "sponsor", "gidman1", "costlocationunit", "costlocation"
,ou, "unit", "mail", "telephonenumber", "mobile", "status", "leavedate", "validdate"
,"orgid", CASE WHEN mastat='4' THEN 'Diplomand' WHEN mastat='5' THEN 'Doktorand'  ELSE 'Extern' END , "personalidnumber"
,'0', "lifecycleevent", "lifecycledate"
,"privatemail", "privatemobile", "pkiversion", "certindicator", "companycode", "firmstat"
from SDS.V_FITS_MASTAT
where "usertype"='I' and  "contractstatus"='F');

ALTER VIEW fits_export OWNER TO scd_testuser;


/*
CREATE OR REPLACE VIEW check_approval_gov (vertragsnummer, grant_gov, neu_grant_gov, grant_gov_durch, neu_grant_gov_gid, grant_gov_name, neu_grant_gov_name, grant_gov_vorname, neu_grant_gov_vorname, grant_gov_am, grant_gov_date) AS SELECT V.vertragsnummer,
V.grant_gov,
A.grant_gov AS neu_grant_gov,
V.grant_gov_durch,
C.gid AS neu_grant_gov_gid,
V.grant_gov_name,
C.name AS neu_grant_gov_name,
V.grant_gov_vorname,
C.givenname AS neu_grant_gov_vorname,
V.grant_gov_am,
A.grant_gov_date
FROM vertraege V
LEFT JOIN cdb_approval A
ON V.vertragsnummer=A.contract_id
LEFT JOIN cdb_contact C
ON A.grant_gov_approver=C.id
WHERE
coalesce(V.grant_gov,0) <> 0 
AND (
    coalesce(V.grant_gov_am,to_date('01.01.2001','DD.mm.YYYY')) <> coalesce(A.grant_gov_date,to_date('01.01.2001','DD.mm.YYYY'))
	OR V.grant_gov_durch <> C.gid 
	OR V.grant_gov_name<>C.name
	OR V.grant_gov_vorname<>C.givenname
) 

ORDER BY V.vertragsnummer;

ALTER VIEW check_approval_gov OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW mgv_all_tables (project_id, project_name, connection_id, host, port, username, dburl, catalog_id, catalog_name, schema_id, schema_name, table_id, table_name) AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_connections.dburl dburl ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_tables.id table_id ,
    md_tables.TABLE_NAME TABLE_NAME
  FROM md_connections,
    md_catalogs ,
    md_schemas ,
    md_tables ,
    md_projects
  WHERE md_tables.schema_id_fk     = md_schemas.id
  AND md_schemas.catalog_id_fk     = md_catalogs.id
  AND md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk = md_projects.id;

ALTER VIEW mgv_all_tables OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mgv_all_index_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_INDEXES' objtype,i.index_name objname, i.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME,t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid, proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||i.index_name  QualifiedName
FROM MD_INDEXES i, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn,MD_PROJECTS proj
WHERE i.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_index_details OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mgv_all_catalog_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_CATALOGS' objtype, cat.catalog_name objname, cat.id objid,  'MD_CATALOGS' MainObjType,cat.catalog_name MAINOBJNAME, cat.id MAINOBJID,null SchemaName,null schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name ELSE NULL END QualifiedName
FROM  MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE  cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_catalog_details OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW check_mon_exp_log (startexec, "job-name", dauer, cpu, status, errors, output, info) AS SELECT
	TO_CHAR(actual_start_date, 'YYYY-MM-DD HH24:MI:SS') AS startexec ,
    job_name "JOB-NAME" ,
    SUBSTR(TO_CHAR(run_duration),9) AS dauer ,
    SUBSTR(TO_CHAR(cpu_used),9) cpu ,
    status, 
	errors, 
    binary_output   output,
    additional_info INFO
    --
  FROM USER_SCHEDULER_JOB_RUN_DETAILS
  WHERE job_name LIKE 'CHECK_MON_EXP%_J'
  ORDER BY actual_start_date DESC;

ALTER VIEW check_mon_exp_log OWNER TO scd_testuser;
*/


/*
CREATE OR REPLACE VIEW mgv_all_columndt_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname, datatype, isidentity) AS SELECT 'MD_COLUMNS' objtype, c.COLUMN_NAME objname, c.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname ,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||t.table_name ||'.'||c.COLUMN_NAME QualifiedName,
c.column_type datatype,
CASE WHEN p.PROP_KEY='SEEDVALUE' THEN 'Y' ELSE 'N' END IsIdentity
FROM MD_COLUMNS c LEFT OUTER JOIN MD_ADDITIONAL_PROPERTIES p ON c.id =p.ref_id_fk
, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn,MD_PROJECTS proj
WHERE c.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_columndt_details OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW mgv_all_partitions_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_PARTITIONS' objtype, 'PARTTITION_EXP' objname, t.id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN   md_meta.quote(cat.catalog_name,s.name,t.table_name,conn.id)
                            ELSE   s.name || '.' || t.table_name END QualifiedName
FROM MD_PARTITIONS p, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE p.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_partitions_details OWNER TO scd_testuser;
*/
/*
CREATE OR REPLACE VIEW check_contractor_commercial (vertragsnummer, asp_mail_l_kaufm, email, asp_gid_l_kaufm, gid, asp_name_l_kaufm, name, asp_vorname_l_kaufm, givenname, asp_tel_l_kaufm, telefon, asp_abt_l_kaufm, department, asp_l_l_kaufm, location) AS SELECT vertragsnummer,
asp_mail_L_kaufm,
X.email,
asp_gid_L_kaufm,
X.gid,
asp_name_L_kaufm,
X.name,
asp_vorname_L_kaufm,
X.givenname,
asp_tel_L_kaufm,
X.telefon,
asp_abt_L_kaufm,
X.department,
asp_l_L_kaufm,
X.location
FROM vertraege V
LEFT JOIN cdb_contract C
ON V.vertragsnummer=C.contract_number
LEFT JOIN cdb_contact X
ON C.contact_contractor_commercial=X.id
WHERE coalesce(lower(asp_mail_L_kaufm),0)<> coalesce(lower(X.email),0) OR
coalesce(asp_gid_L_kaufm,0)<> coalesce(X.gid,0) OR
coalesce(initcap(asp_name_L_kaufm),0)<> coalesce(initcap(X.name),0) OR
coalesce(initcap(asp_vorname_L_kaufm),0)<> coalesce(initcap(X.givenname),0) OR
coalesce(asp_tel_L_kaufm,0) <> coalesce(X.telefon,0) OR
coalesce(asp_abt_L_kaufm,0) <> coalesce(X.department,0) OR
coalesce(asp_l_L_kaufm,0) <> coalesce(X.location,0)
ORDER BY vertragsnummer;

ALTER VIEW check_contractor_commercial OWNER TO scd_testuser;

*/

/*
CREATE OR REPLACE VIEW check_approval (vertragsnummer, grant_gov, alt_grant_gov, grant_gov_date, grant_gov_am, grant_gov_approver, grant_gov_durch, alt_grant_ds, grant_ds, grant_ds_date, grant_ds_am, grant_ds_approver, grant_ds_durch, alt_grant_scd, grant_scd, grant_scd_date, grant_scd_am, grant_scd_approver, grant_scd_durch) AS SELECT V.vertragsnummer,
A.grant_gov,
V.grant_gov AS alt_grant_gov,
A.grant_gov_date,
V.grant_gov_am,
A.grant_gov_approver,
V.grant_gov_durch,
A.grant_ds AS alt_grant_ds,
V.grant_ds,
A.grant_ds_date,
V.grant_ds_am,
A.grant_ds_approver,
V.grant_ds_durch,
A.grant_scd AS alt_grant_scd,
V.grant_scd,
A.grant_scd_date,
V.grant_scd_am,
A.grant_scd_approver,
V.grant_scd_durch
FROM vertraege V
LEFT JOIN cdb_approval A
ON V.vertragsnummer=A.contract_id
WHERE
coalesce(A.grant_gov,0) <> coalesce(V.grant_gov,0) OR
coalesce(A.grant_gov_approver,0) <> coalesce(V.grant_gov_durch,0) OR
coalesce(A.grant_ds,0) <> coalesce(V.grant_ds,0) OR
coalesce(A.grant_ds_approver,0) <> coalesce(V.grant_ds_durch,0) OR
coalesce(A.grant_scd,0) <> coalesce(V.grant_scd,0) OR
coalesce(A.grant_scd_approver,0) <> coalesce(V.grant_scd_durch,0)
OR coalesce(A.grant_gov_date,to_date('01.01.2001','DD.mm.YYYY'))<> coalesce(V.grant_gov_am,to_date('01.01.2001','DD.mm.YYYY'))
OR coalesce(A.grant_ds_date,to_date('01.01.2001','DD.mm.YYYY'))<> coalesce(V.grant_ds_am,to_date('01.01.2001','DD.mm.YYYY'))
OR coalesce(A.grant_scd_date,to_date('01.01.2001','DD.mm.YYYY'))<> coalesce(V.grant_scd_am,to_date('01.01.2001','DD.mm.YYYY'))
ORDER BY vertragsnummer;

ALTER VIEW check_approval OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW test_dbms_output_lo (startexec, "job-name", dauer, cpu, status, errors, output, text, info) AS SELECT TO_CHAR(actual_start_date, 'YYYY-MM-DD HH24:MI:SS') AS startexec ,
    job_name "JOB-NAME" ,
    SUBSTR(TO_CHAR(run_duration),9) AS dauer ,
    SUBSTR(TO_CHAR(cpu_used),9) cpu ,
    status, errors, output,
    binary_output   TEXT,
    additional_info INFO
    --
  FROM USER_SCHEDULER_JOB_RUN_DETAILS
  WHERE job_name LIKE 'TEST_DBMS%_J'
  ORDER BY actual_start_date DESC;

ALTER VIEW test_dbms_output_lo OWNER TO scd_testuser;

*/
/*
CREATE OR REPLACE VIEW v_scdx (c, o, ou, l, cn, sn, givenname, commonnamenational, initials, gender, personaltitle, graduatetitle, mainfunction, department, building, roomnumber, x400address, mail, telephonenumber, faxnumber, secretary, gidsec, gidsecflag, representation, gidrep, gidrepflag, mobile, videoconferencenumber1, videoconferencenumber2, publickey, pager, costlocation, personalidnumber, securephone, alternatephone, personalfax, faxnumbersec, netmeeting, scdid, maident, gid, postofficebox, costlocationunit, surnamenational, givennamenational, departmenttext, releaseextern, personalremark, labeleduri, expiredate, validdate, leavedate, joindate, modifytimestamp, salid, recordtype, recordtypev3, konzbet, utc, firmstat, usertype, contractstatus, status, sponsor, sponsorflag, snampre, snamadd, lastname, appkey, scdversion, pkiversion, robinson, createtimestamp, ende, localityinternational, localitynational, deliveryid, tcgid, certindicator, x509, pgp, kaw, kraw, kueraw, kvs, krvs, kruevs, kpost, orgid, orgidflag, nickname, displayname, departmentnumber, unitid, unit, gidman1, gidman1flag, gidman2, gidman2flag, gidmanf1, gidmanf2, gidmanf3, departmenttextnational, delegation, itacc, reqacc, reqmail, reqmbox, reststart, restend, vip, companycode, mgmtresp, notwebvisible, gpcompany, mgmtlevel, lifecycleevent, lifecycledate, mailpriv, mobilepriv, wcunit, actiontype, actionreason, actionstartdate, preferredsn, orglevela, orglevelb, orglevelc, orgleveld, orglevelx, altou, clientid, clientname, fksource, prefpronoun, countryofresidence, validationerror) AS SELECT	C,O,OU,L,CN,sn,GivenName,commonNameNational,Initials,gender,personalTitle,graduateTitle,mainFunction,Department,building,roomNumber,X400-Address,mail,telephoneNumber,faxNumber,Secretary,gidSec,gidSecFlag,Representation,gidRep,gidRepFlag,mobile,videoConferenceNumber1,videoConferenceNumber2,publicKey,Pager,costLocation,personalIdnumber,securePhone,alternatePhone,personalFax,faxNumberSec,Netmeeting,scdId,maIdent,GID,postOfficeBox,costLocationUnit,surnameNational,givenNameNational,departmentText,releaseExtern,personalRemark,labeledURI,expireDate,validDate,leaveDate,joinDate,modifyTimeStamp,salid,recordType,recordTypeV3,konzBet,utc,firmstat,usertype,contractstatus,status,sponsor,sponsorFlag,snampre,snamadd,lastName,appkey,scdVersion,pkiversion,robinson,createTimeStamp,ENDE,localityInternational,localityNational,deliveryId,tcgid,certIndicator,X509,PGP,kAW,krAW,kuerAW,kVS,krVS,krueVS,kPost,orgid,orgidFlag,nickName,displayName,departmentNumber,unitId,unit,gidMan1,gidMan1Flag,gidMan2,gidMan2Flag,gidManF1,gidManF2,gidManF3,departmentTextNational,delegation,itAcc,reqAcc,reqMail,reqMBox,restStart,restEnd,vip,companyCode,mgmtResp,notWebVisible,gpCompany,mgmtLevel,lifeCycleEvent,lifeCycleDate,mailPriv,mobilePriv,wcUnit,actionType,actionReason,actionStartDate,preferredSN,orgLevelA,orgLevelB,orgLevelC,orgLevelD,orgLevelX,altOU,clientID,clientName,fkSource,prefPronoun,countryOfResidence,validationError
FROM	scdx_1	;

ALTER VIEW v_scdx OWNER TO scd_testuser;
*/
/*
CREATE OR REPLACE VIEW check_vertraege_log ("job-name", start, dauer, cpu, status, errors, output, info) AS SELECT	
	to_char(actual_start_date, 'YYYY-MM-DD HH24:MI:SS')	Start
,   job_name	"Job-Name"
,	substr(to_char(run_duration),9)	Dauer
,	substr(to_char(cpu_used),9)	CPU
,	status,  errors
,	binary_output			Output
,	additional_info			Info
--
FROM	USER_SCHEDULER_JOB_RUN_DETAILS
WHERE	job_name like	'CHECK_VERTRAEGE%_J'
ORDER	BY	actual_start_date DESC;

ALTER VIEW check_vertraege_log OWNER TO scd_testuser;
*/


CREATE OR REPLACE VIEW fits_exportx_old (gid, givenname, sn, nickname, department, l, o, c, salid, building, roomnumber, usertype, recordtypev3, contractstatus, sponsor, gidman1, costlocationunit, costlocation, ou, unit, mail, telephonenumber, mobile, status, leavedate, validdate, orgid, gpcompany, personalidnumber, ofk, lifecycleevent, lifecycledate, privatemail, privatemobile, pkiversion, certindicator, companycode, firmstat) AS (
select gid, givenname, sn, nickname, department
,l, o, c, salid, building, roomnumber, usertype, recordtypev3
,contractstatus, sponsor, gidman1, costlocationunit, costlocation
,ou, unit, mail, telephonenumber, mobile, status, leavedate, validdate
,orgid, gpcompany, personalidnumber
,ofk , lifecycleevent, lifecycledate
,privatemail, privatemobile, pkiversion, certindicator, companycode, firmstat
FROM SDS.V_FITS_MASTATX
where  ((("usertype"='I' or coalesce("usertype"::text, '') = '')
  and ("contractstatus"<>'F' or coalesce("contractstatus"::text, '') = '')) or ("usertype" in ('X','T')))
  and (mastat<>'3' or coalesce(mastat::text, '') = '')

union

select gid, "givenname", "sn", "nickname", "department"
,l, o, c, "salid", "building", "roomnumber", "usertype", "recordtypev3"
,"contractstatus", "sponsor", "gidman1", "costlocationunit", "costlocation"
,ou, "unit", "mail", "telephonenumber", "mobile", "status", azubiend, "validdate"
,"orgid", "gpcompany", "personalidnumber"
,'2' , "lifecycleevent", "lifecycledate"
,"privatemail", "privatemobile", "pkiversion", "certindicator", "companycode", "firmstat"
from SDS.V_FITS_MASTATX
where  ((("usertype"='I' or coalesce("usertype"::text, '') = '') 
  and ("contractstatus"<>'F' or coalesce("contractstatus"::text, '') = '')) or ("usertype" in ('X','T')))
  and mastat='3'

union

select gid, "givenname", "sn", "nickname", "department"
,l, o, c, "salid", "building", "roomnumber", "usertype", "recordtypev3"
,"contractstatus", "sponsor", "gidman1", "costlocationunit", "costlocation"
,ou, "unit", "mail", "telephonenumber", "mobile", "status", "leavedate", "validdate"
,"orgid", CASE WHEN mastat='4' THEN 'Diplomand' WHEN mastat='5' THEN 'Doktorand'  ELSE 'Extern' END , "personalidnumber"
,'0', "lifecycleevent", "lifecycledate"
,"privatemail", "privatemobile", "pkiversion", "certindicator", "companycode", "firmstat"
from SDS.V_FITS_MASTATX
where "usertype"='I' and  "contractstatus"='F');

ALTER VIEW fits_exportx_old OWNER TO scd_testuser;


/*
CREATE OR REPLACE VIEW mgv_all_tables_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_TABLES' objtype, t.table_name objname, t.id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN   md_meta.quote(cat.catalog_name,s.name,t.table_name,conn.id)
                            ELSE   s.name || '.' || t.table_name END QualifiedName
FROM MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_tables_details OWNER TO scd_testuser;
*/
/*
CREATE OR REPLACE VIEW check_ap9965_log (start, dauer, cpu, status, errors, output, info) AS SELECT	
    to_char(actual_start_date, 'YYYY-MM-DD HH24:MI:SS')	START
,	substr(to_char(run_duration),9)	DAUER
,	substr(to_char(cpu_used),9)	CPU
,	status
,   errors 
, 	binary_output
,	additional_info	INFO
--
FROM	USER_SCHEDULER_JOB_RUN_DETAILS
WHERE	job_name =	'AP9965_J'
ORDER	BY	1 DESC;

ALTER VIEW check_ap9965_log OWNER TO scd_testuser;
*/
/*
CREATE OR REPLACE VIEW check_customer_technical (vertragsnummer, asp_mail_k, email, asp_gid_k, gid, asp_name_k, name, asp_vorname_k, givenname, asp_tel_k, telefon, asp_abt_k, department, asp_l_k, location) AS SELECT vertragsnummer,
asp_mail_k,
X.email,
asp_gid_k,
X.gid,
asp_name_K,
X.name,
asp_vorname_k,
X.givenname,
asp_tel_k,
X.telefon,
asp_abt_k,
X.department,
asp_l_k,
X.location
FROM vertraege V
LEFT JOIN cdb_contract C
ON V.vertragsnummer=C.contract_number
LEFT JOIN cdb_contact X
ON C.contact_customer_technical=X.id
WHERE coalesce(lower(asp_mail_k),0)<>coalesce(lower(X.email),0) OR
coalesce(asp_gid_k,0)<>coalesce(X.gid,0) OR
coalesce(initcap(asp_name_K),0)<>coalesce(initcap(X.name),0)  OR
coalesce(initcap(asp_vorname_k),0)<>coalesce(initcap(X.givenname),0) OR
coalesce(asp_tel_k,0)<>coalesce(X.telefon,0) OR
coalesce(asp_abt_k,0)<>coalesce(X.department,0) OR
coalesce(asp_l_k,0)<>coalesce(X.location,0)
ORDER BY vertragsnummer;

ALTER VIEW check_customer_technical OWNER TO scd_testuser;

ALTER VIEW check_approval_scd OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mgv_all_schema_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_SCHEMAS' objtype, s.name objname, s.id objid,  'MD_SCHEMAS' MainObjType,s.name MAINOBJNAME, s.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name QualifiedName
FROM MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_schema_details OWNER TO scd_testuser;


CREATE OR REPLACE VIEW fits_exportx (gid, givenname, sn, nickname, department, l, o, c, salid, building, roomnumber, usertype, recordtypev3, contractstatus, sponsor, gidman1, costlocationunit, costlocation, ou, unit, mail, telephonenumber, mobile, status, leavedate, validdate, orgid, gpcompany, personalidnumber, ofk, lifecycleevent, lifecycledate, privatemail, privatemobile, pkiversion, certindicator, companycode, firmstat, deliveryid, clientid, preferredsn, altou, clientname, countryofresidence, gidman2) AS (
select GID, GivenName, sn, nickname, department
,l, o, c, salid, building, roomnumber, usertype, recordtypev3
,coalesce(contractstatus,'A'), sponsor, gidman1, costlocationunit, costlocation
,ou, unit, mail, telephonenumber, mobile, status, leavedate, validdate
,orgid, gpcompany, personalidnumber
,ofk , lifecycleevent, lifecycledate
,privatemail, privatemobile, pkiversion, certindicator, companycode, firmstat, deliveryid, clientid, preferredsn
,altou,clientname, countryofresidence, gidman2
FROM SDS.V_FITS_MASTATX
where  ((("usertype"='I' or coalesce("usertype"::text, '') = '')
  and ("contractstatus"<>'F' or coalesce("contractstatus"::text, '') = '')) or ("usertype" in ('X','T')))
  and (mastat<>'3' or coalesce(mastat::text, '') = '')

union

select GID, "givenname", "sn", "nickname", "department"
,l, o, c, "salid", "building", "roomnumber", "usertype", "recordtypev3"
,coalesce("contractstatus",'A'), "sponsor", "gidman1", "costlocationunit", "costlocation"
,ou, "unit", "mail", "telephonenumber", "mobile", "status", azubiend, "validdate"
,"orgid", "gpcompany", "personalidnumber"
,'2' , "lifecycleevent", "lifecycledate"
,"privatemail", "privatemobile", "pkiversion", "certindicator", "companycode", "firmstat", "deliveryid", "clientid", "preferredsn"
,"altou","clientname", "countryofresidence", "gidman2"
from SDS.V_FITS_MASTATX
where  ((("usertype"='I' or coalesce("usertype"::text, '') = '') 
  and ("contractstatus"<>'F' or coalesce("contractstatus"::text, '') = '')) or ("usertype" in ('X','T')))
  and mastat='3'

union

select GID, "givenname", "sn", "nickname", "department"
,l, o, c, "salid", "building", "roomnumber", "usertype", "recordtypev3"
,coalesce("contractstatus",'A'), "sponsor", "gidman1", "costlocationunit", "costlocation"
,ou, "unit", "mail", "telephonenumber", "mobile", "status", "leavedate", "validdate"
,"orgid", CASE WHEN mastat='4' THEN 'Diplomand' WHEN mastat='5' THEN 'Doktorand'  ELSE 'Extern' END , "personalidnumber"
,'0', "lifecycleevent", "lifecycledate"
,"privatemail", "privatemobile", "pkiversion", "certindicator", "companycode", "firmstat", "deliveryid", "clientid", "preferredsn"
,"altou","clientname", "countryofresidence", "gidman2"
from SDS.V_FITS_MASTATX
where "usertype"='I' and  "contractstatus"='F'
);

ALTER VIEW fits_exportx OWNER TO scd_testuser;


/*
CREATE OR REPLACE VIEW check_contract_hotline (vertragsnummer, hotline_mail, email, hotline_gid, gid, hotline_name, name, hotline_vorname, givenname, hotline_tel, telefon, hotline_abt, department, hotline_l, location) AS SELECT vertragsnummer,
hotline_mail,
X.email,
hotline_gid,
X.gid,
hotline_name,
X.name,
hotline_vorname,
X.givenname,
hotline_tel,
X.telefon,
hotline_abt,
X.department,
hotline_l,
X.location
FROM vertraege V
LEFT JOIN cdb_contract_hotline C
ON V.vertragsnummer=C.contract_id
LEFT JOIN cdb_contact X
ON C.contact_id=X.id
WHERE coalesce(hotline_mail,0)<> coalesce(X.email,0) OR
coalesce(hotline_gid,0)<> coalesce(X.gid,0) OR
coalesce(hotline_name,0)<> coalesce(X.name,0) OR
coalesce(hotline_vorname,0)<> coalesce(X.givenname,0) OR
coalesce(hotline_tel,0) <> coalesce(X.telefon,0) OR
coalesce(hotline_abt,0) <> coalesce(X.department,0) OR
coalesce(hotline_l,0) <> coalesce(X.location,0);

ALTER VIEW check_contract_hotline OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW mgv_all_view_triggers (project_id, project_name, connection_id, host, port, username, catalog_id, catalog_name, dummy_flag, schema_id, schema_name, view_id, view_name, trigger_id, trigger_name) AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_catalogs.dummy_flag dummy_flag ,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_views.id view_id ,
    md_views.view_name view_name ,
    md_triggers.id trigger_id ,
    md_triggers.trigger_name trigger_name
  FROM md_projects ,
    md_connections,
    md_catalogs ,
    md_schemas ,
    md_views ,
    md_triggers
  WHERE md_triggers.table_or_view_id_fk = md_views.id
  AND md_views.schema_id_fk             = md_schemas.id
  AND md_schemas.catalog_id_fk          = md_catalogs.id
  AND md_catalogs.connection_id_fk      = md_connections.id
  AND md_connections.project_id_fk      = md_projects.id;

ALTER VIEW mgv_all_view_triggers OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mgv_all_view_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_VIEWS' objtype, v.view_name objname, v.Id objid,  'MD_VIEWS' MainObjType,v.view_name MAINOBJNAME,v.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||v.view_name  QualifiedName
FROM MD_VIEWS v,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE v.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_view_details OWNER TO scd_testuser;
/*
CREATE OR REPLACE VIEW pics1 (image_id, file_name, image_data, valid) AS select GID IMAGE_ID, GID||valid||'.jpg' FILE_NAME, FULL IMAGE_DATA, valid FROM  SDS.ADRPIC
where  VALID > trunc(statement_timestamp()) - '3 days'::interval and (FULL AND FULL::text <> '') and substr(GID,1,5) in (select substr(GID,1,5) from SDS.ADRPIC group by substr(GID,1,5) having count(*) > 450);

ALTER VIEW pics1 OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW mgv_all_table_triggers (project_id, project_name, connection_id, host, port, username, catalog_id, catalog_name, dummy_flag, schema_id, schema_name, table_id, table_name, trigger_id, trigger_name) AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_catalogs.dummy_flag dummy_flag ,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_tables.id table_id ,
    md_tables.TABLE_NAME TABLE_NAME ,
    md_triggers.id trigger_id ,
    md_triggers.trigger_name trigger_name
  FROM md_projects ,
    md_connections,
    md_catalogs ,
    md_schemas ,
    md_tables ,
    md_triggers
  WHERE md_triggers.table_or_view_id_fk = md_tables.id
  AND md_tables.schema_id_fk            = md_schemas.id
  AND md_schemas.catalog_id_fk          = md_catalogs.id
  AND md_catalogs.connection_id_fk      = md_connections.id
  AND md_connections.project_id_fk      = md_projects.id;

ALTER VIEW mgv_all_table_triggers OWNER TO scd_testuser;
CREATE OR REPLACE VIEW zddb_filenames (vertragsnummer, file_names) AS SELECT vertragsnummer, string_agg(file_name || '.' || lower(file_format), ' | ' ORDER BY vertragsnummer) AS file_names
FROM (SELECT
D.delivery_id
,D.name
,D.contract_id AS vertragsnummer
,D.enabled
,S.scheduler_id
,E.exporter_id
,S.enabled AS scheduler_enabled
,E.enabled AS exp_enabled
,E.file_name
,E.file_format
,V.SERVER AS zddb_server
,E.OPENFT_TRANSFER_ADM
,V.ZUGANGSBERECHTIGUNG AS ZDDB_Zugangsberechtigung
,E.DOWNLOAD_FOR
,V.EMFPAENGERMAIL AS "ZDDB-Empfängermail"
FROM ap_delivery D
LEFT JOIN ap_scheduler S
ON D.delivery_id=S.delivery_id
LEFT JOIN ap_exporter E
ON E.scheduler_id = S.scheduler_id
LEFT JOIN vertraege V
ON V.vertragsnummer = D.contract_id
WHERE D.enabled=1 AND coalesce(D.to_remove_ts::text, '') = '' AND S.enabled=1 AND E.enabled=1) alias3
GROUP BY vertragsnummer;

ALTER VIEW zddb_filenames OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mgv_all_catalogs (project_id, project_name, connection_id, host, port, username, dburl, catalog_id, catalog_name) AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_connections.dburl dburl ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name
  FROM md_projects ,
    md_connections,
    md_catalogs
  WHERE md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk   = md_projects.id;

ALTER VIEW mgv_all_catalogs OWNER TO scd_testuser;


CREATE OR REPLACE VIEW ws_user_columns (userid, entity, columnname) AS SELECT
        WS_USER_COLGROUP_IDS.USERID AS USERID,
        WS_COLUMN_GROUPS.ENTITY AS ENTITY,
        WS_COLUMN_NAMES.COLUMNNAME AS COLUMNNAME
    FROM
        vrt.ws_user_colgroup_ids
          JOIN vrt.ws_column_groups ON (vrt.WS_COLUMN_GROUPS.COLGROUPID = vrt.WS_USER_COLGROUP_IDS.COLGROUPID)
          JOIN vrt.ws_colgroup_column_ids ON (vrt.WS_COLGROUP_COLUMN_IDS.COLGROUPID = vrt.WS_USER_COLGROUP_IDS.COLGROUPID)
          JOIN vrt.ws_column_names ON (vrt.WS_COLUMN_NAMES.COLUMNID = vrt.WS_COLGROUP_COLUMN_IDS.COLUMNID);

ALTER VIEW ws_user_columns OWNER TO scd_testuser;



CREATE OR REPLACE VIEW zddb_all_ap_data (delivery_id, contract_id, name, description, enabled, query, user_id, added_ts, latest_run_result, latest_run_ts, to_remove_ts, supp_data_file, supp_data_filetype, supp_data_delimiter, supp_data_file_mod_ts, supp_data_has_header, supp_data_enabled, scheduler_id, cron, scheduler_enabled, scheduler_user_id, scheduler_addedd_ts, exporter_id, file_name, file_format, output_to, delimiter, charset, zip_data, print_header, openft_addr, openft_transfer_adm, exporter_enabled, exporter_user_id, exporter_added_ts, download_for, transfer_files) AS SELECT D.delivery_id
,D.contract_id
,D.name
,D.description
,D.enabled
,D.query
,D.user_id
,D.added_ts
,D.latest_run_result
,D.latest_run_ts
,D.to_remove_ts
,D.supp_data_file
,D.supp_data_filetype
,D.supp_data_delimiter
,D.supp_data_file_mod_ts
,D.supp_data_has_header
,D.supp_data_enabled
,S.scheduler_id
,S.cron
,S.enabled AS scheduler_enabled
,S.user_id AS scheduler_user_id
,S.added_ts AS scheduler_addedd_ts
,E.exporter_id
,E.file_name
,E.file_format
,E.output_to
,E.delimiter
,E.charset
,E.zip_data
,E.print_header
,E.openft_addr
,E.OPENFT_TRANSFER_ADM
,E.enabled AS exporter_enabled
,E.user_id AS exporter_user_id
,E.added_ts AS exporter_added_ts
,E.download_for
,E.transfer_files
FROM ap_delivery D
LEFT JOIN ap_scheduler S
ON D.delivery_id=S.delivery_id
LEFT JOIN ap_exporter  E
ON S.scheduler_id=E.scheduler_id;

ALTER VIEW zddb_all_ap_data OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW check_approval_ds (vertragsnummer, grant_ds, neu_grant_ds, grant_ds_durch, neu_grant_ds_gid, grant_ds_name, neu_grant_ds_name, grant_ds_vorname, neu_grant_ds_vorname, grant_ds_am, grant_ds_date) AS SELECT V.vertragsnummer,
V.grant_ds,
A.grant_ds AS neu_grant_ds,
V.grant_ds_durch,
C.gid AS neu_grant_ds_gid,
V.grant_ds_name,
C.name AS neu_grant_ds_name,
V.grant_ds_vorname,
C.givenname AS neu_grant_ds_vorname,
V.grant_ds_am,
A.grant_ds_date
FROM vertraege V
LEFT JOIN cdb_approval A
ON V.vertragsnummer=A.contract_id
LEFT JOIN cdb_contact C
ON A.grant_ds_approver=C.id
WHERE
coalesce(V.grant_ds,0) <> 0 
AND (
    coalesce(V.grant_ds_am,to_date('01.01.2001','DD.mm.YYYY')) <> coalesce(A.grant_ds_date,to_date('01.01.2001','DD.mm.YYYY'))
	OR V.grant_ds_durch <> C.gid 
	OR V.grant_ds_name<>C.name
	OR V.grant_ds_vorname<>C.givenname
) 

ORDER BY V.vertragsnummer;

ALTER VIEW check_approval_ds OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW v_validorgcodeswildcard (department) AS select replace(voc.department,'*','%') department
    FROM sds.validorgcodes voc
    where
    TO_DATE(enddate,'YYYYmmddHH24MISS"Z"') > statement_timestamp() - interval '14 days'
    AND department like('%*');

ALTER VIEW v_validorgcodeswildcard OWNER TO scd_testuser;

*/

/*
CREATE OR REPLACE VIEW v_scd (c, o, ou, l, cn, sn, givenname, commonnamenational, initials, gender, personaltitle, graduatetitle, mainfunction, department, building, roomnumber, x400address, mail, telephonenumber, faxnumber, secretary, gidsec, gidsecflag, representation, gidrep, gidrepflag, mobile, videoconferencenumber1, videoconferencenumber2, publickey, pager, costlocation, personalidnumber, securephone, alternatephone, personalfax, faxnumbersec, netmeeting, scdid, maident, gid, postofficebox, costlocationunit, surnamenational, givennamenational, departmenttext, releaseextern, personalremark, labeleduri, expiredate, validdate, leavedate, joindate, modifytimestamp, salid, recordtype, recordtypev3, konzbet, utc, firmstat, usertype, contractstatus, status, sponsor, sponsorflag, snampre, snamadd, lastname, appkey, scdversion, pkiversion, robinson, createtimestamp, ende, localityinternational, localitynational, deliveryid, tcgid, certindicator, x509, pgp, kaw, kraw, kueraw, kvs, krvs, kruevs, kpost, orgid, orgidflag, nickname, displayname, departmentnumber, unitid, unit, gidman1, gidman1flag, gidman2, gidman2flag, gidmanf1, gidmanf2, gidmanf3, departmenttextnational, delegation, itacc, reqacc, reqmail, reqmbox, reststart, restend, vip, companycode, mgmtresp, notwebvisible, gpcompany, mgmtlevel, lifecycleevent, lifecycledate, mailpriv, mobilepriv, wcunit, actiontype, actionreason, actionstartdate, preferredsn, orglevela, orglevelb, orglevelc, orgleveld, orglevelx, altou, clientid, clientname, fksource, prefpronoun, countryofresidence, validationerror) AS SELECT	C,O,OU,L,CN,sn,GivenName,commonNameNational,Initials,gender,personalTitle,graduateTitle,mainFunction,Department,building,roomNumber,X400-Address,mail,telephoneNumber,faxNumber,Secretary,gidSec,gidSecFlag,Representation,gidRep,gidRepFlag,mobile,videoConferenceNumber1,videoConferenceNumber2,publicKey,Pager,costLocation,personalIdnumber,securePhone,alternatePhone,personalFax,faxNumberSec,Netmeeting,scdId,maIdent,GID,postOfficeBox,costLocationUnit,surnameNational,givenNameNational,departmentText,releaseExtern,personalRemark,labeledURI,expireDate,validDate,leaveDate,joinDate,modifyTimeStamp,salid,recordType,recordTypeV3,konzBet,utc,firmstat,usertype,contractstatus,status,sponsor,sponsorFlag,snampre,snamadd,lastName,appkey,scdVersion,pkiversion,robinson,createTimeStamp,ENDE,localityInternational,localityNational,deliveryId,tcgid,certIndicator,X509,PGP,kAW,krAW,kuerAW,kVS,krVS,krueVS,kPost,orgid,orgidFlag,nickName,displayName,departmentNumber,unitId,unit,gidMan1,gidMan1Flag,gidMan2,gidMan2Flag,gidManF1,gidManF2,gidManF3,departmentTextNational,delegation,itAcc,reqAcc,reqMail,reqMBox,restStart,restEnd,vip,companyCode,mgmtResp,notWebVisible,gpCompany,mgmtLevel,lifeCycleEvent,lifeCycleDate,mailPriv,mobilePriv,wcUnit,actionType,actionReason,actionStartDate,preferredSN,orgLevelA,orgLevelB,orgLevelC,orgLevelD,orgLevelX,altOU,clientID,clientName,fkSource,prefPronoun,countryOfResidence,validationError
FROM	scd_2	;

ALTER VIEW v_scd OWNER TO scd_testuser;
*/
/*
CREATE OR REPLACE VIEW check_contact_assignment (vertragsnummer, asp_mail_k, email, asp_gid_k, gid, asp_name_k, name, asp_vorname_k, givenname, asp_tel_k, telefon, asp_abt_k, department, asp_l_k, location) AS SELECT vertragsnummer,
asp_mail_k,
X.email,
asp_gid_k,
X.gid,
asp_name_K,
X.name,
asp_vorname_k,
X.givenname,
asp_tel_k,
X.telefon,
asp_abt_k,
X.department,
asp_l_k,
X.location
FROM vertraege V
LEFT JOIN cdb_contract C
ON V.vertragsnummer=C.contract_id
LEFT JOIN cdb_contact X
ON C.contact_customer_technical=X.id;

ALTER VIEW check_contact_assignment OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW mgv_all_schema (project_id, project_name, connection_id, host, port, username, catalog_id, catalog_name, schema_id, schema_name) AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_schemas.id schema_id ,
    md_schemas.name schema_name
  FROM md_connections,
    md_catalogs ,
    md_schemas ,
    md_projects
  WHERE md_schemas.catalog_id_fk   = md_catalogs.id
  AND md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk = md_projects.id;

ALTER VIEW mgv_all_schema OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mgv_all_connections (project_id, project_name, connection_id, connection_name, host, port, username, dburl) AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.ID CONNECTION_ID ,
    md_connections.NAME CONNECTION_NAME,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_connections.dburl dburl
  FROM md_projects,
    md_connections
  WHERE md_connections.PROJECT_ID_FK = md_projects.ID;

ALTER VIEW mgv_all_connections OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW zddb_openftdata (vertragsnummer, openft_data) AS SELECT vertragsnummer, string_agg(openft_Addr, ' | ' ORDER BY vertragsnummer) AS openft_data
FROM (SELECT
D.delivery_id
,D.name
,D.contract_id AS vertragsnummer
,D.enabled
,S.scheduler_id
,E.exporter_id
,S.enabled AS scheduler_enabled
,E.enabled AS exp_enabled
,E.openft_Addr
,V.SERVER AS zddb_server
,E.OPENFT_TRANSFER_ADM
,V.ZUGANGSBERECHTIGUNG AS ZDDB_Zugangsberechtigung
,E.DOWNLOAD_FOR
,V.EMFPAENGERMAIL AS ZDDB_Empfaengermail
FROM ap_delivery D
LEFT JOIN ap_scheduler S
ON D.delivery_id=S.delivery_id
LEFT JOIN ap_exporter E
ON E.scheduler_id = S.scheduler_id
LEFT JOIN vertraege V
ON V.vertragsnummer = D.contract_id
where (openft_addr AND openft_addr::text <> '') or (openft_transfer_adm AND openft_transfer_adm::text <> '')) alias3
GROUP BY vertragsnummer;

ALTER VIEW zddb_openftdata OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW mgv_all_views (project_id, project_name, connection_id, host, port, username, catalog_id, catalog_name, dummy_flag, schema_id, schema_name, view_id, view_name) AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_catalogs.dummy_flag dummy_flag ,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_views.id view_id ,
    md_views.view_name view_name
  FROM md_projects ,
    md_connections,
    md_catalogs ,
    md_schemas ,
    md_views
  WHERE md_views.schema_id_fk      = md_schemas.id
  AND md_schemas.catalog_id_fk     = md_catalogs.id
  AND md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk = md_projects.id;

ALTER VIEW mgv_all_views OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW test_dbms_output_log (startexec, "job-name", dauer, cpu, status, errors, output, text, info) AS SELECT TO_CHAR(actual_start_date, 'YYYY-MM-DD HH24:MI:SS') AS startexec ,
    job_name "JOB-NAME" ,
    SUBSTR(TO_CHAR(run_duration),9) AS dauer ,
    SUBSTR(TO_CHAR(cpu_used),9) cpu ,
    status, errors, output,
    binary_output   TEXT,
    additional_info INFO
    --
  FROM USER_SCHEDULER_JOB_RUN_DETAILS
  WHERE job_name LIKE 'TEST_DBMS%_J'
  ORDER BY actual_start_date DESC;

ALTER VIEW test_dbms_output_log OWNER TO scd_testuser;
*/


CREATE OR REPLACE VIEW mgv_all_trigger_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_TRIGGERS' objtype,trig.trigger_name objname, trig.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME,t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||trig.trigger_name  QualifiedName
FROM MD_TRIGGERS trig, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE trig.table_or_view_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id 

UNION ALL

SELECT 'MD_TRIGGERS' objtype,trig.trigger_name objname, trig.Id objid,  'MD_VIEWS' MainObjType,v.view_name MAINOBJNAME,v.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||trig.trigger_name  QualifiedName
FROM MD_TRIGGERS trig, MD_VIEWS v,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE trig.table_or_view_id_fk = v.id
AND v.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id 
ORDER BY objid;

ALTER VIEW mgv_all_trigger_details OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW check_banner_log (start, dauer, cpu, status, errors, output, info) AS SELECT	to_char(actual_start_date, 'YYYY-MM-DD HH24:MI:SS')
					Start
,	substr(to_char(run_duration),9)	Dauer
,	substr(to_char(cpu_used),9)	CPU
,	status,  errors, output		Output
,	additional_info			Info
--
FROM	USER_SCHEDULER_JOB_RUN_DETAILS
WHERE	job_name =	'CHECK_BANNER_J'
ORDER	BY	1 DESC	;

ALTER VIEW check_banner_log OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW check_contractor_technical (vertragsnummer, asp_mail_l, email, asp_gid_l, gid, asp_name_l, name, asp_vorname_l, givenname, asp_tel_l, telefon, asp_abt_l, department, asp_l_l, location) AS SELECT vertragsnummer,
asp_mail_L,
X.email,
asp_gid_L,
X.gid,
asp_name_L,
X.name,
asp_vorname_L,
X.givenname,
asp_tel_L,
X.telefon,
asp_abt_L,
X.department,
asp_l_L,
X.location
FROM vertraege V
LEFT JOIN cdb_contract C
ON V.vertragsnummer=C.contract_number
LEFT JOIN cdb_contact X
ON C.contact_contractor_technical=X.id
WHERE
coalesce(lower(asp_mail_L),0) <> coalesce(X.email,0) OR
coalesce(asp_gid_L,0)<>coalesce(X.gid,0) OR
coalesce(initcap(asp_name_L),0)<>coalesce(X.name,0) OR
coalesce(initcap(asp_vorname_L),0)<>coalesce(X.givenname,0) OR
coalesce(asp_tel_L,0)<>coalesce(X.telefon,0) OR
coalesce(asp_abt_L,0)<>coalesce(X.department,0) OR
coalesce(asp_l_L,0)<>coalesce(X.location,0)
ORDER BY vertragsnummer;

ALTER VIEW check_contractor_technical OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW scd_v3_mailaktionen (mail, c, o, ou, l, cn, deliveryid, gender, graduatetitle, sn, givenname, usertype, recordtype, recordtypev3, firmstat, konzbet, department, building, roomnumber, telephonenumber, scdid, gid, costlocationunit, kvs, krvs, kruevs, kaw, kraw, kueraw, kpost, utc, contractstatus, status, pkiversion) AS SELECT	DISTINCT	mail		MAIL
,	C, O, OU, L, CN
,	deliveryId		DELIVERYID
,	gender		GENDER
,	graduateTitle	GRADUATETITLE
,	sn			SN
,	GivenName		GIVENNAME
,	usertype		USERTYPE
,	recordType		RECORDTYPE
,	recordTypeV3	RECORDTYPEV3
,	firmstat		FIRMSTAT
,	konzBet		KONZBET
,	Department		DEPARTMENT
,	building		BUILDING
,	roomNumber		ROOMNUMBER
,	telephoneNumber	TELEPHONENUMBER
,	scdId		SCDID
,	GID
,	costLocationUnit	COSTLOCATIONUNIT
,	kVS			KVS
,	krVS		KRVS
,	krueVS		KRUEVS
,	kAW			KAW
,	krAW		KRAW
,	kuerAW		KUERAW
,	kPost		KPOST
,	utc			UTC
,	contractstatus	CONTRACTSTATUS
,	status		STATUS
,	pkiversion		PKIVERSION
FROM	scd
WHERE	"mail"	IS  Not Null
 AND	O		<> 'TEST UNIT'
 AND	OU		<> 'SCDV3'
 AND	"usertype"	 = 'I'
 AND	"recordTypeV3" = 'H'
 AND	"status"	 = 'A'
 AND	"firmstat"	 = 'M';

ALTER VIEW scd_v3_mailaktionen OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW mgv_all_constraints_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_CONSTRAINTS' objtype, c.name objname, c.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||t.table_name ||'.'||c.name QualifiedName
FROM MD_CONSTRAINTS c, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE c.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_constraints_details OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mgv_all_stored_programs (project_id, project_name, connection_id, host, port, username, catalog_id, catalog_name, schema_id, schema_name, stored_program_id, programtype, stored_program_name, package_id_fk) AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name ,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name ,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_stored_programs.id stored_program_id ,
    md_stored_programs.programtype programtype ,
    md_stored_programs.name stored_program_name,
    md_stored_programs.package_id_fk package_id_fk
  FROM md_projects ,
    md_connections,
    md_catalogs ,
    md_schemas ,
    md_stored_programs
  WHERE md_stored_programs.schema_id_fk = md_schemas.id
  AND md_schemas.catalog_id_fk          = md_catalogs.id
  AND md_catalogs.connection_id_fk      = md_connections.id
  AND md_connections.project_id_fk      = md_projects.id;

ALTER VIEW mgv_all_stored_programs OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW status (vertragsart, vertragsnummer, asp_name_k, asp_vorname_k, asp_gid_k, asp_mail_k, asp_abt_k, kontrakt_nummer, status, department, c, o, ou, l, gid, mail, sn, givenname, recordtypev3, costlocationunit) AS SELECT	DISTINCT	Vertragsart
,	Vertragsnummer
,	Asp_Name_K
,	Asp_Vorname_K
,	Asp_GID_K
,	Asp_Mail_K
,	Asp_Abt_K
,	Kontrakt_Nummer
,	Status
, 	Department
,	C, O, OU, L
,	GID,	mail
,	sn,	GivenName
,	recordTypeV3
,	costLocationUnit
FROM	Vertraege

LEFT	JOIN	SCD
ON	Asp_GID_K =	GID
WHERE	Vertragsart	IN (
	'AP', 'BU', 'CC', 'E2',	'EL', 'GG', 'GP'
,	'ST', 'VA', 'WB', 'WS'
	)
AND (	Status = 'aktiv'
OR		Status = 'angebot'
	)
AND (	"status" = 'A'
OR		coalesce("status"::text, '') = ''
	)
AND (	"Department" <> Asp_Abt_K
OR		coalesce(GID::text, '') = ''
	)
ORDER	BY	Vertragsnummer DESC;

ALTER VIEW status OWNER TO scd_testuser;
*/


CREATE OR REPLACE VIEW mgv_scratch_derivatives (id, src_id, src_type, derived_id, derived_type, derived_connection_id_fk, transformed, original_identifier, new_identifier, derived_object_namespace, derivative_reason, security_group_id, created_on, created_by, last_updated_on, last_updated_by, enabled) AS SELECT ID,SRC_ID,SRC_TYPE,DERIVED_ID,DERIVED_TYPE,DERIVED_CONNECTION_ID_FK,TRANSFORMED,ORIGINAL_IDENTIFIER,NEW_IDENTIFIER,DERIVED_OBJECT_NAMESPACE,DERIVATIVE_REASON,SECURITY_GROUP_ID,CREATED_ON,CREATED_BY,LAST_UPDATED_ON,LAST_UPDATED_BY,ENABLED FROM MD_DERIVATIVES WHERE Derivative_Reason = 'SCRATCH';

ALTER VIEW mgv_scratch_derivatives OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mgv_all_programs_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_STORED_PROGRAMS' objtype,p.name objname, p.Id objid,  'MD_STORED_PROGRAMS' MainObjType,p.name MAINOBJNAME,p.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||p.name  QualifiedName
FROM MD_STORED_PROGRAMS p,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE p.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_programs_details OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mgv_all_column_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT 'MD_COLUMNS' objtype, c.COLUMN_NAME objname, c.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||t.table_name ||'.'||c.COLUMN_NAME QualifiedName
FROM MD_COLUMNS c, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE c.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

ALTER VIEW mgv_all_column_details OWNER TO scd_testuser;


/*
CREATE OR REPLACE VIEW check_contract_type (vertragsnummer, vertragsart, name) AS SELECT vertragsnummer,
vertragsart,
T.name
FROM vertraege V
LEFT JOIN cdb_contract C
ON V.vertragsnummer=C.contract_number
LEFT JOIN cdb_contract_type T
ON C.type=T.id
WHERE coalesce(vertragsart,0)<>coalesce(T.name,0);

ALTER VIEW check_contract_type OWNER TO scd_testuser;
*/
/*
CREATE OR REPLACE VIEW check_customer_commercial (vertragsnummer, asp_mail_k_kaufm, email, asp_gid_k_kaufm, gid, asp_name_k_kaufm, name, asp_vorname_k_kaufm, givenname, asp_tel_k_kaufm, telefon, asp_abt_k_kaufm, department, asp_l_k_kaufm, location) AS SELECT vertragsnummer,
asp_mail_k_kaufm,
X.email,
asp_gid_k_kaufm,
X.gid,
asp_name_K_kaufm,
X.name,
asp_vorname_k_kaufm,
X.givenname,
asp_tel_k_kaufm,
X.telefon,
asp_abt_k_kaufm,
X.department,
asp_l_k_kaufm,
X.location
FROM vertraege V
LEFT JOIN cdb_contract C
ON V.vertragsnummer=C.contract_number
LEFT JOIN cdb_contact X
ON C.contact_customer_commercial=X.id
WHERE coalesce(lower(asp_mail_k_kaufm),0) <> coalesce(lower(X.email),0) OR
coalesce(asp_gid_k_kaufm,0) <> coalesce(X.gid,0) OR
coalesce(initcap(asp_name_K_kaufm),0) <> coalesce(initcap(X.name),0) OR
coalesce(initcap(asp_vorname_k_kaufm),0) <> coalesce(initcap(X.givenname),0) OR
coalesce(asp_tel_k_kaufm,0) <> coalesce(X.telefon,0) OR
coalesce(asp_abt_k_kaufm,0) <> coalesce(X.department,0) OR
coalesce(asp_l_k_kaufm,0) <> coalesce(X.location,0)
ORDER BY vertragsnummer;

ALTER VIEW check_customer_commercial OWNER TO scd_testuser;
*/

CREATE OR REPLACE VIEW mgv_all_captured_sql (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname, native_sql, linecount) AS SELECT d.OBJTYPE,d.OBJNAME,d.OBJID,d.MAINOBJTYPE,d.MAINOBJNAME,d.MAINOBJID,d.SCHEMANAME,d.SCHEMAID,d.CATALOGNAME,d.CATALOGID,d.CONNNAME,d.CONNID,d.PROJECTNAME,d.PROJECTID,d.CAPTUREDORCONVERTED,d.QUALIFIEDNAME, p.native_sql,p.linecount
FROM md_stored_programs p , mgv_all_programs_details d
WHERE p.id = d.objid
AND d.capturedorconverted = 'CAPTURED'

UNION ALL

SELECT d.OBJTYPE,d.OBJNAME,d.OBJID,d.MAINOBJTYPE,d.MAINOBJNAME,d.MAINOBJID,d.SCHEMANAME,d.SCHEMAID,d.CATALOGNAME,d.CATALOGID,d.CONNNAME,d.CONNID,d.PROJECTNAME,d.PROJECTID,d.CAPTUREDORCONVERTED,d.QUALIFIEDNAME,v.native_sql,v.linecount
FROM md_views v , mgv_all_view_details d
WHERE v.id = d.objid
AND d.capturedorconverted = 'CAPTURED'

UNION ALL

SELECT d.OBJTYPE,d.OBJNAME,d.OBJID,d.MAINOBJTYPE,d.MAINOBJNAME,d.MAINOBJID,d.SCHEMANAME,d.SCHEMAID,d.CATALOGNAME,d.CATALOGID,d.CONNNAME,d.CONNID,d.PROJECTNAME,d.PROJECTID,d.CAPTUREDORCONVERTED,d.QUALIFIEDNAME ,t.native_sql,t.linecount
FROM md_triggers t , mgv_all_trigger_details d
WHERE t.id = d.objid
AND d.capturedorconverted = 'CAPTURED';

ALTER VIEW mgv_all_captured_sql OWNER TO scd_testuser;

/*
CREATE OR REPLACE VIEW dn (gid, givenname, sn, usertype, l, ou, o, c, status, recordtype, dn) AS select gid, givenname, sn, usertype,l,ou,o,c,status,recordtype,
upper(givenname) || ' ' || upper( sn)
|| ' ' || gid
||
case usertype 
when 'X' then ' (EXT)'
when coalesce(usertype,'') then ''
else '' end ||
case recordtype 
when 'S' then ' S'
when coalesce(usertype,'') then ''
else '' end
|| ',l=' || l
|| ',o=' ||o
|| ',c=' || c AS dn
FROM v_scd;

ALTER VIEW dn OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW unknown_ap_download_gids (contract_id, name, delivery_id, enabled, scheduler_id, cron, scheduler_enabled, exporter_id, exporter_enabled, file_name, download_for, gid) AS SELECT contract_id
,name
,delivery_id
,enabled
,scheduler_id
,cron
,scheduler_enabled
,exporter_id
,exporter_enabled
,file_name
,download_for
,regexp_substr(download_for,'[^| ]+',1,column_value) as gid
FROM (
SELECT D.delivery_id
,D.contract_id
,D.name
,D.description
,D.enabled
,D.query
,D.user_id
,D.added_ts
,D.latest_run_result
,D.latest_run_ts
,D.to_remove_ts
,D.supp_data_file
,D.supp_data_filetype
,D.supp_data_delimiter
,D.supp_data_file_mod_ts
,D.supp_data_has_header
,D.supp_data_enabled
,S.scheduler_id
,S.cron
,S.enabled AS scheduler_enabled
,S.user_id AS scheduler_user_id
,S.added_ts AS scheduler_addedd_ts
,E.exporter_id
,E.file_name
,E.file_format
,E.output_to
,E.delimiter
,E.charset
,E.zip_file_name
,E.print_header
,E.openft_addr
,E.OPENFT_TRANSFER_ADM
,E.enabled AS exporter_enabled
,E.user_id AS exporter_user_id
,E.added_ts AS exporter_added_ts
,E.download_for
,E.transfer_files
FROM ap_delivery D

LEFT JOIN ap_scheduler S
ON D.delivery_id=S.delivery_id
LEFT JOIN ap_exporter  E
ON S.scheduler_id=E.scheduler_id
WHERE D.enabled=1
AND coalesce(D.to_remove_ts::text, '') = ''

)
,
TABLE(cast(multiset(WITH RECURSIVE cte AS (
select level
        
        LEVEL <= length(download_for) -
               length(replace(download_for, ' ', ''))+1  UNION ALL
select level
        
        LEVEL <= length(download_for) -
               length(replace(download_for, ' ', ''))+1 JOIN cte c ON ()

) SELECT * FROM cte)
               AS odcinumberlist))
WHERE (download_for AND download_for::text <> '')
AND regexp_substr(download_for,'[^| ]+',1,column_value) NOT IN (SELECT gid FROM v_scd WHERE (gid AND gid::text <> '') AND status='A')
AND regexp_substr(download_for,'[^| ]+',1,column_value) NOT LIKE 'AP%'
ORDER BY enabled DESC, contract_id, regexp_substr(download_for,'[^| ]+',1,column_value);

ALTER VIEW unknown_ap_download_gids OWNER TO scd_testuser;

*/

/*
CREATE OR REPLACE VIEW mgv_all_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname) AS SELECT objtype,objname,objid,mainobjtype,mainobjname,mainobjid,schemaname,schemaid,catalogname,catalogid,connname,connid,projectname,projectid,capturedorconverted,qualifiedname FROM MGV_ALL_CATALOG_DETAILS

UNION ALL

SELECT "objtype","objname","objid","mainobjtype","mainobjname","mainobjid","schemaname","schemaid","catalogname","catalogid","connname","connid","projectname","projectid","capturedorconverted","qualifiedname" from mgv_all_schema_details

UNION ALL

SELECT "objtype","objname","objid","mainobjtype","mainobjname","mainobjid","schemaname","schemaid","catalogname","catalogid","connname","connid","projectname","projectid","capturedorconverted","qualifiedname" from mgv_all_tables_details

UNION ALL

SELECT "objtype","objname","objid","mainobjtype","mainobjname","mainobjid","schemaname","schemaid","catalogname","catalogid","connname","connid","projectname","projectid","capturedorconverted","qualifiedname" FROM MGV_ALL_COLUMN_DETAILS

UNION ALL

SELECT "objtype","objname","objid","mainobjtype","mainobjname","mainobjid","schemaname","schemaid","catalogname","catalogid","connname","connid","projectname","projectid","capturedorconverted","qualifiedname" FROM MGV_ALL_CONSTRAINTS_DETAILS

UNION ALL

SELECT "objtype","objname","objid","mainobjtype","mainobjname","mainobjid","schemaname","schemaid","catalogname","catalogid","connname","connid","projectname","projectid","capturedorconverted","qualifiedname" FROM MGV_ALL_INDEX_DETAILS

UNION ALL

SELECT "objtype","objname","objid","mainobjtype","mainobjname","mainobjid","schemaname","schemaid","catalogname","catalogid","connname","connid","projectname","projectid","capturedorconverted","qualifiedname" FROM MGV_ALL_TRIGGER_DETAILS

UNION ALL

SELECT "objtype","objname","objid","mainobjtype","mainobjname","mainobjid","schemaname","schemaid","catalogname","catalogid","connname","connid","projectname","projectid","capturedorconverted","qualifiedname" FROM MGV_ALL_VIEW_DETAILS

UNION ALL

SELECT "objtype","objname","objid","mainobjtype","mainobjname","mainobjid","schemaname","schemaid","catalogname","catalogid","connname","connid","projectname","projectid","capturedorconverted","qualifiedname" FROM MGV_ALL_PROGRAMS_DETAILS

UNION ALL

SELECT "objtype","objname","objid","mainobjtype","mainobjname","mainobjid","schemaname","schemaid","catalogname","catalogid","connname","connid","projectname","projectid","capturedorconverted","qualifiedname" FROM MGV_ALL_PARTITIONS_DETAILS;

ALTER VIEW mgv_all_details OWNER TO scd_testuser;
*/

/*
CREATE OR REPLACE VIEW mgv_derived_details (capcatalogid, capcatalogname, capconnid, capconnname, capmainobjid, capmainobjname, capmainobjtype, capobjid, capobjname, capobjtype, capprojectid, capprojectname, capqualifiedname, capschemaid, capschemaname, concatalogid, concatalogname, conconnid, conconnname, conmainobjid, conmainobjname, conmainobjtype, conobjid, conobjname, conobjtype, conprojectid, conprojectname, conqualifiedname, conschemaid, conschemaname, derivative_reason, transformed) AS select d1.catalogid capcatalogid,
   d1.catalogname capcatalogname,
   d1.connid capconnid,
   d1.connname capconnname,
   d1.mainobjid capmainobjid,
   d1.mainobjname capmainobjname,
   d1.mainobjtype capmainobjtype ,
   d1.objid capobjid,
   d1.objname capobjname,
   d1.objtype capobjtype,
   d1.projectid capprojectid,
   d1.projectname capprojectname,
   d1.qualifiedname capqualifiedname,
   d1.schemaid capschemaid,
   d1.schemaname capschemaname,
   d2.catalogid concatalogid,
   d2.catalogname concatalogname,
   d2.connid conconnid,
   d2.connname conconnname,
   d2.mainobjid conmainobjid,
   d2.mainobjname conmainobjname,
   d2.mainobjtype conmainobjtype ,
   d2.objid conobjid,
   d2.objname conobjname,
   d2.objtype conobjtype,
   d2.projectid conprojectid,
   d2.projectname conprojectname,
   d2.qualifiedname conqualifiedname,
   d2.schemaid conschemaid,
   d2.schemaname conschemaname,
    der.derivative_reason,
    der.transformed
  FROM mgv_all_details d1
  LEFT OUTER JOIN md_derivatives der
  ON der.src_id              = d1.objid
  AND coalesce(der.derivative_reason::text, '') = ''
  LEFT OUTER JOIN mgv_all_details d2
  ON der.derived_id            = d2.objid
  WHERE d1.capturedorconverted = 'CAPTURED'
  AND coalesce(der.derivative_reason::text, '') = '';

ALTER VIEW mgv_derived_details OWNER TO scd_testuser;

*/

CREATE OR REPLACE VIEW mgv_all_columndt_details (objtype, objname, objid, mainobjtype, mainobjname, mainobjid, schemaname, schemaid, catalogname, catalogid, connname, connid, projectname, projectid, capturedorconverted, qualifiedname, datatype, isidentity) AS SELECT 'MD_COLUMNS' objtype, c.COLUMN_NAME objname, c.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname ,proj.id projectid,
coalesce(conn.type,'CAPTURED') CapturedOrConverted,
CASE WHEN coalesce(conn.type::text, '') = '' THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||t.table_name ||'.'||c.COLUMN_NAME QualifiedName,
c.column_type datatype,
CASE WHEN p.PROP_KEY='SEEDVALUE' THEN 'Y' ELSE 'N' END IsIdentity
FROM MD_COLUMNS c LEFT OUTER JOIN MD_ADDITIONAL_PROPERTIES p ON c.id =p.ref_id_fk
, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn,MD_PROJECTS proj
WHERE c.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;

CREATE OR REPLACE VIEW zddb_filenames (vertragsnummer, file_names) AS SELECT vertragsnummer, string_agg(file_name || '.' || lower(file_format), ' | ' ORDER BY vertragsnummer) AS file_names
FROM (SELECT
D.delivery_id
,D.name
,D.contract_id AS vertragsnummer
,D.enabled
,S.scheduler_id
,E.exporter_id
,S.enabled AS scheduler_enabled
,E.enabled AS exp_enabled
,E.file_name
,E.file_format
,V.SERVER AS zddb_server
,E.OPENFT_TRANSFER_ADM
,V.ZUGANGSBERECHTIGUNG AS ZDDB_Zugangsberechtigung
,E.DOWNLOAD_FOR
,V.EMFPAENGERMAIL AS "ZDDB-Empfängermail"
FROM ap_delivery D
LEFT JOIN ap_scheduler S
ON D.delivery_id=S.delivery_id
LEFT JOIN ap_exporter E
ON E.scheduler_id = S.scheduler_id
LEFT JOIN vertraege V
ON V.vertragsnummer = D.contract_id
WHERE D.enabled=1 AND coalesce(D.to_remove_ts::text, '') = '' AND S.enabled=1 AND E.enabled=1) alias3
GROUP BY vertragsnummer;

ALTER VIEW zddb_filenames OWNER TO scd_testuser;

/* VRT Trigger Creation - Section 2.6 */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = vrt,oracle,public;

SET check_function_bodies = false;

DROP TRIGGER IF EXISTS app_config_trigger ON app_config CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_app_config_trigger() RETURNS trigger AS $BODY$
BEGIN
SELECT nextval('vrt.app_config_sequence') INTO STRICT NEW.CONFIG_ID;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_app_config_trigger() FROM PUBLIC;

ALTER FUNCTION trigger_fct_app_config_trigger() OWNER TO scd_testuser;

CREATE TRIGGER app_config_trigger
	BEFORE INSERT ON app_config FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_app_config_trigger();

DROP TRIGGER IF EXISTS app_trigger ON app CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_app_trigger() RETURNS trigger AS $BODY$
BEGIN
SELECT nextval('vrt.app_sequence') INTO STRICT NEW.APP_ID;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_app_trigger() FROM PUBLIC;

ALTER FUNCTION trigger_fct_app_trigger() OWNER TO scd_testuser;

CREATE TRIGGER app_trigger
	BEFORE INSERT ON app FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_app_trigger();

DROP TRIGGER IF EXISTS tippderwoche_tr ON tippderwoche CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_tippderwoche_tr() RETURNS trigger AS $BODY$
BEGIN
  select nextval('tippderwoche_seq') into STRICT NEW.nr;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_tippderwoche_tr() FROM PUBLIC;

ALTER FUNCTION trigger_fct_tippderwoche_tr() OWNER TO scd_testuser;

CREATE TRIGGER tippderwoche_tr
	BEFORE INSERT ON tippderwoche FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_tippderwoche_tr();

DROP TRIGGER IF EXISTS user_settings_to_user_service ON ws_user_settings CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_user_settings_to_user_service() RETURNS trigger AS $BODY$
DECLARE
    rows_found bigint;
BEGIN
    IF TG_OP = 'INSERT' THEN
    SELECT COUNT(*)
    INTO STRICT rows_found
    FROM WS_USER_SERVICE WHERE USER_ID = NEW.USERID AND SERVICE = 'SCDWS';

    IF rows_found = 0
        THEN
            INSERT INTO WS_USER_SERVICE(USER_ID, SERVICE)
            VALUES (NEW.USERID, 'SCDWS');
        END IF;
    END IF;

    IF TG_OP = 'DELETE' THEN
        DELETE FROM WS_USER_SERVICE WHERE
        USER_ID = OLD.USERID
        AND SERVICE = 'SCDWS';
    END IF;

    IF TG_OP = 'UPDATE' THEN
        IF (OLD.USERID != NEW.USERID) THEN
            UPDATE WS_USER_SERVICE
            SET USER_ID = NEW.USERID
            WHERE USER_ID = OLD.USERID
            AND SERVICE = 'SCDWS';
        END IF;
    END IF;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_user_settings_to_user_service() FROM PUBLIC;

ALTER FUNCTION trigger_fct_user_settings_to_user_service() OWNER TO scd_testuser;

CREATE TRIGGER user_settings_to_user_service
	AFTER INSERT OR UPDATE OR DELETE ON ws_user_settings FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_user_settings_to_user_service();

DROP TRIGGER IF EXISTS ws_audit_cumulate_trigger ON ws_audit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ws_audit_cumulate_trigger() RETURNS trigger AS $BODY$
BEGIN
  DECLARE theCount  bigint;
          timeValue varchar(16);
  BEGIN
     SELECT TO_CHAR(statement_timestamp(),'yyyy-mm') INTO STRICT timeValue;
     SELECT COUNT(*) INTO STRICT theCount FROM WS_CUMULATED_AUDIT WHERE year_month = timeValue AND USERID = NEW.USERID;

     IF theCount < 1 THEN
  	    INSERT INTO WS_CUMULATED_AUDIT( id, year_month, userid, record_count ) VALUES ( NEW.ID, timeValue, NEW.USERID, NEW.RECORD_COUNT);
  	 ELSE
  	  	UPDATE WS_CUMULATED_AUDIT SET record_count =  record_count + NEW.RECORD_COUNT WHERE year_month = timeValue AND USERID = NEW.USERID;
     END IF;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_ws_audit_cumulate_trigger() FROM PUBLIC;

ALTER FUNCTION trigger_fct_ws_audit_cumulate_trigger() OWNER TO scd_testuser;

CREATE TRIGGER ws_audit_cumulate_trigger
	AFTER INSERT ON ws_audit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_ws_audit_cumulate_trigger();

DROP TRIGGER IF EXISTS ws_audit_trigger ON ws_audit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ws_audit_trigger() RETURNS trigger AS $BODY$
BEGIN
  NEW.ID := nextval('ws_audit_sequence');
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_ws_audit_trigger() FROM PUBLIC;

ALTER FUNCTION trigger_fct_ws_audit_trigger() OWNER TO scd_testuser;

CREATE TRIGGER ws_audit_trigger
	BEFORE INSERT ON ws_audit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_ws_audit_trigger();

DROP TRIGGER IF EXISTS ws_colgroup_trigger ON ws_colgroup_column_ids CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ws_colgroup_trigger() RETURNS trigger AS $BODY$
BEGIN
  NEW.ID := nextval('ws_colgroup_sequence');
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_ws_colgroup_trigger() FROM PUBLIC;

ALTER FUNCTION trigger_fct_ws_colgroup_trigger() OWNER TO scd_testuser;

CREATE TRIGGER ws_colgroup_trigger
	BEFORE INSERT ON ws_colgroup_column_ids FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_ws_colgroup_trigger();

DROP TRIGGER IF EXISTS ws_usersett_clean_contr_mail ON ws_user_settings CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ws_usersett_clean_contr_mail() RETURNS trigger AS $BODY$
BEGIN
	DELETE FROM WS_CONTRACT_MAIL WHERE USERID = NEW.USERID;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_ws_usersett_clean_contr_mail() FROM PUBLIC;

ALTER FUNCTION trigger_fct_ws_usersett_clean_contr_mail() OWNER TO scd_testuser;

CREATE TRIGGER ws_usersett_clean_contr_mail
	AFTER INSERT OR UPDATE ON ws_user_settings FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_ws_usersett_clean_contr_mail();

DROP TRIGGER IF EXISTS ws_user_columns_trigger ON ws_user_colgroup_ids CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ws_user_columns_trigger() RETURNS trigger AS $BODY$
BEGIN
  NEW.ID := nextval('ws_user_columns_sequence');
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_ws_user_columns_trigger() FROM PUBLIC;

ALTER FUNCTION trigger_fct_ws_user_columns_trigger() OWNER TO scd_testuser;

CREATE TRIGGER ws_user_columns_trigger
	BEFORE INSERT ON ws_user_colgroup_ids FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_ws_user_columns_trigger();

/* VRT MVIEW Creation - Section - 2.7.2 */

SET client_encoding TO 'UTF8';

SET search_path = vrt,oracle,public;

SET check_function_bodies = false;

CREATE MATERIALIZED VIEW md_regex_mview AS
SELECT  pr.PROJECT_NAME, pr.ID PROJECT_ID, c.ID CONNECTION_ID, c.NAME CONNECTION_NAME, mc.ID CATALOG_ID,
        mc.CATALOG_NAME,s.id SCHEMA_ID,s.NAME SCHEMA_NAME, p.ID PROGRAM_ID, p.name PROGRAM_NAME,
        rg.DESCRIPTION ITEM, regexp_count(p.native_sql,rg.REGEX,1,'ix') VALUE
FROM MD_STORED_PROGRAMS p,
  md_projects pr,
  md_connections c,
  md_schemas s,
  MD_CATALOGS mc,
  MD_CODE_REGEX rg
WHERE coalesce(c.TYPE::text, '') = '' --Shows captured
AND mc.CONNECTION_ID_FK=c.id
AND mc.id              =s.CATALOG_ID_FK
AND pr.PROJECT_NAME LIKE 'SS%'
and pr.id=c.PROJECT_ID_FK
and p.SCHEMA_ID_FK=s.ID
and regexp_count(p.native_sql,rg.REGEX,1,'ix')>0;


ALTER MATERIALIZED VIEW md_regex_mview OWNER TO scd_testuser;

CREATE MATERIALIZED VIEW md_regex_schema_mview AS
SELECT  PROJECT_ID, CONNECTION_ID, CONNECTION_NAME,CATALOG_ID,
        CATALOG_NAME,SCHEMA_ID,SCHEMA_NAME, ITEM, SUM(VALUE) VALUE FROM MD_REGEX_MVIEW
        group by PROJECT_NAME, PROJECT_ID, CONNECTION_ID, CONNECTION_NAME,CATALOG_ID,
        CATALOG_NAME,SCHEMA_ID,SCHEMA_NAME, ITEM;


ALTER MATERIALIZED VIEW md_regex_schema_mview OWNER TO scd_testuser;

CREATE MATERIALIZED VIEW statdn AS
SELECT		C, O, OU, L
,	Count(*)	Anz
FROM	scd
GROUP	BY	C, O, OU, L;


ALTER MATERIALIZED VIEW statdn OWNER TO scd_testuser;

SET client_encoding TO 'UTF8';



SET check_function_bodies = false;



/* MAK Schema Creation - Section 8.1.1 */ 

CREATE SCHEMA IF NOT EXISTS mak;
ALTER SCHEMA mak OWNER TO scd_testuser;

SET search_path = mak,oracle,public;


/* MAK Synounymous Creation - Section 8.1.2 */


-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = mak,oracle,public;


SET check_function_bodies = false;

CREATE OR REPLACE VIEW mak.adrarch AS SELECT * FROM sds.adrarch;
ALTER VIEW mak.adrarch OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.adrdat AS SELECT * FROM sds.adrdat;
ALTER VIEW mak.adrdat OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.attr AS SELECT * FROM sds.attr;
ALTER VIEW mak.attr OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.attrchk AS SELECT * FROM sds.attrchk;
ALTER VIEW mak.attrchk OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.attrsetv AS SELECT * FROM sds.attrsetv;
ALTER VIEW mak.attrsetv OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.batch_job_execution AS SELECT * FROM sds.batch_job_execution;
ALTER VIEW mak.batch_job_execution OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.batch_job_execution_context AS SELECT * FROM sds.batch_job_execution_context;
ALTER VIEW mak.batch_job_execution_context OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.batch_job_execution_params AS SELECT * FROM sds.batch_job_execution_params;
ALTER VIEW mak.batch_job_execution_params OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.batch_job_execution_seq AS SELECT * FROM sds.batch_job_execution_seq;
ALTER VIEW mak.batch_job_execution_seq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.batch_job_instance AS SELECT * FROM sds.batch_job_instance;
ALTER VIEW mak.batch_job_instance OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.batch_job_seq AS SELECT * FROM sds.batch_job_seq;
ALTER VIEW mak.batch_job_seq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.batch_step_execution AS SELECT * FROM sds.batch_step_execution;
ALTER VIEW mak.batch_step_execution OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.batch_step_execution_context AS SELECT * FROM sds.batch_step_execution_context;
ALTER VIEW mak.batch_step_execution_context OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.batch_step_execution_seq AS SELECT * FROM sds.batch_step_execution_seq;
ALTER VIEW mak.batch_step_execution_seq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.dn AS SELECT * FROM sds.dn;
ALTER VIEW mak.dn OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.fits_blacklist AS SELECT * FROM sds.fits_blacklist;
ALTER VIEW mak.fits_blacklist OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.fits_events AS SELECT * FROM sds.fits_events;
ALTER VIEW mak.fits_events OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.fits_events_seq AS SELECT * FROM sds.fits_events_seq;
ALTER VIEW mak.fits_events_seq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.fits_scope AS SELECT * FROM sds.fits_scope;
ALTER VIEW mak.fits_scope OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.fits_trigger AS SELECT * FROM sds.fits_trigger;
ALTER VIEW mak.fits_trigger OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.fits_trigger_seq AS SELECT * FROM sds.fits_trigger_seq;
ALTER VIEW mak.fits_trigger_seq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.gid_data AS SELECT * FROM sds.gid_data;
ALTER VIEW mak.gid_data OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.gid_datauser AS SELECT * FROM sds.gid_datauser;
ALTER VIEW mak.gid_datauser OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.gid_datauser2 AS SELECT * FROM sds.gid_datauser2;
ALTER VIEW mak.gid_datauser2 OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.gid_user AS SELECT * FROM sds.gid_user;
ALTER VIEW mak.gid_user OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.join AS SELECT * FROM sds.join;
ALTER VIEW mak.join OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.konfig AS SELECT * FROM sds.konfig;
ALTER VIEW mak.konfig OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.liefnt AS SELECT * FROM sds.liefnt;
ALTER VIEW mak.liefnt OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.liefntsuz AS SELECT * FROM sds.liefntsuz;
ALTER VIEW mak.liefntsuz OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.mesg AS SELECT * FROM sds.mesg;
ALTER VIEW mak.mesg OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.prot AS SELECT * FROM sds.prot;
ALTER VIEW mak.prot OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.sgid_err AS SELECT * FROM sds.sgid_err;
ALTER VIEW mak.sgid_err OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.ssd AS SELECT * FROM sds.ssd;
ALTER VIEW mak.ssd OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.tcgids AS SELECT * FROM sds.tcgids;
ALTER VIEW mak.tcgids OWNER TO scd_testuser;
CREATE OR REPLACE VIEW mak.v_fits_last AS SELECT * FROM sds.v_fits_last;
ALTER VIEW mak.v_fits_last OWNER TO scd_testuser;


/* TCG Synounynous Creation - Section 7.1.2 */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = tcg,oracle,public;

SET check_function_bodies = false;

CREATE OR REPLACE VIEW tcg.adrdat AS SELECT * FROM sds.adrdat;
ALTER VIEW tcg.adrdat OWNER TO scd_testuser;
/*CREATE OR REPLACE VIEW tcg.adrjoin AS SELECT * FROM sds.adrjoin;
ALTER VIEW tcg.adrjoin OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.attchk AS SELECT * FROM sds.attchk;
ALTER VIEW tcg.attchk OWNER TO scd_testuser; 
CREATE OR REPLACE VIEW tcg.attschk AS SELECT * FROM sds.attschk;
ALTER VIEW tcg.attschk OWNER TO scd_testuser; */
CREATE OR REPLACE VIEW tcg.batch_job_execution AS SELECT * FROM sds.batch_job_execution;
ALTER VIEW tcg.batch_job_execution OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.batch_job_execution_context AS SELECT * FROM sds.batch_job_execution_context;
ALTER VIEW tcg.batch_job_execution_context OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.batch_job_execution_params AS SELECT * FROM sds.batch_job_execution_params;
ALTER VIEW tcg.batch_job_execution_params OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.batch_job_execution_seq AS SELECT * FROM sds.batch_job_execution_seq;
ALTER VIEW tcg.batch_job_execution_seq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.batch_job_instance AS SELECT * FROM sds.batch_job_instance;
ALTER VIEW tcg.batch_job_instance OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.batch_job_seq AS SELECT * FROM sds.batch_job_seq;
ALTER VIEW tcg.batch_job_seq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.batch_step_execution AS SELECT * FROM sds.batch_step_execution;
ALTER VIEW tcg.batch_step_execution OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.batch_step_execution_context AS SELECT * FROM sds.batch_step_execution_context;
ALTER VIEW tcg.batch_step_execution_context OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.batch_step_execution_seq AS SELECT * FROM sds.batch_step_execution_seq;
ALTER VIEW tcg.batch_step_execution_seq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.berch AS SELECT * FROM sds.berch;
ALTER VIEW tcg.berch OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.cl_user AS SELECT * FROM sds.cl_user;
ALTER VIEW tcg.cl_user OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.dn AS SELECT * FROM sds.dn;
ALTER VIEW tcg.dn OWNER TO scd_testuser;
/*CREATE OR REPLACE VIEW tcg.dnliefnt AS SELECT * FROM sds.dnliefnt;
ALTER VIEW tcg.dnliefnt OWNER TO scd_testuser; 
CREATE OR REPLACE VIEW tcg.dnstmgen AS SELECT * FROM sds.dnstmgen;
ALTER VIEW tcg.dnstmgen OWNER TO scd_testuser;*/ 
CREATE OR REPLACE VIEW tcg.dn_srq AS SELECT * FROM sds.dn_srq;
ALTER VIEW tcg.dn_srq OWNER TO scd_testuser; 
CREATE OR REPLACE VIEW tcg.fits_events AS SELECT * FROM sds.fits_events;
ALTER VIEW tcg.fits_events OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_chart_data AS SELECT * FROM sds.ggw_chart_data;
ALTER VIEW tcg.ggw_chart_data OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_chart_data_sequence AS SELECT * FROM sds.ggw_chart_data_sequence;
ALTER VIEW tcg.ggw_chart_data_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_gid_batch AS SELECT * FROM sds.ggw_gid_batch;
ALTER VIEW tcg.ggw_gid_batch OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_gid_batch_id_sequence AS SELECT * FROM sds.ggw_gid_batch_id_sequence;
ALTER VIEW tcg.ggw_gid_batch_id_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_gid_pw AS SELECT * FROM sds.ggw_gid_pw;
ALTER VIEW tcg.ggw_gid_pw OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_jobs AS SELECT * FROM sds.ggw_jobs;
ALTER VIEW tcg.ggw_jobs OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_job_id_sequence AS SELECT * FROM sds.ggw_job_id_sequence;
ALTER VIEW tcg.ggw_job_id_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_login_blocked AS SELECT * FROM sds.ggw_login_blocked;
ALTER VIEW tcg.ggw_login_blocked OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_login_failure AS SELECT * FROM sds.ggw_login_failure;
ALTER VIEW tcg.ggw_login_failure OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_logs AS SELECT * FROM sds.ggw_logs;
ALTER VIEW tcg.ggw_logs OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_log_id_sequence AS SELECT * FROM sds.ggw_log_id_sequence;
ALTER VIEW tcg.ggw_log_id_sequence OWNER TO scd_testuser;
/*CREATE OR REPLACE VIEW tcg.ggw_method_count AS SELECT * FROM sds.ggw_method_count;
ALTER VIEW tcg.ggw_method_count OWNER TO scd_testuser; 
CREATE OR REPLACE VIEW tcg.ggw_method_count_id_sequence AS SELECT * FROM sds.ggw_method_count_id_sequence;
ALTER VIEW tcg.ggw_method_count_id_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_method_count_v AS SELECT * FROM sds.ggw_method_count_v; 
ALTER VIEW tcg.ggw_method_count_v OWNER TO scd_testuser; */
CREATE OR REPLACE VIEW tcg.ggw_photoportal_blocked AS SELECT * FROM sds.ggw_photoportal_blocked;
ALTER VIEW tcg.ggw_photoportal_blocked OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_photoportal_failed AS SELECT * FROM sds.ggw_photoportal_failed;
ALTER VIEW tcg.ggw_photoportal_failed OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_properties AS SELECT * FROM sds.ggw_properties;
ALTER VIEW tcg.ggw_properties OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_properties_id_sequence AS SELECT * FROM sds.ggw_properties_id_sequence;
ALTER VIEW tcg.ggw_properties_id_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_report_config AS SELECT * FROM sds.ggw_report_config;
ALTER VIEW tcg.ggw_report_config OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_report_config_sequence AS SELECT * FROM sds.ggw_report_config_sequence;
ALTER VIEW tcg.ggw_report_config_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_rfc_servers AS SELECT * FROM sds.ggw_rfc_servers;
ALTER VIEW tcg.ggw_rfc_servers OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_rfc_servers_id_sequence AS SELECT * FROM sds.ggw_rfc_servers_id_sequence;
ALTER VIEW tcg.ggw_rfc_servers_id_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_role AS SELECT * FROM sds.ggw_role;
ALTER VIEW tcg.ggw_role OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_role_id_sequence AS SELECT * FROM sds.ggw_role_id_sequence;
ALTER VIEW tcg.ggw_role_id_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_user AS SELECT * FROM sds.ggw_user;
ALTER VIEW tcg.ggw_user OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_user_id_sequence AS SELECT * FROM sds.ggw_user_id_sequence;
ALTER VIEW tcg.ggw_user_id_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_user_role AS SELECT * FROM sds.ggw_user_role;
ALTER VIEW tcg.ggw_user_role OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.ggw_user_role_sequence AS SELECT * FROM sds.ggw_user_role_sequence;
ALTER VIEW tcg.ggw_user_role_sequence OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gidakt AS SELECT * FROM sds.gidakt;
ALTER VIEW tcg.gidakt OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gidband AS SELECT * FROM sds.gidband;
ALTER VIEW tcg.gidband OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gidzchn AS SELECT * FROM sds.gidzchn;
ALTER VIEW tcg.gidzchn OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gid_bl_dn AS SELECT * FROM sds.gid_bl_dn;
ALTER VIEW tcg.gid_bl_dn OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gid_bl_geb AS SELECT * FROM sds.gid_bl_geb;
ALTER VIEW tcg.gid_bl_geb OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gid_clearing AS SELECT * FROM sds.gid_clearing;
ALTER VIEW tcg.gid_clearing OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gid_clearing_mail AS SELECT * FROM sds.gid_clearing_mail;
ALTER VIEW tcg.gid_clearing_mail OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gid_data AS SELECT * FROM sds.gid_data;
ALTER VIEW tcg.gid_data OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gid_datauser AS SELECT * FROM sds.gid_datauser;
ALTER VIEW tcg.gid_datauser OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gid_datauser2 AS SELECT * FROM sds.gid_datauser2;
ALTER VIEW tcg.gid_datauser2 OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gid_pw AS SELECT * FROM sds.gid_pw;
ALTER VIEW tcg.gid_pw OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.gid_user AS SELECT * FROM sds.gid_user;
ALTER VIEW tcg.gid_user OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.konfig AS SELECT * FROM sds.konfig;
ALTER VIEW tcg.konfig OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.liefnt AS SELECT * FROM sds.liefnt;
ALTER VIEW tcg.liefnt OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.liefnt_gid AS SELECT * FROM sds.liefnt_gid;
ALTER VIEW tcg.liefnt_gid OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.liefnt_srq AS SELECT * FROM sds.liefnt_srq;
ALTER VIEW tcg.liefnt_srq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.mesg AS SELECT * FROM sds.mesg;
ALTER VIEW tcg.mesg OWNER TO scd_testuser;
/*CREATE OR REPLACE VIEW tcg.pgid AS SELECT * FROM sds.pgid;
ALTER VIEW tcg.pgid OWNER TO scd_testuser; */
CREATE OR REPLACE VIEW tcg.sgid_err AS SELECT * FROM sds.sgid_err;
ALTER VIEW tcg.sgid_err OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.stmgen AS SELECT * FROM sds.stmgen;
ALTER VIEW tcg.stmgen OWNER TO scd_testuser;
CREATE OR REPLACE VIEW tcg.stmgendn AS SELECT * FROM sds.stmgendn;
ALTER VIEW tcg.stmgendn OWNER TO scd_testuser; 
CREATE OR REPLACE VIEW tcg.tcgids AS SELECT * FROM sds.tcgids;
ALTER VIEW tcg.tcgids OWNER TO scd_testuser;

/* Section 3.1 - Reorg Table Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';


SET check_function_bodies = false;

CREATE SCHEMA IF NOT EXISTS reorg;
ALTER SCHEMA reorg OWNER TO scd_testuser;

SET search_path = reorg,oracle,public;


CREATE TABLE gid_data_test (
	gid char(8),
	valid_date timestamp,
	leave_date timestamp,
	user_type char(1),
	owner char(8),
	join_date timestamp,
	sponsor char(8),
	c char(2),
	o varchar(16),
	ou varchar(32),
	l varchar(32),
	appl_internal_id varchar(32),
	appl_name varchar(20),
	confirmed char(1),
	scd char(1),
	isinscd smallint,
	delete_date timestamp,
	delete_uid char(8),
	modify_data_date timestamp,
	modify_data_uid char(8),
	confirm_date timestamp,
	sync_date timestamp,
	id bigint GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1 MAXVALUE 9223372036854775807 MINVALUE 1 NO CYCLE CACHE 20 )
) ;
ALTER  TABLE gid_data_test OWNER TO scd_testuser;
CREATE INDEX ix_gid_data_test_deletedate ON gid_data_test (delete_date);
CREATE INDEX ix_gid_data_test_gid ON gid_data_test (gid);
CREATE INDEX ix_gid_data_test_leavedate ON gid_data_test (leave_date);
CREATE INDEX ix_gid_data_test_owner ON gid_data_test (owner);
CREATE INDEX ix_gid_data_test_validdate ON gid_data_test (valid_date);
CREATE INDEX ix_gid_dn_test ON gid_data_test (c, o, ou, l);
ALTER TABLE gid_data_test ALTER COLUMN ID SET NOT NULL;


CREATE TABLE gid_user_test (
	gid char(8),
	creator char(8),
	creation_date timestamp,
	surname varchar(40),
	given_name varchar(40),
	name_prefix varchar(16),
	name_suffix varchar(16),
	birth_date timestamp,
	birth_place varchar(40),
	birth_name varchar(40),
	gender char(1),
	modify_user_date timestamp,
	modify_user_uid char(8),
	orig_gid char(8),
	clientid smallint
) ;
ALTER  TABLE gid_user_test OWNER TO scd_testuser;
CREATE INDEX ix_gid_given_name_test ON gid_user_test (given_name);
CREATE INDEX ix_gid_surname_test ON gid_user_test (surname);
CREATE UNIQUE INDEX ix_gid_user_test_gid ON gid_user_test (gid);


/* REORG Synounyms Creation - Section - 3.1.2 */

SET client_encoding TO 'UTF8';

SET search_path = reorg,oracle,public;

SET check_function_bodies = false;

CREATE OR REPLACE VIEW reorg.adrdat AS SELECT * FROM sds.adrdat;
ALTER VIEW reorg.adrdat OWNER TO scd_testuser;
/*CREATE OR REPLACE VIEW reorg.attchk AS SELECT * FROM sds.attchk;
ALTER VIEW reorg.attchk OWNER TO scd_testuser; */
CREATE OR REPLACE VIEW reorg.attr_check_norm AS SELECT * FROM sds.attr_check_norm;
ALTER VIEW reorg.attr_check_norm OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.attr_utf8 AS SELECT * FROM sds.attr_utf8;
ALTER VIEW reorg.attr_utf8 OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.berch AS SELECT * FROM sds.berch;
ALTER VIEW reorg.berch OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.check_err_mesg AS SELECT * FROM sds.check_err_mesg;
ALTER VIEW reorg.check_err_mesg OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.cl_user AS SELECT * FROM sds.cl_user;
ALTER VIEW reorg.cl_user OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.dn AS SELECT * FROM sds.dn;
ALTER VIEW reorg.dn OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.dnliefnt AS SELECT * FROM sds.dnliefnt;
ALTER VIEW reorg.dnliefnt OWNER TO scd_testuser;
/*CREATE OR REPLACE VIEW reorg.dnstmgen AS SELECT * FROM sds.dnstmgen;
ALTER VIEW reorg.dnstmgen OWNER TO scd_testuser;*/
CREATE OR REPLACE VIEW reorg.dn_srq AS SELECT * FROM sds.dn_srq;
ALTER VIEW reorg.dn_srq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.fits_events AS SELECT * FROM sds.fits_events;
ALTER VIEW reorg.fits_events OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gidakt AS SELECT * FROM sds.gidakt;
ALTER VIEW reorg.gidakt OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gidband AS SELECT * FROM sds.gidband;
ALTER VIEW reorg.gidband OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gidzchn AS SELECT * FROM sds.gidzchn;
ALTER VIEW reorg.gidzchn OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_batch_error AS SELECT * FROM sds.gid_batch_error;
ALTER VIEW reorg.gid_batch_error OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_batch_record_validation AS SELECT * FROM sds.gid_batch_record_validation;
ALTER VIEW reorg.gid_batch_record_validation OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_batch_validation AS SELECT * FROM sds.gid_batch_validation;
ALTER VIEW reorg.gid_batch_validation OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_bl_dn AS SELECT * FROM sds.gid_bl_dn;
ALTER VIEW reorg.gid_bl_dn OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_bl_geb AS SELECT * FROM sds.gid_bl_geb;
ALTER VIEW reorg.gid_bl_geb OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_clearing AS SELECT * FROM sds.gid_clearing;
ALTER VIEW reorg.gid_clearing OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_clearing_mail AS SELECT * FROM sds.gid_clearing_mail;
ALTER VIEW reorg.gid_clearing_mail OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_data AS SELECT * FROM sds.gid_data;
ALTER VIEW reorg.gid_data OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_datauser AS SELECT * FROM sds.gid_datauser;
ALTER VIEW reorg.gid_datauser OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_datauser2 AS SELECT * FROM sds.gid_datauser2;
ALTER VIEW reorg.gid_datauser2 OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_pw AS SELECT * FROM sds.gid_pw;
ALTER VIEW reorg.gid_pw OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.gid_user AS SELECT * FROM sds.gid_user;
ALTER VIEW reorg.gid_user OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.konfig AS SELECT * FROM sds.konfig;
ALTER VIEW reorg.konfig OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.liefnt AS SELECT * FROM sds.liefnt;
ALTER VIEW reorg.liefnt OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.liefnt_gid AS SELECT * FROM sds.liefnt_gid;
ALTER VIEW reorg.liefnt_gid OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.liefnt_srq AS SELECT * FROM sds.liefnt_srq;
ALTER VIEW reorg.liefnt_srq OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.mesg AS SELECT * FROM sds.mesg;
ALTER VIEW reorg.mesg OWNER TO scd_testuser;
/*CREATE OR REPLACE VIEW reorg.pgid AS SELECT * FROM sds.pgid;
ALTER VIEW reorg.pgid OWNER TO scd_testuser;*/
CREATE OR REPLACE VIEW reorg.sgid_err AS SELECT * FROM sds.sgid_err;
ALTER VIEW reorg.sgid_err OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.stmgen AS SELECT * FROM sds.stmgen;
ALTER VIEW reorg.stmgen OWNER TO scd_testuser;
CREATE OR REPLACE VIEW reorg.stmgendn AS SELECT * FROM sds.stmgendn;
ALTER VIEW reorg.stmgendn OWNER TO scd_testuser; 
CREATE OR REPLACE VIEW reorg.tcgids AS SELECT * FROM sds.tcgids;
ALTER VIEW reorg.tcgids OWNER TO scd_testuser;



/* Section 3.4 - REORG Procedure Creation */

-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=demchdc178x.dc4ca.siemens.de;port=1521;service_name=SDS_PROD

SET client_encoding TO 'UTF8';

SET search_path = reorg,oracle,public;

SET check_function_bodies = false;





CREATE OR REPLACE PROCEDURE reorg.copy_data_4_parser () AS $body$
DECLARE

   vActDate		timestamp;

BEGIN

    EXECUTE 'DROP INDEX "REORG"."IX_GID_DATA_TEST_DELETEDATE"';
    EXECUTE 'DROP INDEX "REORG"."IX_GID_DATA_TEST_GID"';
    EXECUTE 'DROP INDEX "REORG"."IX_GID_DATA_TEST_LEAVEDATE"';
    EXECUTE 'DROP INDEX "REORG"."IX_GID_DATA_TEST_OWNER"';
    EXECUTE 'DROP INDEX "REORG"."IX_GID_DATA_TEST_VALIDDATE"';
    EXECUTE 'DROP INDEX "REORG"."IX_GID_DN_TEST"';

	SELECT clock_timestamp() INTO STRICT vActDate;
	dbms_output.put_line('vor Truncate: ' || to_char(vActDate,'YYYY-MM-DD HH24:MI:SS'));
	EXECUTE 'TRUNCATE TABLE GID_DATA_TEST';

	SELECT clock_timestamp() INTO STRICT vActDate;
	dbms_output.put_line('vor insert: ' || to_char(vActDate,'YYYY-MM-DD HH24:MI:SS'));

	EXECUTE 'ALTER TABLE gid_data_test NOLOGGING';
	INSERT INTO gid_data_test(APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE) SELECT
		APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE 
		FROM gid_data where coalesce(delete_date::text, '') = ''
		FETCH FIRST 1000000 ROWS ONLY;
	COMMIT;	

	INSERT INTO gid_data_test(APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE) SELECT
		APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE 
		FROM gid_data where coalesce(delete_date::text, '') = ''
		OFFSET 1000000 ROWS FETCH NEXT 1000000 ROWS ONLY;
		COMMIT;

		INSERT INTO gid_data_test(APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE) SELECT
		APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE 
		FROM gid_data where coalesce(delete_date::text, '') = ''
		OFFSET 2000000 ROWS FETCH NEXT 1000000 ROWS ONLY;
		COMMIT;

		INSERT INTO gid_data_test(APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE) SELECT
		APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE 
		FROM gid_data where coalesce(delete_date::text, '') = ''
		OFFSET 3000000 ROWS FETCH NEXT 1000000 ROWS ONLY;
		COMMIT;

		INSERT INTO gid_data_test(APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE) SELECT
		APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE 
		FROM gid_data where coalesce(delete_date::text, '') = ''
		OFFSET 4000000 ROWS FETCH NEXT 1000000 ROWS ONLY;
		COMMIT;

		INSERT INTO gid_data_test(APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE) SELECT
		APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE 
		FROM gid_data where coalesce(delete_date::text, '') = ''
		OFFSET 5000000 ROWS FETCH NEXT 1000000 ROWS ONLY;
		COMMIT;

		INSERT INTO gid_data_test(APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE) SELECT
		APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE 
		FROM gid_data where coalesce(delete_date::text, '') = ''
		OFFSET 6000000 ROWS FETCH NEXT 1000000 ROWS ONLY;
		COMMIT;

        INSERT INTO gid_data_test(APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE) SELECT
		APPL_INTERNAL_ID,
		APPL_NAME,
		C,
		CONFIRM_DATE,
		CONFIRMED,
		DELETE_DATE,
		DELETE_UID,
		GID,
		ISINSCD,
		JOIN_DATE,
		L,
		LEAVE_DATE,
		MODIFY_DATA_DATE,
		MODIFY_DATA_UID,
		O,
		OU,
		OWNER,
		SCD,
		SPONSOR,
		SYNC_DATE,
		USER_TYPE,
		VALID_DATE 
		FROM gid_data where coalesce(delete_date::text, '') = ''
		OFFSET 7000000 ROWS FETCH NEXT 1000000 ROWS ONLY;
		COMMIT;

        EXECUTE 'CREATE INDEX "REORG"."IX_GID_DATA_TEST_DELETEDATE" ON "REORG"."GID_DATA_TEST" ("DELETE_DATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DATA" 
  PARALLEL 4 ';

  EXECUTE 'CREATE INDEX "REORG"."IX_GID_DATA_TEST_GID" ON "REORG"."GID_DATA_TEST" ("GID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DATA" ';

  EXECUTE 'CREATE INDEX "REORG"."IX_GID_DATA_TEST_LEAVEDATE" ON "REORG"."GID_DATA_TEST" ("LEAVE_DATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DATA" 
  PARALLEL 4 ';

  EXECUTE 'CREATE INDEX "REORG"."IX_GID_DATA_TEST_OWNER" ON "REORG"."GID_DATA_TEST" ("OWNER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 37748736 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DATA" 
  PARALLEL 4 ';

  EXECUTE 'CREATE INDEX "REORG"."IX_GID_DATA_TEST_VALIDDATE" ON "REORG"."GID_DATA_TEST" ("VALID_DATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DATA" 
  PARALLEL 4 ';

  EXECUTE 'CREATE INDEX "REORG"."IX_GID_DN_TEST" ON "REORG"."GID_DATA_TEST" ("C", "O", "OU", "L") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 178257920 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DATA" 
  PARALLEL 4 ';


	EXECUTE 'ALTER TABLE gid_data_test LOGGING';

    EXECUTE 'DROP INDEX "REORG"."IX_GID_SURNAME_TEST"';
    EXECUTE 'DROP INDEX "REORG"."IX_GID_GIVEN_NAME_TEST"';

	SELECT clock_timestamp() INTO STRICT vActDate;
	dbms_output.put_line('nach insert: ' || to_char(vActDate,'YYYY-MM-DD HH24:MI:SS'));

	SELECT clock_timestamp() INTO STRICT vActDate;
	dbms_output.put_line('vor truncate: ' || to_char(vActDate,'YYYY-MM-DD HH24:MI:SS'));
	EXECUTE 'TRUNCATE TABLE gid_user_test';	

	dbms_output.put_line('vor insert: ' || to_char(vActDate,'YYYY-MM-DD HH24:MI:SS'));

	INSERT /*+ ignore_row_on_dupkey_index(gid_user_test,IX_GID_USER_TEST_GID) */ INTO gid_user_test PERFORM * FROM gid_user order by creation_date asc FETCH FIRST 1000000 ROWS ONLY;
    COMMIT;

    INSERT /*+ ignore_row_on_dupkey_index(gid_user_test,IX_GID_USER_TEST_GID) */ INTO gid_user_test PERFORM * FROM gid_user order by creation_date asc OFFSET 1000000 ROWS FETCH NEXT 1000000 ROWS ONLY;
    COMMIT;

     INSERT /*+ ignore_row_on_dupkey_index(gid_user_test,IX_GID_USER_TEST_GID) */ INTO gid_user_test PERFORM * FROM gid_user order by creation_date asc OFFSET 2000000 ROWS FETCH NEXT 1000000 ROWS ONLY;
    COMMIT;

  EXECUTE 'CREATE INDEX "REORG"."IX_GID_GIVEN_NAME_TEST" ON "REORG"."GID_USER_TEST" ("GIVEN_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 37748736 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DATA" 
  PARALLEL 4 ';

  EXECUTE 'CREATE INDEX "REORG"."IX_GID_SURNAME_TEST" ON "REORG"."GID_USER_TEST" ("SURNAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 35651584 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DATA" 
  PARALLEL 4 ';

	dbms_output.put_line('nach insert: ' || to_char(vActDate,'YYYY-MM-DD HH24:MI:SS'));


	--BEGIN
	--	EXECUTE IMMEDIATE 'DE gid_data_test';
	--EXCEPTION WHEN OTHERS THEN NULL;
	--END;
	-- EXECUTE IMMEDIATE 'CREATE TABLE gid_data_test AS SELECT * FROM gid_data';
	-- EXECUTE IMMEDIATE 'ALTER TABLE gid_data_test ADD  id NUMBER GENERATED ALWAYS as IDENTITY(START WITH 1 INCREMENT BY 1)';
    -- EXECUTE IMMEDIATE 'CREATE INDEX IX_GID_DATA_TEST_GID ON GID_DATA_TEST(gid)';
	-- EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX IX_GID_DATA_TEST_GID ON GID_DATA_TEST(id)';
	--BEGIN
	--	EXECUTE IMMEDIATE 'DROP TABLE gid_user_test';
	--EXCEPTION WHEN OTHERS THEN NULL;
	--END;
	--EXECUTE IMMEDIATE 'CREATE TABLE gid_user_test AS SELECT * FROM gid_user';
END;
$body$
LANGUAGE PLPGSQL
;
ALTER PROCEDURE reorg.copy_data_4_parser () OWNER TO scd_testuser;
-- REVOKE ALL ON PROCEDURE reorg.copy_data_4_parser () FROM PUBLIC;










